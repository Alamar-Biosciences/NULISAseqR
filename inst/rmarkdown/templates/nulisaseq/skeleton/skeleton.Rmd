---
params:
  study_name: ""
  outfolder: './'
  assayName: ""
  ## directory where xml files are located
  dataDir: '.'
  # xmlFiles: !r NULL
  xmlFiles: !r c('detectability_P1_Tr03.xml', 'detectability_P2_Tr03.xml')
  dataRuns: NULL 
  ## manually set plate ID, otherwise plate ID will be 
  ## "Plate 1", "Plate 2", ... according to order of filenames 
  plateNames: !r NULL
  # assay run information
  # a list (for each run) of lists (assay run date, assay instrument)
  assayRunInfo: !r NULL
  # assayRunInfo: !r list(list('5/23/2025', 'SN27'), list('5/28/2025', 'SN21'), list('5/28/2025', 'SN21'))
  ## type of report
  ## options:
  ## internal
  ## WebApp
  # reportType: "webApp"
  reportType: "internal"
  advancedQC: !r FALSE
  # advancedQC: !r TRUE
  ## internal control name(s) e.g. "mCherry", "NIC_1", "NIC_3" 
  # first IC will be used for LOD calculations (should typically be mCherry)
  IC: !r NULL # c("mCherry")
  ## string(s) that denotes inter-plate controls
  IPC: !r NULL # c("IPC")
  ## string(s) that denotes negative controls
  NC: !r NULL # c("NC") 
  ## string(s) that denotes sample controls
  SC: !r NULL # c("SC")
  ## string(s) that denotes bridge samples
  Bridge: !r NULL
  ## variables in XML that indicate row, column, and plate ID
  rowAnnotName: "AUTO_WELLROW"
  colAnnotName: "AUTO_WELLCOL"
  plateAnnotName: "AUTO_PLATE"
  ## older version names for row, column, plate ID variables
  # rowAnnotName: "Annot2"
  # colAnnotName: "Annot3"
  # plateAnnotName: "Annot1"
  # optional list of names of samples to exclude
  ## excludeSamples: !r list(c('A_01_C001 P3', 'A_02_C044 P1'), c('A_01_C040 P1'))
  excludeSamples: !r NULL
  ## excludeTargets: !r list(c('IL16', 'IL9'), c('KDR'))
  excludeTargets: !r NULL
  # Optional list of lists defining targets and corresponding NCs to exclude
  # during LoD calculations
  # ignoreTargetBlank: !r list(list("AGER" = c("SMI_E12_NTC_rep01"), "ANXA1" = c("SMI_H12_NTC_rep04")), list())
  ignoreTargetBlank: !r NULL
  # Optional numeric input parameter that determines the minimum number of blanks/NCs needed
  # to enable MAD outlier detection and removal
  # Defaults to 4
  minBlankNoMAD: !r 4
  # Un-adjusted p-value cutoff for identifying targets that have overall plate (or instrument) effects in the ANOVA -- pairwise tests are only done for these targets
  plate_effect_pval_ANOVA: 0.01
  # Tukey-adjusted p-value cutoff for identifying targets that have batch effects in the pairwise test
  plate_effect_pval_pairwise: 0.01
  # ICC threshold for the ICC percentage of random batch effect to generate a batch effect QC flag
  plate_effect_icc_threshold: 10
  # batch effect QC warning will be applied if plate has >= this percent of significant targets
  plate_effect_sig_pct_threshold: 10
  # batch effect limit the maximum number of target boxplots that will be shown
  plate_effect_max_target_boxplots: 30
  ## sampleGroupCovar -- Specify the covariate to retrieve sample group information.
  # this information is used when determining detectability.
  # defaults to SAMPLE_MATRIX
  sampleGroupCovar: SAMPLE_MATRIX
  # sampleGroupCovar: CONDITION_1
  # sampleGroupCovar: !r NULL
  # when sampleGroupCovar is not NULL, batch effect test will only be done for 
  # plate_effect_group. this is a level of sampleGroupCovar
  # if NULL, batch effect test will only be done for the group with maximum number of samples
  # if there are ties, then will use first group alphabetically
  plate_effect_group: !r NULL
  outRunSummary: !r TRUE
  outPlateLayout: !r TRUE
  outReadSummary: !r TRUE
  outHeatmaps: !r TRUE
  outQC: !r TRUE
  outDetectability: !r TRUE
  # output the intra-plate CV section
  outIntraPlateNorm: !r TRUE
  # output the inter-plate CV section
  outInterPlateNorm: !r TRUE
  outSampleBoxplot: !r TRUE
  outSampleCorrelation: !r TRUE
  outSampleClustering: !r TRUE
  outSamplePCA: !r TRUE
  outPlateEffect: !r TRUE
  ## should heatmaps show % median units?
  heatMapRel: !r TRUE
  ## outputPlots -- if TRUE will output a set of plots in a nice format for slides
  outputPlots: !r TRUE
  ## outputDetectCSV
  # if TRUE, outputs a CSV file with detectability for each target and sample type
  outputDetectCSV: !r TRUE
  ## outputCoefVarCSV
  # if TRUE, outputs a CSV file with intraCV and interCV for each target and sample type
  outputCoefVarCSV: !r TRUE
  ## Include SC / IPC ration graphic in the report
  # If TRUE, generates a plot of SC / IPC ratios and log2 ratios for each target and plate
  out_SC_IPC_Ratio: !r TRUE
  ## Include SC / NC ration graphic in the report
  # If TRUE, generates a plot of SC / NC ratios and log2 ratios for each target and plate
  out_SC_NC_Ratio: !r TRUE
  ## output_SC_IPC_Ratio_CSV
  # if TRUE, outputs a CSV file with SC / IPC log2 ratio for each target and plate
  output_SC_IPC_Ratio_CSV: !r TRUE
  ## output_SC_NC_Ratio_CSV
  # if TRUE, outputs a CSV file with SC / NC log2 ratio for each target and plate
  output_SC_NC_Ratio_CSV: !r TRUE
  ## outputPlateEffectCSV
  # if TRUE, outputs a CSV file with F-test results for each target and inter CVs for each target
  outputPlateEffectCSV: !r TRUE
  ## outputRData
  # if TRUE, outputs an RData file with entire report data
  outputRData: !r TRUE
  ## set to TRUE if this is being rendered by a Shiny wrapper (adds progress bar)
  rendered_by_shiny: !r FALSE
  ## set to TRUE if this is report for TAP, will highlight in yellow fields for client report
  highlight_TAP_report_fields: !r FALSE
  ## if TRUE, will sort runs in order of plate name using order()
  # sort_by_plateNames: !r TRUE
  sort_by_plateNames: !r TRUE
output:
  html_document:
    toc: yes
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    self_contained: true
    mode: selfcontained
date: "`r Sys.Date()`"
---


```{r setup, include=FALSE}
# Set cache to FALSE (sometimes chunks cached near the end are cached inconsistently (ChatGPT))
knitr::opts_chunk$set(echo = FALSE, cache = FALSE)

if(params$rendered_by_shiny) {
  knitr::opts_chunk$set(dev = 'ragg_png')
}
# Running pngquant reduces the size of inline pngs, use this hook to automatically run it (if it exists) during rendering
options(pdf.compress=FALSE) # let pngquant do the compression
knitr::knit_hooks$set(
  plot = local({
    hook_old <- knitr::knit_hooks$get('plot')
    function(x, options) {
      if(nzchar(Sys.which("pngquant"))) {
        file_size <- file.info(x)$size
        if(file_size > 50000) { # Only compress files > 50kb
          exit_code <- system2("pngquant", 
                               args = c("--force", "--ext", ".png", "--skip-if-larger", 
                                        "--quality=70-90", shQuote(x)))
          if (exit_code != 0) {
            warning(sprintf("pngquant failed for image '%s' with exit code %d", 
                            x, exit_code))
          }
        }
      }
      hook_old(x, options)
    }
  }),
  time_it = local({
    now <- NULL
    function(before, options) {
      if (before) {
        now <<- Sys.time()
      } else {
        res <- difftime(Sys.time(), now, units = "secs")
        message(options$label, ": ",
                round(res, 2), " sec")
        # Return NULL so nothing extra is added to output
        NULL
      }
    }
  })
)

knitr::opts_chunk$set(time_it=TRUE)
knitr::knit_engines$set(future = function(options) {
  future::future({
    knitr::engine_output(options, options$code, eval(parse(text = options$code)))
  })
})

library(NULISAseqR)
library(kableExtra)
# pander removed - using base R cat() for markdown generation
library(grid)
library(gdata)
library(dplyr)
library(ggplot2)
library(tibble)
library(reactable)
library(future)
library(future.apply)
library(plotly)
library(qs2)
library(future.callr)

.original_future_plan <- if ("future" %in% loadedNamespaces()) future::plan() else NULL

# Set controlled worker count
workers_count <- if (params$rendered_by_shiny) {
  2  # Conservative for Shiny
} else {
  min(parallelly::availableCores(), 4)  # Cap for standalone
}

plan(callr, workers = workers_count)

# Create a new TMPDIR to prevent potential concurrency / race conditions (ChatGPT)
Sys.setenv(TMPDIR = file.path(getwd(), paste0("tmp_", Sys.getpid())))
dir.create(Sys.getenv("TMPDIR"), showWarnings = FALSE)
```

```{r helper-functions, include=FALSE}
#' Combine multiple data frames by column, matching on row names
#'
#' Takes a list of data frames and combines them by column, using row names to match rows.
#' All data frames must have row names. Missing values are filled with NA.
#'
#' @param data A list of data frames to combine
#' @return A single data frame containing all columns from input data frames, with rows matched by row names
#' @examples
#' df1 <- data.frame(a=1:3, row.names=c("x","y","z"))
#' df2 <- data.frame(b=4:6, row.names=c("x","y","z"))
#' combineCols(list(df1, df2))
if (params$rendered_by_shiny) shiny::setProgress(0.05, message = "Setting up ...")
combineCols <- function(data){
  dataOut <- lapply(data, function(df) {
    df <- as.data.frame(df)
    df$rowname <- rownames(df)
    df
  })
  
  # Merge all by 'rowname', keeping all rows
  merged <- suppressWarnings(Reduce(function(x, y) merge(x, y, by = "rowname", all = TRUE), dataOut))
  
  # Set rownames and drop the helper column
  rownames(merged) <- merged$rowname
  merged$rowname <- NULL
  dataOut <- merged
  return(dataOut)
}

# function for putting wells in plate layout order
# sampleTypeFactor should have levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC')
wellorder <- function(samples, sampleTypeFactor=NULL, index=F){
  cols <- formatC(as.numeric(samples$AUTO_WELLCOL), width=2, flag=0)
  rows <- samples$AUTO_WELLROW
  inds <- if(is.null(sampleTypeFactor)){
    sort(paste0(rows, cols), index.return=TRUE)
  } else sort(paste0(as.numeric(sampleTypeFactor), rows, cols), index.return=TRUE)
  if(index){
    return(inds$ix)
  }
  else{
    return(samples$sampleName[inds$ix])
  }
}

# function for colorizing wells in heatmap
wellcolors <- function(data, well_types, boxplot_colors){
  # all labels black by default
  colors <- rep("black", ncol(data))
  for (j in 1:length(well_types)){
    # save indices matching the given well type
    indices <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    # color well label to match well type
    if(length(indices) > 0){
      colors[indices] <- boxplot_colors[j+1]
    }
  }
  return(colors)
}

# function to convert data into matrix for plate layout and heatmap
matrixify <- function(runSamples, plate=FALSE){
  val <- matrix(rep(NA, 96), nrow=8)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  for(j in LETTERS[1:8]){
    for(k in 1:12){
      sample_jk <- runSamples$sampleName[runSamples$AUTO_WELLROW==j & as.numeric(runSamples$AUTO_WELLCOL)==k]
      if(length(sample_jk)!=0){
        val[rownames(val)==j, colnames(val)==k] <- sample_jk
      }
      if(plate && length(sample_jk) == 0){
        val[rownames(val)==j, colnames(val)==k] <- ""
      }
    }
  }
  return(val)
}

#' Generate formatted warning text for display above tables
#'
#' This function counts the number of warnings in a logical vector and returns a 
#' formatted summary string. If one or more warnings are present, the text is wrapped 
#' in an HTML `<span>` with customizable background and text colors for highlighting. 
#' Otherwise, a plain text summary is returned.
#'
#' @param highlight_warnings A logical vector indicating which entries should be counted 
#'   as warnings. `TRUE` values are counted; `NA` values are ignored.
#' @param textColor A string specifying the text color when warnings are highlighted 
#'   (default: `"white"`).
#' @param bgColor A string specifying the background color when warnings are highlighted 
#'   (default: `"red"`).
#'
#' @return A character string containing either plain text or an HTML-formatted span 
#'   showing the number of warnings.
#'
#' @examples
#' tableWarningText(c(TRUE, FALSE, TRUE))
#' tableWarningText(c(FALSE, FALSE))
#' tableWarningText(c(TRUE, TRUE, NA), textColor = "black", bgColor = "yellow")
tableWarningText <- function(highlight_warnings, textColor = "white", bgColor = "red", warningText="Number of warnings"){ 
  # Count the number of warnings
  warning_count <- sum(highlight_warnings, na.rm=TRUE)
  
  # Create and print warning summary
  if (warning_count > 0) {
    warning_summary <- paste0("<span style='background-color: ", bgColor, "; color: ", textColor, "; font-weight: bold; padding: 2px 4px;'>", warningText, ": ", warning_count, "</span>")
  } else {
    warning_summary <- paste0(warningText, ": ", warning_count)
  }
  return(warning_summary)
}

#' Format excluded items for display
#'
#' Takes excluded items (targets or samples) and formats them for display
#' in reports, creating a formatted string with plate names and excluded items.
#'
#' @param excluded_list A list of excluded items per plate (can be NULL)
#' @param plate_names A character vector of plate names to use as names
#' @param item_type A string describing the type of items (e.g., "Targets", "Samples")
#' @return NULL if excluded_list is NULL, otherwise returns a formatted string
formatExcludedItems <- function(excluded_list, plate_names, item_type = "Items") {
  if(is.null(excluded_list)) return(NULL)
  
  names(excluded_list) <- plate_names
  excluded_list <- excluded_list[sapply(excluded_list, function(x) length(x) > 0)]
  
  if(length(excluded_list) == 0) return(NULL)
  
  excluded_formatted <- mapply(function(name, values) paste0(name, ": ", paste(values, collapse = ", ")),
                               names(excluded_list), excluded_list,
                               SIMPLIFY = TRUE, USE.NAMES = FALSE)
  
  return(paste0(item_type, " excluded: ", paste(excluded_formatted, collapse = "; ")))
}

#' Print excluded targets message if any are excluded
#'
#' Convenience function that formats excluded targets and prints them using cat
#'
#' @param excluded_targets List of excluded targets per plate (can be NULL)
#' @param plate_names Character vector of plate names
printExcludedTargets <- function(excluded_targets, plate_names) {
  message <- formatExcludedItems(excluded_targets, plate_names, "Targets")
  if(!is.null(message)) {
    cat(message, "\n\n")
  }
}

#' Print excluded samples message if any are excluded
#'
#' Convenience function that formats excluded samples and prints them using cat
#'
#' @param excluded_samples List of excluded samples per plate (can be NULL)
#' @param plate_names Character vector of plate names
printExcludedSamples <- function(excluded_samples, plate_names) {
  message <- formatExcludedItems(excluded_samples, plate_names, "Samples")
  if(!is.null(message)) {
    cat(message, "\n\n")
  }
}

#' Format samples with zero reads for display
#'
#' Takes samples with zero reads and formats them for display in reports.
#'
#' @param zero_samples_list List of samples with zero reads per plate
#' @param message_prefix String to prefix the message with
#' @return Formatted string ready for display
formatZeroSamples <- function(zero_samples_list, message_prefix) {
  zero_samples_list <- zero_samples_list[sapply(zero_samples_list, function(x) length(x) > 0)]
  
  if(length(zero_samples_list) == 0) return(NULL)
  
  zero_samples_formatted <- mapply(function(name, values) paste0(name, ": ", paste(values, collapse = ", ")),
                                   names(zero_samples_list), zero_samples_list,
                                   SIMPLIFY = TRUE, USE.NAMES = FALSE)
  
  return(paste0(message_prefix, paste(zero_samples_formatted, collapse = "; ")))
}

#' Render a Reactable Table with Optional Hidden Columns and Row Highlighting
#'
#' Generates a styled HTML table using `reactable` with optional row names,
#' selective column hiding, and custom row styling.
#'
#' @param df A data.frame or coercible object containing the table data.
#' @param table_name A character string specifying the display title above the table.
#' @param table_id A character string for the HTML element ID (used for interactivity/styling).
#' @param highlight A list with three elements:
#'   - `Data`: A logical vector indicating which rows should be highlighted.
#'   - `bgColor`: A string specifying the background color for highlighted rows.
#'   - `textColor`: A string specifying the text color for highlighted rows.
#' @param first_colName Column name to use when rownames are added (default is "Target").
#' @param rownames Logical; whether to convert rownames to a column (default: TRUE).
#' @param validPageSizes Specifies valid choices for the number of rows to display (the maximum is automatically calculated based on the input data)
#' @param defaultPageSize An integer specifying the number of rows to show by default
#' @param searchLimit An integer specifying the maximum number of rows before showing a search bar
#'
#' @return An HTML tag list containing a title and a rendered interactive table.
#' @examples
#' render_table(df, "QC Summary", "qc_table", highlight = list(Data=c(TRUE,FALSE,FALSE,TRUE), bgColor="yellow", textColor="black"))

render_table <- function(df, table_name, table_id, highlight = NULL, first_colName="Target", rownames=TRUE, validPageSizes=c(10,25,50,100), defaultPageSize=10, searchLimit=10, HTML=FALSE, custom_columns=NULL, tooltips=NULL) {
  df2 <- df
  if (!is.data.frame(df2)){
    df2 <- as.data.frame(df)
    # Convert columns that can be safely coerced to numeric
    for (colname in names(df2)) {
      # Try coercing the column to numeric
      suppressWarnings(num_col <- as.numeric(df2[[colname]]))
      
      # If no NA is introduced (other than original NA), convert the column
      if (sum(is.na(num_col)) <= sum(is.na(df2[[colname]]))) {
        df2[[colname]] <- num_col
      }
      
    }
  }
  if(rownames){
    if(!is.null(rownames(df))){
      df2 <- tibble::rownames_to_column(df2, var = first_colName)
    }
  }
  if (nrow(df2) == 0) {
    pageSizeOptions <- c(defaultPageSize)  # Default page size for empty tables
  } else {
    pageSizeOptions <- unique(sort(c(validPageSizes[validPageSizes <= nrow(df2)], nrow(df2))))
  }
  
  row_style <- NULL
  hide_columns <- NULL
  if(!is.null(highlight)){
    newColName <- "StatusHide"
    df2[[newColName]] <- as.character(highlight$Data)
    hide_columns <- c(newColName)
    row_style <- highlight_rows(status_col=newColName, highlight_status="TRUE", bgColor=highlight$bgColor, textColor=highlight$textColor)
  }
  column_defs <- list()
  if(!is.null(hide_columns)){
    for (col in hide_columns){
      column_defs[[col]] <- colDef(show=FALSE)
    }
  }
  
  # Add tooltip support with click-to-expand
  if(!is.null(tooltips)){
    for (tooltip_col in names(tooltips)){
      tooltip_source_col <- tooltips[[tooltip_col]]
      # Hide the source column
      column_defs[[tooltip_source_col]] <- colDef(show=FALSE)
      # Add expandable cell to target column
      column_defs[[tooltip_col]] <- colDef(
        cell = JS(sprintf("
          function(cellInfo) {
            const [isExpanded, setIsExpanded] = React.useState(false);
            const detailText = cellInfo.row['%s'];

            return React.createElement(
              'div',
              { style: { cursor: 'pointer' } },
              React.createElement(
                'div',
                {
                  onClick: function() { setIsExpanded(!isExpanded); },
                  style: {
                    color: '#0066cc',
                    textDecoration: 'underline',
                    cursor: 'pointer'
                  },
                  title: 'Click to show/hide targets'
                },
                cellInfo.value
              ),
              isExpanded && React.createElement(
                'div',
                {
                  style: {
                    marginTop: '5px',
                    padding: '8px',
                    backgroundColor: '#f5f5f5',
                    border: '1px solid #ddd',
                    borderRadius: '3px',
                    fontSize: '0.9em',
                    maxHeight: '200px',
                    overflowY: 'auto',
                    whiteSpace: 'pre-wrap',
                    userSelect: 'text',
                    cursor: 'text'
                  }
                },
                detailText
              )
            )
          }
        ", tooltip_source_col)),
        html = TRUE
      )
    }
  }
  
  # Merge custom column definitions
  if(!is.null(custom_columns)){
    for (col_name in names(custom_columns)){
      column_defs[[col_name]] <- custom_columns[[col_name]]
    }
  }

  # Format columns that should display as integers (no decimal places)
  integer_columns <- c("missing", "Total wells", "Total targets")
  for(int_col in integer_columns){
    if(int_col %in% colnames(df2)){
      column_defs[[int_col]] <- colDef(format = colFormat(digits = 0))
    }
  }

  htmltools::tagList(
    htmltools::tags$p(style="font-size: 1.1em;", table_name),
    reactable(
      df2,
      elementId = table_id,
      columns=column_defs,
      defaultColDef = colDef(
        html = HTML,
        align = "right",
        minWidth = 50,
        format = colFormat(separators = TRUE, digits = 2),
        headerStyle = list(
          display = "flex",
          flexDirection = "column",
          justifyContent = "flex-end")
      ),
      bordered=FALSE,
      borderless=TRUE,
      striped = TRUE,
      rownames = FALSE,
      highlight = TRUE,
      compact = TRUE,
      fullWidth = TRUE,
      searchable = if(nrow(df2) <= searchLimit) FALSE else TRUE,
      pagination = TRUE,
      showPageSizeOptions = TRUE,
      pageSizeOptions = pageSizeOptions,
      defaultPageSize = defaultPageSize,
      rowStyle = row_style
    )
  )
}

#' Create JavaScript Row Highlighting Based on Column Values
#'
#' Generates a JavaScript function for conditional row styling in a `reactable` table,
#' highlighting rows where a specified column matches a given value.
#'
#' @param status_col The name of the column to evaluate (as a string).
#' @param highlight_status The target value in `status_col` that triggers highlighting (default: "TRUE").
#' @param bgColor Background color for the highlighted row (default: "yellow").
#' @param textColor Text color for the highlighted row (default: "black").
#' @param bold Whether the highlighted text should be bold (default: "FALSE")
#'
#' @return A JavaScript function object created with `reactable::JS`.
#' @examples
#' highlight_rows("StatusHide", "TRUE")

highlight_rows <- function(status_col, highlight_status="TRUE", bgColor = "yellow", textColor = "black", bold = FALSE) {
  boldVal <- if(bold) "bold" else "normal"
  js_code <- 
    sprintf("
      function(rowInfo) {
        if (rowInfo.row['%s'] === '%s') {
          return { background: '%s', color: '%s', fontWeight: '%s' };
        }
        return null;
      }
    ", status_col, highlight_status, bgColor, textColor, boldVal)
  
  reactable::JS(js_code)
}
```

```{r load-data, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.1, message = "Parsing XML files ...")
# define sample specific boxplot colors for use in plots
#boxplot_colors <- unlist(lapply(alamarColorPalette(n=5, tint='light', nReps=5), function(x) x[4]))
boxplot_colors <- grDevices::hcl.colors(5, palette = "Set3")[c(4,3,1,5,2)]
if(is.null(params$dataRuns)){
  numFiles <- length(params$xmlFiles)
  # set data directory
  if(is.null(params$dataDir)){
    xmlFilesPath <- params$xmlFiles
  } else {
    knitr::opts_knit$set(root.dir=params$dataDir)
    # save xml file path
    xmlFilesPath <- paste0(params$dataDir, "/", params$xmlFiles)
  }
  # define variables to store results
  runs <- vector('list', numFiles)
  runSummaries <- vector('list', numFiles)
  read_summary <- NULL
  # read in XML files
  tempDir <- tempdir()
  
  
  runs <- future_lapply(seq_along(xmlFilesPath), function(i) {
    loadNULISAseq(
      xmlFilesPath[i],
      plateID = params$plateNames[i],
      NC = params$NC,
      SC = params$SC,
      IC = params$IC,
      IPC = params$IPC,
      Bridge = params$Bridge,
      sample_group_covar = params$sampleGroupCovar,
      excludeSamples = params$excludeSamples[[i]],
      excludeTargets = params$excludeTargets[[i]]
    )
  })
  for(i in 1:numFiles){
    AbsData <- runs[[i]]$AbsAssay
    Tcriteria <- QCTargetCriteria(AQ=AbsData, advancedQC=params$advancedQC)
    AQSC_SC <- ifelse(AbsData, "AQSC", "SC") 
    AQSC_SC_full <- ifelse(AbsData, "AQ sample controls (AQSC)", "Sample controls (SC)")
    CAL_IPC <- ifelse(AbsData, "CAL", "IPC") 
    CAL_IPC_full <- ifelse(AbsData, "Calibrator controls (CAL)", "Inter-plate controls (IPC)")
    
    # check if plate / row / col AnnotName match the data
    if(!(params$plateAnnotName %in% colnames(runs[[i]]$samples)) | !(params$rowAnnotName %in% colnames(runs[[i]]$samples)) | !(params$colAnnotName %in% colnames(runs[[i]]$samples))){
      stop('plate / row / col AnnotName do not match the data. Check and update params.')
    }
    
    # check and exclude samples if all NPQ values are 0 for each target
    runs[[i]]$zero_samples <- names(which(colSums(runs[[i]]$Data == 0) == nrow(runs[[i]]$Data)))
    if(length(runs[[i]]$zero_samples) != 0){
      runs[[i]]$samples <- runs[[i]]$samples[!(runs[[i]]$samples$sampleName %in% runs[[i]]$zero_samples),]
      runs[[i]]$SampleNames <- runs[[i]]$SampleNames[!(runs[[i]]$SampleNames %in% runs[[i]]$zero_samples)]
      runs[[i]]$Data <- runs[[i]]$Data[,!(colnames(runs[[i]]$Data) %in% runs[[i]]$zero_samples)]
    }
    
    # check and exclude samples with 0 IC reads
    runs[[i]]$IC_zero_samples <- colnames(runs[[i]]$Data)[runs[[i]]$Data[runs[[i]]$IC, ] == 0]
    if(length(runs[[i]]$IC_zero_samples) != 0){
      runs[[i]]$samples <- runs[[i]]$samples[!(runs[[i]]$samples$sampleName %in% runs[[i]]$IC_zero_samples),]
      runs[[i]]$SampleNames <- runs[[i]]$SampleNames[!(runs[[i]]$SampleNames %in% runs[[i]]$IC_zero_samples)]
      runs[[i]]$Data <- runs[[i]]$Data[,!(colnames(runs[[i]]$Data) %in% runs[[i]]$IC_zero_samples)]
    }
    
    # summarize each plate
    runSummaries[[i]] <- plateSummary(runs[[i]], IC=runs[[i]]$IC)
    read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
    if(is.null(runs[[i]]$samples[["AUTO_PLATE"]]) & !is.null(params$plateAnnotName) & length(params$plateNames) == 0){
      runs[[i]]$samples$AUTO_PLATE <- eval(str2expression(paste0("runs[[i]]$samples$", params$plateAnnotName)))
    } else if (length(params$plateNames) > 0){
      runs[[i]]$samples$AUTO_PLATE <- params$plateNames[i]
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLROW"]]) & !is.null(params$rowAnnotName)){
      runs[[i]]$samples$AUTO_WELLROW <- eval(str2expression(paste0("runs[[i]]$samples$", params$rowAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLCOL"]]) & !is.null(params$colAnnotName)){
      runs[[i]]$samples$AUTO_WELLCOL <- eval(str2expression(paste0("runs[[i]]$samples$", params$colAnnotName)))
    }
  } # end loop over xml files
} else { # passed in runs[[i]] from SAM, etc.
  runs <- params$dataRuns
  numFiles <- length(runs)
  runSummaries <- vector('list', numFiles)
  read_summary <- NULL
  for(i in 1:numFiles){
    runSummaries[[i]] <- plateSummary(runs[[i]], IC=runs[[i]]$IC)
    read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
    if(is.null(runs[[i]]$samples[["AUTO_PLATE"]]) & !is.null(params$plateAnnotName)){
      runs[[i]]$samples$AUTO_PLATE <- eval(str2expression(paste0("runs[[i]]$samples$", params$plateAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLROW"]]) & !is.null(params$rowAnnotName)){
      runs[[i]]$samples$AUTO_WELLROW <- eval(str2expression(paste0("runs[[i]]$samples$", params$rowAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLCOL"]]) & !is.null(params$colAnnotName)){
      runs[[i]]$samples$AUTO_WELLCOL <- eval(str2expression(paste0("runs[[i]]$samples$", params$colAnnotName)))
    }
  } # end loop over xml files
}

# set plate names based on first unique AUTO_PLATE variable, if present
PlateNames <- sapply(runs, function(x) {
  plate_name_i <- unique(x$samples$AUTO_PLATE)[1]
  if(is.null(plate_name_i)) plate_name_i <- NA
  return(plate_name_i)
})
PlateNameMessage <- NULL
# if any of these is NA or any duplicates, define plate names manually
if(any(is.na(PlateNames)) | any(duplicated(PlateNames))) {
  PlateNames <- paste0('Plate_', formatC(1:numFiles, width=2, format='d', flag='0'))
  if(numFiles > 99) PlateNames <- paste0('Plate_', formatC(1:numFiles, width=3, format='d', flag='0'))
  PlateNameMessage <- 'NOTE: Plate ID variable had missing or duplicate entries so plate IDs were automatically assigned.'
}

xmlFiles <- params$xmlFiles

# sort plates if specified
if(!is.null(params$assayRunInfo)) assayRunInfo <- params$assayRunInfo
if(params$sort_by_plateNames){
  orderIndex <- order(PlateNames)
  runs <- runs[orderIndex]
  runSummaries <- runSummaries[orderIndex]
  read_summary <- read_summary[, orderIndex]
  PlateNames <- PlateNames[orderIndex]
  xmlFiles <- xmlFiles[orderIndex] 
  if(!is.null(params$assayRunInfo)) assayRunInfo <- assayRunInfo[orderIndex]
}
# add plate names to runs and read summaries
names(runs) <- names(runSummaries) <- PlateNames
if(length(PlateNames) > 1 ){
  colnames(read_summary) <- PlateNames
}
# transpose read summary
read_summary <- t(read_summary)
# set multiple file indicator
multipleFiles <- if(numFiles > 1) TRUE else FALSE
# set SC indicator
indicatorSC <- all(sapply(runs, function(x) length(x$SC) > 0))

# set Bridge indicator
indicatorBridge <- if(sum(sapply(runs, function(x) length(x$Bridge)))==0) FALSE else TRUE
```

```{r intraPlateNorm, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.2, message = "Performing Normalization ...")
# do intra-plate normalization
intraPlateNormData <- vector("list", numFiles)
for (i in 1:numFiles){
  intraPlateNormData[[i]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                                            method="IC",
                                            IC=runs[[i]]$IC)
}
names(intraPlateNormData) <- PlateNames
```

```{r interPlateNorm, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.3, message = "Performing Normalization ...")
# do inter-plate normalization 
# save IC-normalized data in a list
normData <- lapply(intraPlateNormData, function(x) x$normData)

# save IPC, NC, etc wells for each plate
IPC_wells <- lapply(runs, function(x) x$IPC)
NC_wells <- lapply(runs, function(x) x$NC)
SC_wells <- lapply(runs, function(x) x$SC)
Bridge_wells <- lapply(runs, function(x) x$Bridge)

# IC + IPC
IC_IPC <- interPlateNorm(data_list=normData,
                         IPC=TRUE, IN=FALSE,
                         IPC_wells=IPC_wells,
                         IPC_method='median')

# IC + IN
IC_IN <- interPlateNorm(data_list=normData,
                        IPC=TRUE, IN=TRUE,
                        IPC_wells=IPC_wells,
                        NC_wells=NC_wells)

if(indicatorBridge==TRUE){
  IC_Bridge <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=TRUE,
                              IN_samples=Bridge_wells)
}
```

```{r calculate-LOD, include=FALSE}
# calculate LOD on the IPC normalized data
targetNoOutlierDetection <- lapply(seq_len(numFiles), function(i) {
  names(which(apply(runs[[i]]$Data[, runs[[i]]$NC] < 100, 1, all)))
})

plate_lod <- lapply(seq_len(numFiles), function(i) {
  lod(
    data_matrix          = IC_IPC$interNormData[[i]],
    blanks               = runs[[i]]$NC,
    min_count            = 0,
    min_blank_no         = params$minBlankNoMAD,
    ignore_target_blank  = params$ignoreTargetBlank[[i]],
    targetNoOutlierDetection = targetNoOutlierDetection[[i]],
    match_matrix         = runs[[i]]$match_matrix
  )
})

# extract and clean blank_outlier_table
blank_outlier_table <- lapply(seq_along(plate_lod), function(i) {
  tbl <- plate_lod[[i]]$blank_outlier_table
  if (!is.null(tbl) && nrow(tbl) > 0) {
    tbl$Run <- PlateNames[i]
    tbl <- tbl[, c(5, 1:4)]
    rownames(tbl) <- NULL
    tbl
  } else {
    NULL
  }
})

# drop NULLs and bind together
blank_outlier_table <- do.call(rbind, blank_outlier_table[!sapply(blank_outlier_table, is.null)])

```

```{r intraCV, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.4, message = "Performing Normalization ...")

# calculate intra-plate CVs on unnormalized and IC normalized data
# using IPCs and SCs (sample controls) if present
IPC_intraCV_unnorm <- IPC_intraCV_IC <- NULL
if(indicatorSC==TRUE){
  SC_intraCV_unnorm <- SC_intraCV_IC <- NULL
}
# loop through plates and calculate CVs
for (i in 1:numFiles){
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(runs[[i]]$samples))
  IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$SC] <- 'SC'
  }
  # unnormalized intraCV
  # Create vector of targets to exclude: IC + hidden targets + user excluded targets
  targets_to_exclude <- c(runs[[i]]$IC, runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)])
  if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[i]])) {
    targets_to_exclude <- c(targets_to_exclude, params$excludeTargets[[i]])
  }
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                  samples=IPC_SC_samples,
                                  aboveLOD=plate_lod[[i]]$aboveLOD,
                                  exclude_targets=targets_to_exclude)
  # combine plates into one matrix
  IPC_intraCV_unnorm <- combineCols(list(IPC_intraCV_unnorm, plate_unnorm_intraCV[,'IPC'])) 
  if(indicatorSC==TRUE){
    SC_intraCV_unnorm <- combineCols(list(SC_intraCV_unnorm, plate_unnorm_intraCV[,'SC']))
  }
  # IC intraCV
  plate_IC_INtraCV <- intraCV(data_matrix=intraPlateNormData[[i]]$normData,
                              samples=IPC_SC_samples,
                              aboveLOD=plate_lod[[i]]$aboveLOD,
                              exclude_targets=targets_to_exclude)
  # combine plates into one matrix
  IPC_intraCV_IC <- combineCols(list(IPC_intraCV_IC, plate_IC_INtraCV[,'IPC']))
  if(indicatorSC==TRUE){
    SC_intraCV_IC <- combineCols(list(SC_intraCV_IC, plate_IC_INtraCV[,'SC']))
  }
}
# set colnames
colnames(IPC_intraCV_unnorm) <- colnames(IPC_intraCV_IC) <- PlateNames
if(indicatorSC==TRUE){
  colnames(SC_intraCV_unnorm) <- colnames(SC_intraCV_IC) <- PlateNames
}
# if more than one plate, add Average column of mean intraCV
if(multipleFiles==TRUE){
  IPC_intraCV_unnorm <- cbind(IPC_intraCV_unnorm, Average=rowMeans(IPC_intraCV_unnorm, na.rm=TRUE))
  IPC_intraCV_IC <- cbind(IPC_intraCV_IC, Average=rowMeans(IPC_intraCV_IC, na.rm=TRUE))
  if(indicatorSC==TRUE){
    SC_intraCV_unnorm <- cbind(SC_intraCV_unnorm, Average=rowMeans(SC_intraCV_unnorm, na.rm=TRUE))
    SC_intraCV_IC <- cbind(SC_intraCV_IC, Average=rowMeans(SC_intraCV_IC, na.rm=TRUE))
  }
}

# create CV summary tables
IPC_intraCV_unnorm_summary_table <- column_summary_stats(IPC_intraCV_unnorm, n_digits=NULL)
IPC_intraCV_IC_summary_table <- column_summary_stats(IPC_intraCV_IC, n_digits=NULL)
if(indicatorSC==TRUE){
  SC_intraCV_unnorm_summary_table <- column_summary_stats(SC_intraCV_unnorm, n_digits=NULL)
  SC_intraCV_IC_summary_table <- column_summary_stats(SC_intraCV_IC, n_digits=NULL)
}
```

```{r interCV, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.45, message = "Calculating CVs ...")
# calculate inter-plate CVs on unnormalized, IC normalized,
# and inter-plate normalized data
# using IPCs and SCs (sample controls) if present
# get input data lists
IPC_SC_samples_list <- lapply(runs, function(x) {
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(x$samples))
  IPC_SC_samples[colnames(x$Data) %in% x$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(x$Data) %in% x$SC] <- 'SC'
  }
  return(IPC_SC_samples)
})
plateData <- lapply(runs, function(x) x$Data)
plate_IC <- lapply(intraPlateNormData, function(x) x$normData)
aboveLOD <- lapply(plate_lod, function(x) x$aboveLOD)
exclude_targets <- lapply(runs, function(x) x$IC)
hides <- lapply(runs, function(x) x$targets$targetName[which(x$targets$hide)])

# unnormalized interCV
interCV_unnorm <- interCV(data_list=plateData,
                          samples=IPC_SC_samples_list,
                          aboveLOD=aboveLOD,
                          exclude_targets=c(exclude_targets, hides),
                          useMean=FALSE)

# IC interCV
interCV_IC <- interCV(data_list=plate_IC,
                      samples=IPC_SC_samples_list,
                      aboveLOD=aboveLOD,
                      exclude_targets=c(exclude_targets, hides),
                      useMean=FALSE)

# IC + IPC interCV
interCV_IC_IPC<- interCV(data_list=IC_IPC$interNormData,
                         samples=IPC_SC_samples_list,
                         aboveLOD=aboveLOD,
                         exclude_targets=c(exclude_targets, hides),
                         useMean=FALSE)

# IC + IN interCV
interCV_IC_IN<- interCV(data_list=IC_IN$interNormData,
                        samples=IPC_SC_samples_list,
                        aboveLOD=aboveLOD,
                        exclude_targets=c(exclude_targets, hides),
                        useMean=FALSE)

if(indicatorBridge==FALSE){
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_IC[,'IPC'],
                               interCV_IC_IPC[,'IPC'])
  
  colnames(IPC_interCV_results) <- c('unnorm',
                                     'IC',
                                     paste0('IC + ', CAL_IPC))
  if (params$reportType == "internal"){
    IPC_interCV_results <- cbind(IPC_interCV_results, interCV_IC_IN[,'IPC'])
    colnames(IPC_interCV_results)[ncol(IPC_interCV_results)] <- 'IC + IN'
  }
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results, n_digits=NULL)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_IC[,'SC'],
                                interCV_IC_IPC[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'IC',
                                      paste0('IC + ', CAL_IPC))
    if (params$reportType == "internal"){
      SC_interCV_results <- cbind(SC_interCV_results, interCV_IC_IN[,'SC'])
      colnames(SC_interCV_results)[ncol(SC_interCV_results)] <- 'IC + IN'
    }
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results, n_digits=NULL)
  }
}

if(indicatorBridge==TRUE){
  # IC + Bridge
  interCV_IC_Bridge <- interCV(data_list=IC_Bridge$interNormData,
                               samples=IPC_SC_samples_list,
                               aboveLOD=aboveLOD,
                               exclude_targets=c(exclude_targets, hides),
                               useMean=FALSE)
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_IC[,'IPC'],
                               interCV_IC_IPC[,'IPC'],
                               interCV_IC_IN[,'IPC'],
                               interCV_IC_Bridge[,'IPC'])
  
  colnames(interCV_results) <- c('unnorm',
                                 'IC',
                                 paste0('IC + ', CAL_IPC),
                                 'IC + IN',
                                 'IC + Bridge')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results, n_digits=NULL)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_IC[,'SC'],
                                interCV_IC_IPC[,'SC'],
                                interCV_IC_IN[,'SC'],
                                interCV_IC_Bridge[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'IC',
                                      paste0('IC + ', CAL_IPC),
                                      'IC + IN',
                                      'IC + Bridge')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results, n_digits=NULL)
  }
}
```

```{r SC-IPC-ratios, include=FALSE}
IC_name <- Reduce(intersect, lapply(runs, function(x) x$IC))
if(indicatorSC){
  # calculate SC / IPC ratios for plots
  SC_IPC_ratios <- lapply(runs, function(x){
    SC_means <- apply(x$IC_normed$normData[,x$SC], 1, mean, na.rm=TRUE)
    IPC_means <- apply(x$IC_normed$normData[,x$IPC], 1, mean, na.rm=TRUE)
    SC_IPC_ratios <- log2(SC_means / IPC_means)
    SC_IPC_ratios[is.infinite(SC_IPC_ratios)] <- NA
    return(SC_IPC_ratios)
  })
  
  if(numFiles > 1){
    SC_IPC_ratio_matrix <- combineCols(SC_IPC_ratios)
    colnames(SC_IPC_ratio_matrix) <- PlateNames
    # Create vector of all targets to exclude: IC + hidden targets + user excluded targets
    all_exclude_targets <- IC_name
    for(i in seq_along(runs)) {
      all_exclude_targets <- c(all_exclude_targets, runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)])
      if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[i]])) {
        all_exclude_targets <- c(all_exclude_targets, params$excludeTargets[[i]])
      }
    }
    all_exclude_targets <- unique(all_exclude_targets)
    # remove excluded targets
    SC_IPC_ratio_table <- SC_IPC_ratio_matrix[!(rownames(SC_IPC_ratio_matrix) %in% all_exclude_targets),]
    # reverse ordering for plot
    SC_IPC_ratio_matrix <- t(apply(SC_IPC_ratio_table, 1, rev))
    SC_IPC_ratio_matrix <- apply(SC_IPC_ratio_matrix, 2, rev)
  } else if(numFiles==1){
    # Create vector of all targets to exclude: IC + hidden targets + user excluded targets
    all_exclude_targets <- c(IC_name, runs[[1]]$targets$targetName[which(runs[[1]]$targets$hide)])
    if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[1]])) {
      all_exclude_targets <- c(all_exclude_targets, params$excludeTargets[[1]])
    }
    all_exclude_targets <- unique(all_exclude_targets)
    SC_IPC_ratio_table <- SC_IPC_ratios[[1]][!(names(SC_IPC_ratios[[1]]) %in% all_exclude_targets)]
    SC_IPC_ratio_matrix <- data.frame(rev(SC_IPC_ratio_table))
    SC_IPC_ratio_table <- data.frame(SC_IPC_ratio_table)
    colnames(SC_IPC_ratio_matrix) <- PlateNames[1]
    colnames(SC_IPC_ratio_table) <- PlateNames[1]
  }
}
```

```{r SC-NC-ratios, include=FALSE}
IC_name <- Reduce(intersect, lapply(runs, function(x) x$IC))
if(indicatorSC){
  # calculate SC / NC ratios for plots
  SC_NC_ratios <- lapply(runs, function(x){
    SC_means <- apply(x$IC_normed$normData[,x$SC], 1, mean, na.rm=TRUE)
    NC_means <- apply(x$IC_normed$normData[,x$NC], 1, mean, na.rm=TRUE)
    SC_NC_ratios <- log2(SC_means / NC_means)
    SC_NC_ratios[is.infinite(SC_NC_ratios)] <- NA
    return(SC_NC_ratios)
  })
  
  # identify targets with NC mean = 0
  NC_mean_zero <- lapply(runs, function(x){
    NC_means <- apply(x$IC_normed$normData[,x$NC], 1, mean, na.rm=TRUE)
    NC_mean_zero <- NC_means == 0
    return(NC_mean_zero)
  })
  
  if(numFiles > 1){
    SC_NC_ratio_matrix <- combineCols(SC_NC_ratios)
    colnames(SC_NC_ratio_matrix) <- PlateNames
    NC_mean_zero <- combineCols(NC_mean_zero)
    NC_mean_zero_targets <- apply(NC_mean_zero, 1, any)
    NC_mean_zero_targets <- names(NC_mean_zero_targets)[NC_mean_zero_targets]
    # Create vector of all targets to exclude: IC + hidden targets + user excluded targets
    all_exclude_targets <- IC_name
    for(i in seq_along(runs)) {
      all_exclude_targets <- c(all_exclude_targets, runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)])
      if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[i]])) {
        all_exclude_targets <- c(all_exclude_targets, params$excludeTargets[[i]])
      }
    }
    all_exclude_targets <- unique(all_exclude_targets)
    # remove excluded targets
    SC_NC_ratio_table <- SC_NC_ratio_matrix[!(rownames(SC_NC_ratio_matrix) %in% all_exclude_targets),]
    # reverse ordering for plot
    SC_NC_ratio_matrix <- t(apply(SC_NC_ratio_table, 1, rev))
    SC_NC_ratio_matrix <- apply(SC_NC_ratio_matrix, 2, rev)
  } else if(numFiles==1){
    # Create vector of all targets to exclude: IC + hidden targets + user excluded targets
    all_exclude_targets <- c(IC_name, runs[[1]]$targets$targetName[which(runs[[1]]$targets$hide)])
    if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[1]])) {
      all_exclude_targets <- c(all_exclude_targets, params$excludeTargets[[1]])
    }
    all_exclude_targets <- unique(all_exclude_targets)
    SC_NC_ratio_table <- SC_NC_ratios[[1]][!(names(SC_NC_ratios[[1]]) %in% all_exclude_targets)]
    SC_NC_ratio_matrix <- data.frame(rev(SC_NC_ratio_table))
    NC_mean_zero_targets <- NC_mean_zero[[1]]
    NC_mean_zero_targets <- names(NC_mean_zero_targets)[NC_mean_zero_targets]
    SC_NC_ratio_table <- data.frame(SC_NC_ratio_table)
    colnames(SC_NC_ratio_matrix) <- PlateNames[1]
    colnames(SC_NC_ratio_table) <- PlateNames[1]
  }
}
```

```{r detectability, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.5, message = "Calculating Detectability ...")

# calculate detectability on regular samples only
# NOTE: we may also want to add detectability_summary for IPCs, SCs, and Bridge samples

# Collect all noDetectability targets across all runs for filtering
all_noDetectability_targets <- unique(unlist(lapply(runs, function(x) {
  x$targets$targetName[which(x$targets$noDetectability)]
})))

# initialize data stores
detectability_return_summary <- list()
detectability_return_targets <- list()

for (i in 1:numFiles){
  detectability_summary <- detectability_targets <- NULL
  
  # column names of return data
  col_names_targets <- NULL
  col_names_summary <- c('type', '# samples', 'mean', 'sd', 'median',
                         'min', 'max', '# of detectable targets (%)')
  
  # retrieve sample type group information accurately
  if (is.null(params$sampleGroupCovar)){
    sample_groups <- NULL
  } else{
    # get sample group assignment for only the samples, not the controls
    sample_groups <- runs[[i]]$samples[runs[[i]]$samples$sampleName %in% runs[[i]]$SampleNames, params$sampleGroupCovar]
  }
  
  # run detectability calculation -- note that controls are excluded
  # Create vector of targets to exclude: IC + hidden targets + no detectability targets + user excluded targets
  targets_to_exclude <- c(runs[[i]]$IC, runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)], runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)])
  if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[i]])) {
    targets_to_exclude <- c(targets_to_exclude, params$excludeTargets[[i]])
  }
  plate_detect <- detectability(aboveLOD_matrix=plate_lod[[i]]$aboveLOD,
                                sample_subset=runs[[i]]$SampleNames,
                                sample_groups=sample_groups,
                                exclude_targets=targets_to_exclude)
  
  # add all sample type/identity detectability data
  raw_detectability <- plate_detect$all$detectability
  detectability <- cbind('all',
                         plate_detect$all$sampleNumber,
                         format(round(mean(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                         format(round(sd(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                         formatC(median(raw_detectability, na.rm=TRUE), width=2),
                         formatC(min(raw_detectability, na.rm=TRUE), width=2),
                         formatC(max(raw_detectability, na.rm=TRUE), width=2),
                         paste0(sum(raw_detectability > 50, na.rm=TRUE),
                                ' / ', sum(!is.na(raw_detectability)),
                                ' (',
                                format(round(sum(raw_detectability > 50, na.rm=TRUE)/sum(!is.na(raw_detectability)) * 100, 1), nsmall=1),
                                '%)'))
  col_names_targets <- c(col_names_targets, "all")
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_targets <- cbind(detectability_targets,
                                 format(round(raw_detectability, 1), nsmall=1))
  
  # check if both sample and all data present
  if (length(names(plate_detect)) == 2){
    for (j in names(plate_detect$sample_group$detectability)){
      raw_detectability <- plate_detect$sample_group$detectability[[j]]
      detectability <- cbind(j,
                             plate_detect$sample_group$sampleNumber[[j]],
                             format(round(mean(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                             format(round(sd(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                             formatC(median(raw_detectability, na.rm=TRUE), width=2),
                             formatC(min(raw_detectability, na.rm=TRUE), width=2),
                             formatC(max(raw_detectability, na.rm=TRUE), width=2),
                             paste0(sum(raw_detectability > 50, na.rm=TRUE),
                                    ' / ', sum(!is.na(raw_detectability)), 
                                    ' (',
                                    format(round(sum(raw_detectability > 50, na.rm=TRUE)/sum(!is.na(raw_detectability)) * 100, 1), nsmall=1),
                                    '%)'))
      col_names_targets <- c(col_names_targets, j)
      detectability_summary <- rbind(detectability_summary, detectability)
      detectability_targets <- cbind(detectability_targets,
                                     format(round(raw_detectability, 1), nsmall=1))
    }
  }
  
  # update column names
  colnames(detectability_summary) <- col_names_summary
  colnames(detectability_targets) <- col_names_targets
  
  # update return data
  detectability_return_summary[[PlateNames[i]]] <- detectability_summary
  detectability_return_targets[[PlateNames[i]]] <- detectability_targets
}

# if more than one plate, summarize across plates with detectability_summary function:
combine_detectability <- FALSE
if(numFiles > 1){
  
  # Call the detectability_summary function
  combined_detect <- detectability_summary(runs)
  
  # Extract detectability data from combined_detect
  all_detect <- combined_detect$all$detectability
  
  # Check if sample groups exist before accessing
  sample_group_detect <- if(!is.null(combined_detect$sample_group)) {
    combined_detect$sample_group$detectability
  } else {
    NULL
  }
  
  # Merge all and sample_group detectability data
  # Start with the "all" column
  overall_matrix <- data.frame(
    Target = all_detect$Target,
    all = all_detect[, 2]  # The detectability column
  )
  
  # Add sample group columns if they exist
  if(!is.null(sample_group_detect)){
    # Extract just the detectability columns (not the Target column)
    sample_group_cols <- sample_group_detect[, -1, drop = FALSE]
    
    # Get clean column names (remove the " (n = X)" part)
    clean_names <- gsub(" \\(n = \\d+\\)", "", colnames(sample_group_cols))
    
    # Add to overall matrix with clean names
    for(j in 1:ncol(sample_group_cols)){
      overall_matrix[[clean_names[j]]] <- sample_group_cols[, j]
    }
  }
  
  # Convert to matrix and format as character with proper decimal places
  rownames(overall_matrix) <- overall_matrix$Target
  overall_matrix <- overall_matrix[, -1, drop = FALSE]  # Remove Target column
  overall_matrix <- as.matrix(overall_matrix)
  
  # Format to match the desired structure: right-aligned with 1 decimal place
  # Handle NA values properly
  overall_matrix <- apply(overall_matrix, 2, function(x) {
    formatted <- ifelse(is.na(x), 
                        "",  
                        format(round(x, 1), nsmall = 1, width = 5, justify = "right"))
    return(formatted)
  })
  
  # Assign to detectability_return_targets
  # Filter out noDetectability targets
  overall_matrix <- overall_matrix[!(rownames(overall_matrix) %in% all_noDetectability_targets), , drop = FALSE]
  detectability_return_targets[["Overall"]] <- overall_matrix

  # Create summary statistics from the combined detectability
  detectability_summary_overall <- NULL
  
  # For "all" samples - use the actual values from all_detect
  all_detect_col <- colnames(all_detect)[2]  # Get the actual column name
  all_detect_values <- all_detect[[all_detect_col]]
  n_valid <- sum(!is.na(all_detect_values))
  
  if(n_valid > 0){
    n_detectable <- sum(all_detect_values > 50, na.rm=TRUE)
    detectable_pct <- format(round(n_detectable / n_valid * 100, 1), nsmall=1)
    mean_val <- format(round(mean(all_detect_values, na.rm=TRUE), 1), nsmall=1)
    sd_val <- format(round(sd(all_detect_values, na.rm=TRUE), 1), nsmall=1)
    median_val <- formatC(round(median(all_detect_values, na.rm=TRUE), 1), width=2)
    min_val <- formatC(round(min(all_detect_values, na.rm=TRUE), 1), width=2)
    max_val <- formatC(round(max(all_detect_values, na.rm=TRUE), 1), width=2)
  } else {
    n_detectable <- 0
    detectable_pct <- ""
    mean_val <- sd_val <- median_val <- min_val <- max_val <- ""
  }
  
  detectability_summary_row <- cbind(
    "all",
    combined_detect$all$sampleNumber,
    mean_val,
    sd_val,
    median_val,
    min_val,
    max_val,
    paste0(n_detectable, ' / ', n_valid, ' (', detectable_pct, '%)')
  )
  detectability_summary_overall <- rbind(detectability_summary_overall, detectability_summary_row)
  
  # If sample groups exist, add those too
  if(!is.null(combined_detect$sample_group)){
    for(group_name in names(combined_detect$sample_group$sampleNumber)){
      # Find the column by the group name (accounting for the naming pattern)
      group_col_pattern <- paste0("^", group_name, " \\(n = \\d+\\)$")
      group_col_idx <- grep(group_col_pattern, colnames(sample_group_detect))
      
      # Check if column was found
      if(length(group_col_idx) == 0){
        warning(paste("Column not found for group:", group_name))
        next
      }
      
      group_detect_values <- sample_group_detect[[group_col_idx]]
      
      # Handle edge case where all values are NA (denominator would be 0)
      n_valid <- sum(!is.na(group_detect_values))
      
      if(n_valid > 0){
        n_detectable <- sum(group_detect_values > 50, na.rm=TRUE)
        detectable_pct <- format(round(n_detectable / n_valid * 100, 1), nsmall=1)
        mean_val <- format(round(mean(group_detect_values, na.rm=TRUE), 1), nsmall=1)
        sd_val <- format(round(sd(group_detect_values, na.rm=TRUE), 1), nsmall=1)
        median_val <- formatC(round(median(group_detect_values, na.rm=TRUE), 1), width=2)
        min_val <- formatC(round(min(group_detect_values, na.rm=TRUE), 1), width=2)
        max_val <- formatC(round(max(group_detect_values, na.rm=TRUE), 1), width=2)
      } else {
        n_detectable <- 0
        detectable_pct <- ""
        mean_val <- sd_val <- median_val <- min_val <- max_val <- ""
      }
      
      detectability_summary_row <- cbind(
        group_name,
        combined_detect$sample_group$sampleNumber[[group_name]],
        mean_val,
        sd_val,
        median_val,
        min_val,
        max_val,
        paste0(n_detectable, ' / ', n_valid, ' (', detectable_pct, '%)')
      )
      detectability_summary_overall <- rbind(detectability_summary_overall, detectability_summary_row)
    }
  }
  
  colnames(detectability_summary_overall) <- col_names_summary
  detectability_return_summary[["Overall"]] <- detectability_summary_overall
  
  # identify all sample types
  unique_types <- unique(unlist(lapply(detectability_return_summary, function(x) x[, "type"])))
  
  # present data tables better if all plates have the same sample type
  # applicable only if sample group information is provided and/or all samples are
  # of the same group (e.g., plasma)
  if (length(unique_types) <= 2){
    # summary data
    all_rows <- lapply(detectability_return_summary,
                       function(plate) plate[plate[, "type"] == "all", ])
    combined_all_matrix <- do.call(rbind, all_rows)
    detectability_return_summary[["Combined"]] <- combined_all_matrix
    
    # detectability targets
    all_cols <- lapply(detectability_return_targets,
                       function(plate) plate[, "all"])
    combined_all_matrix <- combineCols(all_cols)
    # Filter out noDetectability targets
    combined_all_matrix <- combined_all_matrix[!(rownames(combined_all_matrix) %in% all_noDetectability_targets), , drop = FALSE]
    detectability_return_targets[["Combined"]] <- combined_all_matrix
    colnames(detectability_return_targets[["Combined"]]) <- names(all_cols)

    combine_detectability <- TRUE
  }
}
```

```{r transform-data, include=FALSE}
# log transform and scale data for clustered heatmap
# and sample correlation plot
data_IC_IPC_log2_scaled <- list()
data_IC_IPC_log2_no_NC_scaled <- list()
for(i in 1:numFiles){
  data_IC_IPC<- IC_IPC$interNormData[[i]]
  # remove ICs
  data_IC_IPC<- data_IC_IPC[!grepl(paste(runs[[i]]$IC, collapse="|"), rownames(data_IC_IPC)),]
  # remove NCs to calculate center and scale (so NCs don't skew the scale parameters)
  data_IC_IPC_no_NC <- data_IC_IPC[,!grepl(paste(runs[[i]]$NC, collapse="|"), colnames(data_IC_IPC))]
  data_IC_IPC_log2_no_NC_scaled[[i]] <- t(scale(t(log2(data_IC_IPC_no_NC + 1)),
                                                center=TRUE, scale=TRUE))
  # log transform and scale targets
  data_IC_IPC_log2_scaled[[i]] <- t(scale(t(log2(data_IC_IPC+ 1)),
                                          center=attributes(data_IC_IPC_log2_no_NC_scaled[[i]])$`scaled:center`, 
                                          scale=attributes(data_IC_IPC_log2_no_NC_scaled[[i]])$`scaled:scale`))
}

# define title
assayName <- if(!is.null(params$assayName)) params$assayName else runs[[1]]$ExecutionDetails$Assay
title_var <- paste(params$study_name, assayName, sep='<br>')
```

```{r calculate-top-reads, include=TRUE, eval=params$reportType=='internal'}
# calculate top 10 targets that take up most % raw reads
# Note: do not exclude targets that were specified in excludeTargets parameter
# get raw reads for all targets / samples
# only do if params$dataRuns is NULL AND at least one of params$excludeTargets or params$excludeSamples is not NULL
if(is.null(params$dataRuns) && (!is.null(params$excludeTargets) || !is.null(params$excludeSamples))){
  all_raw_reads <- future_lapply(seq_along(xmlFilesPath), function(i) {
    readNULISAseq(
      xmlFilesPath[i],
      plateID = params$plateNames[i],
      NC = params$NC,
      SC = params$SC,
      IC = params$IC,
      IPC = params$IPC,
      Bridge = params$Bridge
    )$Data
  })
} else { # if dataRuns is input or if there are no exclusions we use the Data from runs
  all_raw_reads <- lapply(runs, function(x) x$Data)
}

total_reads_per_target <- lapply(all_raw_reads, function(x) format(sort(apply(x, 1, sum, na.rm=TRUE), decreasing=TRUE)[1:10], big.mark=',', scientific=FALSE, trim=TRUE))
pct_reads_per_target <- lapply(all_raw_reads, function(x) paste0(sprintf("%.1f", round(sort(apply(x, 1, sum, na.rm=TRUE) / sum(x, na.rm=TRUE) * 100, decreasing=TRUE)[1:10], 1)), '%'))
top_targets_names <- lapply(total_reads_per_target, function(x) names(x))
top_targets_table <- do.call(rbind, Map(function(x, y, z) paste(x, y, z, sep = "<br>"), top_targets_names, pct_reads_per_target, total_reads_per_target))
grand_totals <- format(sapply(runs, function(x) sum(x$Data, na.rm=TRUE)), big.mark=',', scientific=FALSE, trim=TRUE)
top_targets_table <- cbind(grand_totals, top_targets_table)
colnames(top_targets_table) <- c('Grand Total', seq_len(ncol(top_targets_table) - 1))

# calculate top 10 samples that take up most % raw reads
total_reads_per_sample <- lapply(all_raw_reads, function(x) format(sort(apply(x, 2, sum, na.rm=TRUE), decreasing=TRUE)[1:10], big.mark=',', scientific=FALSE))
pct_reads_per_sample <- lapply(all_raw_reads, function(x) paste0(sprintf("%.1f", round(sort(apply(x, 2, sum, na.rm=TRUE) / sum(x, na.rm=TRUE) * 100, decreasing=TRUE)[1:10], 1)), '%'))
top_samples_names <- lapply(total_reads_per_sample, function(x) names(x))
top_samples_table <- do.call(rbind, Map(function(x, y, z) paste(x, y, z, sep = "<br>"), top_samples_names, pct_reads_per_sample, total_reads_per_sample))
grand_totals <- format(sapply(runs, function(x) sum(x$Data, na.rm=TRUE)), big.mark=',', scientific=FALSE, trim=TRUE)
top_samples_table <- cbind(grand_totals, top_samples_table)
colnames(top_samples_table) <- c('Grand Total', 1:10)
```

```{r make-output-directory, include=FALSE}
# make directory -- we will put the file in the outputFiles directory
if(params$reportType != "webApp"){
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
}
```

```{r plate-effect-test, include=FALSE, eval=(params$outPlateEffect & multipleFiles)}
if(multipleFiles){
  # perform batch effect test if indicated
  #####################################
  ## ORGANIZE DATA
  #####################################
  # combine sample metadata
  sample_metadata_cols <- Reduce(intersect, lapply(lapply(runs, function(x) x$samples), function(x) colnames(x)))
  sample_metadata <- do.call(rbind, lapply(runs, function(x) x$samples[,sample_metadata_cols]))
  # create a plateEffectID variable
  plateEffectID <- rep(PlateNames, sapply(runs, function(x) nrow(x$samples)))
  # remove any spaces
  plateEffectID <- gsub(' ', '_', plateEffectID)
  unique_plateEffectID <- unique(plateEffectID)
  sample_metadata$plateEffectID <- factor(plateEffectID, levels=unique_plateEffectID)
  sample_metadata$full_sampleName <- paste0(sample_metadata$plateEffectID, '_', sample_metadata$sampleName)
  rownames(sample_metadata) <- sample_metadata$full_sampleName
  # combine IC-IPC normalized data into one matrix
  # Exclude IC controls, hidden targets, and noDetectability targets
  # Collect noDetectability targets for reporting
  batch_effect_noDetectability_targets <- unique(unlist(lapply(runs, function(x) {
    x$targets$targetName[which(x$targets$noDetectability)]
  })))

  plate_test_data_list <- lapply(1:numFiles, function(i) {
    targets_to_exclude <- c(runs[[i]]$IC,
                            runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)],
                            runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)])
    data <- IC_IPC$log2_interNormData[[i]][!(rownames(IC_IPC$log2_interNormData[[i]]) %in% targets_to_exclude), ]
    colnames(data) <- paste0(unique_plateEffectID[i], '_', colnames(data))
    data
  })
  
  plate_test_data <- plate_test_data_list[[1]]
  for(i in 2:length(plate_test_data_list)){
    # Get common rownames between current data and next plate
    common_rows <- intersect(rownames(plate_test_data), rownames(plate_test_data_list[[i]]))
    
    if(length(common_rows) < 2){ # discount the IC control {
      stop(paste("No matching row names found between plate", i-1, "and plate", i))
    }
    
    # Subset both matrices to common rows before merging
    plate_test_data <- plate_test_data[common_rows,]
    next_plate_data <- plate_test_data_list[[i]][common_rows,]
    
    # Merge the subsetted data
    plate_test_data <- merge(plate_test_data, next_plate_data, by='row.names')
    rownames(plate_test_data) <- plate_test_data[,1]
    plate_test_data <- plate_test_data[,2:ncol(plate_test_data)]
  }
  # omit control samples 
  sample_metadata <- sample_metadata[toupper(sample_metadata$sampleType)=='SAMPLE',]
  # omit any samples that are not matching 
  samples_omitted <- sample_metadata[!(sample_metadata$full_sampleName %in% colnames(plate_test_data)),]
  sample_metadata <- sample_metadata[sample_metadata$full_sampleName %in% colnames(plate_test_data),]
  plate_test_data <- plate_test_data[,sample_metadata$full_sampleName]
  # only use samples in plate_effect_group
  if(!is.null(params$sampleGroupCovar)){
    if(is.null(params$plate_effect_group)){
      plate_effect_group <- names(sort(table(sample_metadata[,params$sampleGroupCovar]), decreasing=TRUE))[1]
    } else {
      plate_effect_group <- params$plate_effect_group
    }
    sample_metadata <- sample_metadata[sample_metadata[,params$sampleGroupCovar]==plate_effect_group,]
    plate_test_data <- plate_test_data[,sample_metadata$full_sampleName]
  }
  plate_test_data <- as.matrix(plate_test_data)
  sample_metadata$plateEffectID <- droplevels(sample_metadata$plateEffectID)
  unique_plateEffectID_old <- unique_plateEffectID
  unique_plateEffectID <- levels(sample_metadata$plateEffectID)
  plate_effect_PlateNames <- PlateNames[unique_plateEffectID_old %in% unique_plateEffectID]
  plate_effect_excluded_plates <- PlateNames[!(unique_plateEffectID_old %in% unique_plateEffectID)]


  # remove any targets with zero variance 
  plate_effect_remove_targets <- names(apply(plate_test_data, 1, sd))[apply(plate_test_data, 1, sd)==0]
  plate_test_data <- plate_test_data[!(rownames(plate_test_data) %in% plate_effect_remove_targets),]
  # plate by samples table
  plate_effect_n_samples_table <- as.data.frame(table(sample_metadata$plateEffectID))
  rownames(plate_effect_n_samples_table) <- NULL
  colnames(plate_effect_n_samples_table) <- c('PlateID', 'n samples')
  plate_effect_n_samples_table$`n samples` <- as.integer(plate_effect_n_samples_table$`n samples`)
  
  #####################################
  ## ANOVA PLATE EFFECT F TEST
  #####################################
  plate_effect_ftest <- lmNULISAseq(data=plate_test_data,
                                    sampleInfo=sample_metadata,
                                    sampleName_var = "full_sampleName",
                                    modelFormula = 'plateEffectID',
                                    reduced_modelFormula = '1',
                                    return_model_fits = TRUE,
                                    analysis_context = "Batch Effect")
  
  plate_effect_volcano_plot <- volcanoPlot(coefs=plate_effect_ftest$Fstats$Fstat, 
                                           p_vals = plate_effect_ftest$Fstats$Ftest_pval, 
                                           target_labels = plate_effect_ftest$Fstats$target,
                                           title = 'Batch effect ANOVA F-test',
                                           xlabel = 'F Statistic',
                                           ylabel = '-log10(p-value)',
                                           sig_label = paste0('p = ', params$plate_effect_pval_ANOVA), 
                                           sig_threshold = params$plate_effect_pval_ANOVA)
  
  #####################################
  ## POST HOC PAIRWISE TEST FOR SIGNIFICANT F TEST TARGETS
  #####################################
  plate_effect_sig_F_targets <- plate_effect_ftest$Fstats$target[plate_effect_ftest$Fstats$Ftest_pval < params$plate_effect_pval_ANOVA]
  n_significant_Ftest <- length(plate_effect_sig_F_targets)
  if(n_significant_Ftest > 0){
    
    if(all(is.na(plate_effect_sig_F_targets))){
      stop("The calculated Batch effects were all NA (check for identical XML input files)")
    }
    
    pairwise_tests <- lapply(plate_effect_ftest$modelFits[plate_effect_sig_F_targets], function(x){
      emm <- emmeans::emmeans(x, ~ plateEffectID)
      contrasts <- as.data.frame(pairs(emm))
      contrasts$sig_pval <- contrasts$p.value < params$plate_effect_pval_pairwise
      plate_effect_pct_sig <- data.frame(plate=unique_plateEffectID, pct_sig_pval=NA)
      for(p in 1:nrow(plate_effect_pct_sig)){
        plate_contrasts_pval <- contrasts$sig_pval[grep(plate_effect_pct_sig$plate[p], contrasts$contrast)]
        plate_effect_pct_sig$pct_sig_pval[p] <- sum(plate_contrasts_pval) / length(plate_contrasts_pval) * 100
      }
      plate_effect_pct_sig$plate_effect <- plate_effect_pct_sig$pct_sig_pval >= 50
      return(list(plate_effect_pct_sig=plate_effect_pct_sig,
                  contrasts=contrasts))
    })
    
  } else {
    # if no significant targets, create a dummy pairwise test table using first target
    pairwise_tests <- lapply(plate_effect_ftest$modelFits[1], function(x){
      emm <- emmeans::emmeans(x, ~ plateEffectID)
      contrasts <- as.data.frame(pairs(emm))
      contrasts$sig_pval <- contrasts$p.value < params$plate_effect_pval_pairwise
      plate_effect_pct_sig <- data.frame(plate=unique_plateEffectID, pct_sig_pval=NA)
      for(p in 1:nrow(plate_effect_pct_sig)){
        plate_contrasts_pval <- contrasts$sig_pval[grep(plate_effect_pct_sig$plate[p], contrasts$contrast)]
        plate_effect_pct_sig$pct_sig_pval[p] <- sum(plate_contrasts_pval) / length(plate_contrasts_pval) * 100
      }
      plate_effect_pct_sig$plate_effect <- plate_effect_pct_sig$pct_sig_pval >= 50
      return(list(plate_effect_pct_sig=plate_effect_pct_sig,
                  contrasts=contrasts))
    })
  }
  
  #####################################
  ## PLATE EFFECT SUMMARY TABLE
  #####################################
  plate_effect_summary_table <- data.frame(PlateID=unique_plateEffectID,
                                           plate_effect_QC=NA,
                                           n_sig_targets=NA,
                                           pct_sig_targets=NA,
                                           n_pct_sig_targets=NA,
                                           sig_targets=NA)
  plate_effect_sig_pairwise_targets <- c()
  for(i in 1:nrow(plate_effect_summary_table)){
    plate_name <- plate_effect_summary_table$PlateID[i]
    plate_sig_targets <- sapply(pairwise_tests, function(x) x$plate_effect_pct_sig[x$plate_effect_pct_sig$plate==plate_name,'plate_effect'])
    plate_effect_summary_table[i,'n_sig_targets'] <- sum(plate_sig_targets, na.rm=TRUE)
    plate_effect_summary_table[i,'pct_sig_targets'] <- plate_effect_summary_table[i,'n_sig_targets'] / nrow(plate_test_data) * 100
    if (plate_effect_summary_table[i,'pct_sig_targets'] < params$plate_effect_sig_pct_threshold) {
      plate_effect_summary_table[i,'plate_effect_QC'] <- 'Pass'
    } else {
      plate_effect_summary_table[i,'plate_effect_QC'] <- 'Warning'
    }
    plate_effect_summary_table[i,'n_pct_sig_targets'] <- paste0(plate_effect_summary_table[i,'n_sig_targets'], ' (', format(round(plate_effect_summary_table[i,'pct_sig_targets'], 1), nsmall=1), '%)')
    plate_effect_summary_table[i,'sig_targets'] <- paste0(names(plate_sig_targets)[plate_sig_targets==TRUE], collapse=', ')
    plate_effect_sig_pairwise_targets <- sort(unique(c(plate_effect_sig_pairwise_targets, names(plate_sig_targets)[plate_sig_targets==TRUE])))
  }
  
  #####################################
  ## FIT LMER MODELS RANDOM EFFECT 
  ## Random Plate
  #####################################
  # function to extract variance components and ICC for a single model
  get_variance_components <- function(model) {
    if (is.null(model)) return(NULL)
    
    vc <- as.data.frame(lme4::VarCorr(model))
    if (nrow(vc) == 0) return(NULL)
    
    # Calculate ICC for each random effect
    vc$ICC <- vc$vcov / sum(vc$vcov) *100
    
    return(vc)
  }
  # function to extract variance components for a single model type
  process_model_type <- function(model_fits, model_name) {
    if (is.null(model_fits)) {
      return(list(var_results = NULL, icc_summary = NULL))
    }
    
    valid_models <- lapply(model_fits, get_variance_components)
    
    if (length(valid_models) == 0) {
      return(list(var_results = NULL, icc_summary = NULL))
    }
    
    var_results <- tryCatch({
      bind_rows(valid_models, .id = "Target") %>%
        select(Target, Group = grp, Variance = vcov, ICC) %>%
        mutate(Model = model_name) %>%
        arrange(Target, Group)
    }, error = function(e) NULL)
    
    icc_summary <- tryCatch({
      var_results %>%
        group_by(Group, Model) %>%
        summarise(
          Mean_ICC = mean(ICC, na.rm = TRUE),
          Median_ICC = median(ICC, na.rm = TRUE),
          SD_ICC = sd(ICC, na.rm = TRUE),
          Min_ICC = min(ICC, na.rm = TRUE),
          Max_ICC = max(ICC, na.rm = TRUE),
          .groups = "drop"
        )
    }, error = function(e) NULL)
    
    list(var_results = var_results, icc_summary = icc_summary)
  }
  # function to make ICC scatterplot, high icc on the left
  generate_icc_scatterplot <- function(var_result_table, 
                                       effect_type,
                                       random_effect,
                                       icc_threshold = params$plate_effect_icc_threshold,
                                       plot_title_font_size = 16,
                                       plot_aspect_ratio = 1) {
    
    # Filter data - more robust handling
    plot_data <- var_result_table %>%
      filter(Group == effect_type,
             Model == random_effect) %>%
      mutate(
        High_ICC = ifelse(ICC > icc_threshold, "High", "Low"),
        Target = reorder(Target, -ICC)  # Highest ICC on left
      )
    
    # Early return if no data
    if (nrow(plot_data) == 0) {
      message("No data for ", random_effect, " in ", figure_name)
      return(NULL)
    }
    
    # Create plot
    plot <- ggplot(plot_data, aes(x = Target, y = ICC, color = High_ICC)) +
      geom_point() +
      ggrepel::geom_text_repel(
        data = ~ filter(.x, High_ICC == "High"),
        aes(label = Target),
        size = 3,
        max.overlaps = Inf,
        box.padding = 0.6,
        segment.color = "grey50"
      ) +
      scale_color_manual(values = c("High" = "darkred", "Low" = "grey60")) +
      labs(
        title = paste0("Variability Explained by ", random_effect),
        subtitle = paste("Targets with ICC >", icc_threshold, "% highlighted"),
        x = "Target",
        y = "ICC (%)"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face='bold', 
                                  size=plot_title_font_size),
        axis.text.x = element_blank(),
        legend.position = "none",
        aspect.ratio = plot_aspect_ratio,
        plot.margin = margin(4,4,4,4),
        panel.grid.major.x = element_blank()
      ) +
      geom_hline(yintercept = icc_threshold, color = "red", alpha = 0.7)
    
    return(invisible(plot))
  }
  
  # if no sampleGroupCovar indicated or only one unique category, fit model with no covariates
  plate_effect_icc_results <- vector(mode='list', length = 1)
  # fit model
  plate_effect_icc_results[[1]]$plate_test_lmer <- lmerNULISAseq(data=plate_test_data, 
                                                                 sampleInfo = sample_metadata[,c('full_sampleName', 'plateEffectID')], 
                                                                 sampleName_var = 'full_sampleName',
                                                                 modelFormula_fixed = "1",
                                                                 modelFormula_random = "(1|plateEffectID)",
                                                                 return_model_fits = TRUE)
  
  # ICC result and summary
  plate_effect_icc_results[[1]]$var_result <- process_model_type(plate_effect_icc_results[[1]]$plate_test_lmer$modelFits, 
                                                                 "Random PlateID")
  
  # make ICC scatterplot
  plate_effect_icc_results[[1]]$ICC_scatter <- generate_icc_scatterplot(var_result_table = plate_effect_icc_results[[1]]$var_result$var_results, 
                                                                        effect_type = "plateEffectID",
                                                                        random_effect = "Random PlateID")
  
  #####################################
  ## make matrix of target means by plate for heatmap and PCA by run
  #####################################
  target_means <- lapply(1:nrow(plate_test_data), function(x) {
    aggregate(plate_test_data[x,] ~ sample_metadata$plateEffectID, FUN='mean')[,2]
  })
  target_means <- do.call(cbind, target_means)
  colnames(target_means) <- rownames(plate_test_data)
  rownames(target_means) <- unique_plateEffectID
  # remove targets with zero variance
  target_means <- target_means[,!apply(target_means, 2, sd, na.rm=TRUE)==0]
  target_mean_pca <- prcomp(scale(target_means))
  
  # make a plate indicator for associating with sample PCA
  sample_metadata[unique_plateEffectID] <- lapply(unique_plateEffectID, function(x) sample_metadata$plateEffectID == x)
  
  #####################################
  # MAKE PLATE EFFECT TARGET TABLE
  #####################################
  # permutation F test results
  plate_effect_target_table <- plate_effect_ftest$Fstats[,c("target","Fstat","Ftest_pval")]
  plate_effect_target_table$Ftest_significant <- plate_effect_target_table$Ftest_pval < params$plate_effect_pval_ANOVA
  
  # add ICC from random batch effect
  plate_effect_target_table <- plate_effect_target_table %>% 
    left_join(
      plate_effect_icc_results[[1]]$var_result$var_results %>% 
        filter(Group == "plateEffectID") %>% 
        rename(target = Target) %>%
        mutate(
          ICC_plate_significant = ifelse(ICC > params$plate_effect_icc_threshold, TRUE, FALSE),
          ICC_plate = sprintf("%.1f", ICC)  # formats as "XX.X%"
        ) %>% 
        select(target, ICC_plate, ICC_plate_significant)
    )
  
  # add n pct plates with a significant pairwise test
  plate_effect_target_table$n_sig_pairwise <- NA
  plate_effect_target_table$pct_sig_pairwise <- NA
  for(i in 1:nrow(plate_effect_target_table)){
    target <- plate_effect_target_table$target[i]
    n_sig <- sum(grepl(target, plate_effect_summary_table$sig_targets), na.rm=TRUE)
    pct_sig <- n_sig / nrow(plate_effect_summary_table) * 100
    plate_effect_target_table$n_sig_pairwise[i] <- n_sig
    plate_effect_target_table$pct_sig_pairwise[i] <- round(pct_sig, 1)
  }
  
  # merge SC CV
  rownames(plate_effect_target_table) <- plate_effect_target_table$target
  if(indicatorSC){
    ind <- paste0("IC + ", CAL_IPC)
    # Check if SC_interCV_results has data before attempting merge
    if(nrow(SC_interCV_results) > 0 && ind %in% colnames(SC_interCV_results)){
      plate_effect_target_table <- merge(plate_effect_target_table, SC_interCV_results[, ind], by='row.names', all=TRUE)
      colnames(plate_effect_target_table)[colnames(plate_effect_target_table)=='y'] <- 'SC interCV'
      rownames(plate_effect_target_table) <- plate_effect_target_table$Row.names
      plate_effect_target_table <- plate_effect_target_table[,2:ncol(plate_effect_target_table)]
    }
  }
  
  # merge CV of sample means
  CV_of_target_sample_means <- apply(target_means, 2, function(x) sd((2^x - 1), na.rm=TRUE) / mean((2^x - 1), na.rm=TRUE) * 100)
  CV_of_target_sample_means <- data.frame(target=names(CV_of_target_sample_means),
                                          sample_mean_interCV=CV_of_target_sample_means)
  plate_effect_target_table <- merge(plate_effect_target_table, CV_of_target_sample_means)
  
  # median raw IPC reads by target and plate
  raw_IPC_reads <- lapply(runs[plate_effect_PlateNames], function(x){
    apply(x$Data[!rownames(x$Data) %in% x$IC, x$IPC], 1, median, na.rm=TRUE)
  })
  raw_IPC_reads <- combineCols(raw_IPC_reads)
  # number of plates with median IPC reads < 200
  low_raw_IPC_reads <- apply(raw_IPC_reads, 1, function(x) sum(x < 200, na.rm=TRUE))
  n_non_missing_raw_IPC_reads <- apply(raw_IPC_reads, 1, function(x) sum(!is.na(x)))
  low_raw_IPC_reads <- data.frame(target = names(low_raw_IPC_reads),
                                  n_plates_low_IPC = low_raw_IPC_reads,
                                  pct_plates_low_IPC = round(low_raw_IPC_reads / n_non_missing_raw_IPC_reads * 100, 1))
  low_raw_IPC_reads$n_pct_plates_low_IPC <- paste0(low_raw_IPC_reads$n_plates_low_IPC, ' (',
                                                   format(round(low_raw_IPC_reads$pct_plates_low_IPC, 1), nsmall=1, trim = TRUE), '%)')
  low_raw_IPC_reads$plate_names_low_IPC <- apply(raw_IPC_reads, 1, function(x) {
    paste0(PlateNames[x < 200 & !is.na(x)], collapse=', ')
  })
  plate_effect_target_table <- merge(plate_effect_target_table, low_raw_IPC_reads[,c("target","n_plates_low_IPC","pct_plates_low_IPC")])
  
  # median raw sample reads by target and plate
  raw_sample_reads <- lapply(runs[plate_effect_PlateNames], function(x){
    apply(x$Data[!rownames(x$Data) %in% x$IC, x$SampleNames, drop=FALSE], 1, median, na.rm=TRUE)
  })
  raw_sample_reads <- combineCols(raw_sample_reads)
  # number of plates with median IPC reads < 200
  low_raw_sample_reads <- apply(raw_sample_reads, 1, function(x) sum(x < 200, na.rm=TRUE))
  n_non_missing_raw_sample_reads <- apply(raw_sample_reads, 1, function(x) sum(!is.na(x)))
  low_raw_sample_reads <- data.frame(target = names(low_raw_sample_reads),
                                     n_plates_low_sample_reads = low_raw_sample_reads,
                                     pct_plates_low_sample_reads = round(low_raw_sample_reads / n_non_missing_raw_sample_reads * 100, 1))
  low_raw_sample_reads$n_pct_plates_low_sample_reads <- paste0(low_raw_sample_reads$n_plates_low_sample_reads, ' (',
                                                               format(round(low_raw_sample_reads$pct_plates_low_sample_reads, 1), nsmall=1, trim = TRUE), '%)')
  low_raw_sample_reads$plate_names_low_IPC <- apply(raw_sample_reads, 1, function(x) {
    paste0(PlateNames[x < 200 & !is.na(x)], collapse=', ')
  })
  plate_effect_target_table <- merge(plate_effect_target_table, low_raw_sample_reads[,c("target","n_plates_low_sample_reads","pct_plates_low_sample_reads")])
  
  # sort in order of Fstat
  plate_effect_target_table <- plate_effect_target_table[order(plate_effect_target_table$Fstat, decreasing=TRUE),]
  # round the values
  plate_effect_target_table$Fstat <- format(round(plate_effect_target_table$Fstat, 1), nsmall=1, trim=TRUE)
  plate_effect_target_table$Ftest_pval <- format(plate_effect_target_table$Ftest_pval, scientific=TRUE, digits=2, trim=TRUE)
  if(indicatorSC){
    plate_effect_target_table$`SC interCV` <- format(round(plate_effect_target_table$`SC interCV`, 1), nsmall=1, trim=TRUE)
  }
  plate_effect_target_table$sample_mean_interCV <- format(round(plate_effect_target_table$sample_mean_interCV, 1), nsmall=1, trim=TRUE)
  # add rownames 
  rownames(plate_effect_target_table) <- 1:nrow(plate_effect_target_table)
  
  # remove underscores from colnames
  colnames(plate_effect_target_table) <- gsub('_', ' ', colnames(plate_effect_target_table))
  colnames(plate_effect_target_table) <- gsub('pct', '%', colnames(plate_effect_target_table))
  
  #####################################
  # MAKE PLATE EFFECT PLATE TABLE
  #####################################
  # merge n samples with batch effect test result
  plate_effect_plate_table <- plate_effect_n_samples_table
  if(!is.null(params$assayRunInfo)) plate_effect_plate_table$instrument <- unlist(sapply(assayRunInfo, function(x) x[2]))
  plate_effect_plate_table <- merge(plate_effect_plate_table,
                                    plate_effect_summary_table, by='PlateID', sort=FALSE)
  
  # Ensure n samples remains as integer after merge
  plate_effect_plate_table$`n samples` <- as.integer(plate_effect_plate_table$`n samples`)
  
  plate_effect_plate_table$n_low_IPC_reads <- apply(raw_IPC_reads, 2, function(x) sum(x < 200 & !is.na(x)))
  plate_effect_plate_table$pct_low_IPC_reads <- plate_effect_plate_table$n_low_IPC_reads / apply(raw_IPC_reads, 2, function(x) sum(!is.na(x))) * 100
  plate_effect_plate_table$n_pct_low_IPC_reads <- paste0(plate_effect_plate_table$n_low_IPC_reads, ' (', format(round(plate_effect_plate_table$pct_low_IPC_reads, 1), nsmall=1, trim=TRUE), '%)')
  plate_effect_plate_table$low_IPC_reads_targets <- apply(raw_IPC_reads, 2, function(x) {
    paste0(names(x)[x < 200 & !is.na(x)], collapse=', ')
  })
  
  plate_effect_plate_table$n_low_sample_reads <- apply(raw_sample_reads, 2, function(x) sum(x < 200 & !is.na(x)))
  plate_effect_plate_table$pct_low_sample_reads <- plate_effect_plate_table$n_low_sample_reads / apply(raw_sample_reads, 2, function(x) sum(!is.na(x))) * 100
  plate_effect_plate_table$n_pct_low_sample_reads <- paste0(plate_effect_plate_table$n_low_sample_reads, ' (', format(round(plate_effect_plate_table$pct_low_sample_reads, 1), nsmall=1, trim=TRUE), '%)')
  plate_effect_plate_table$low_sample_reads_targets <- apply(raw_sample_reads, 2, function(x) {
    paste0(names(x)[x < 200 & !is.na(x)], collapse=', ')
  })
  
  # remove columns
  plate_effect_plate_table <- plate_effect_plate_table[,!colnames(plate_effect_plate_table) %in% c("n_low_IPC_reads", "pct_low_IPC_reads","n_low_sample_reads", "pct_low_sample_reads")]
  
  # remove underscores from colnames
  colnames(plate_effect_plate_table) <- gsub('_', ' ', colnames(plate_effect_plate_table))
  colnames(plate_effect_plate_table) <- gsub('pct', '%', colnames(plate_effect_plate_table))
  
  #####################################
  # MAKE PLATE EFFECT PLATE SUMMARY TABLE
  #####################################
  plate_effect_QC_summary <- plate_effect_plate_table[,c("PlateID","plate effect QC","n % sig targets")]
  
  #####################################
  # BOXPLOTS FOR SIGNIFICANT TARGETS -- save names and n significant 
  #####################################
  if(!is.null(plate_effect_sig_pairwise_targets)){
    # set number of boxplots to plot
    # only make plot if significant pairwise test and 
    # ICC > threshold
    plate_effect_boxplot_targets <- plate_effect_target_table$target[plate_effect_target_table$`ICC plate significant`==TRUE & plate_effect_target_table$`n sig pairwise` > 0]
    # For each significant target, get plates that have significant test
    pairwise_sig_plates <- lapply(pairwise_tests[plate_effect_boxplot_targets], function(x){
      x$plate_effect_pct_sig$plate[x$plate_effect_pct_sig$plate_effect]
    })
  }
} # end if multipleFiles
```

```{r instrument-effect-test, include=FALSE, eval=(params$outPlateEffect & multipleFiles)}
if(is.null(params$assayRunInfo)){
  instrument_names <- NA
}
if(multipleFiles & !is.null(params$assayRunInfo)){
  # perform instrument effect test
  ## ORGANIZE DATA
  # extract instrument data
  instruments <- unlist(sapply(assayRunInfo, function(x) x[2]))
  # make an instrument indicator for associating with sample PCA
  instrument_names <- instruments
  instrument_names <- gsub(' ', '_', instrument_names)
  unique_instruments <- unique(instruments)
  max_plates_per_inst <- max(table(instruments))
  # only do inst effect test if there are at least 2 inst 
  # and we have at least one inst with 2 or more plates
  do_inst_effect_test <- length(unique_instruments) > 1 && max_plates_per_inst > 1
  if(do_inst_effect_test){
    # create a instEffectID variable
    sample_metadata$instEffectID <- NA
    for(i in 1:numFiles){
      sample_metadata$instEffectID[sample_metadata$plateEffectID==unique(sample_metadata$plateEffectID)[i]] <- instruments[i]
    }
    sample_metadata$instEffectID <- factor(sample_metadata$instEffectID)
    # create a model fit message variable
    model_fit_message_inst <- NULL
    for(i in 1:length(unique_instruments)){
      sample_metadata[,gsub(' ', '_', unique_instruments[i])] <- sample_metadata$instEffectID == unique_instruments[i]
    }
    
    #####################################
    ## FIT MODELS INSTRUMENT EFFECT ANOVA
    #####################################
    # determine whether to adjust for covariate 
    use_covariates <- FALSE
    if(!is.null(params$sampleGroupCovar)){
      if(!is.null(params$sampleGroupCovar) & params$sampleGroupCovar %in% colnames(sample_metadata)){
        if(length(unique(sample_metadata[,params$sampleGroupCovar])) > 1){
          use_covariates <- TRUE
        }
      }
    }
    # if no sampleGroupCovar indicated or only one unique category, fit model with no covariates
    if(!use_covariates){
      inst_effect_results <- vector(mode='list', length = 1)
      # table n samples per instrument
      inst_effect_results[[1]]$n_samples_table <- as.data.frame(table(sample_metadata$instEffectID))
      rownames(inst_effect_results[[1]]$n_samples_table) <- NULL
      colnames(inst_effect_results[[1]]$n_samples_table) <- c('InstrumentID', 'n samples')
      # fit model
      inst_effect_results[[1]]$inst_test_lm <- lmNULISAseq(data=plate_test_data, 
                                                           sampleInfo = sample_metadata[,c('full_sampleName', 'instEffectID')], 
                                                           sampleName_var = 'full_sampleName',
                                                           modelFormula = 'instEffectID', 
                                                           reduced_modelFormula = '1',
                                                           return_model_fits = TRUE)
      inst_effect_results[[1]]$Ftest_volcano <- volcanoPlot(coefs=inst_effect_results[[1]]$inst_test_lm$Fstats$Fstat, 
                                                            p_vals = inst_effect_results[[1]]$inst_test_lm$Fstats$Ftest_pval, 
                                                            target_labels = inst_effect_results[[1]]$inst_test_lm$Fstats$target,
                                                            title = 'Instrument effect ANOVA F-test',
                                                            xlabel = paste0('F-statistic (df=', inst_effect_results[[1]]$inst_test_lm$Fstats$Df[1], ')'),
                                                            ylabel = '-log10(unadjusted p-value)',
                                                            sig_label = paste0('p = ', params$plate_effect_pval_ANOVA), 
                                                            sig_threshold = params$plate_effect_pval_ANOVA)
    } else if(use_covariates){
      # table n samples per plate
      inst_effect_results <- vector(mode='list', length = 1)
      inst_effect_results[[1]]$n_samples_table <- as.data.frame.matrix(table(sample_metadata$instEffectID, sample_metadata[,params$sampleGroupCovar]))
      inst_effect_results[[1]]$n_samples_table <- data.frame(InstrumentID=rownames(inst_effect_results[[1]]$n_samples_table), inst_effect_results[[1]]$n_samples_table)
      rownames(inst_effect_results[[1]]$n_samples_table) <- NULL
      colnames(inst_effect_results[[1]]$n_samples_table)[2:ncol(inst_effect_results[[1]]$n_samples_table)] <- paste0(colnames(inst_effect_results[[1]]$n_samples_table)[2:ncol(inst_effect_results[[1]]$n_samples_table)], ' (n)')
      # check if model matrix is full rank 
      model_matrix <- model.matrix(as.formula(paste0(' ~ sample_metadata$instEffectID + sample_metadata$', params$sampleGroupCovar)))
      model_matrix_rank <- qr(model_matrix)$rank
      # if not full rank, omit the sampleGroupCovar and print a message in the output
      if(model_matrix_rank < ncol(model_matrix)){
        model_fit_message_inst <- 'PLEASE NOTE: Instrument and sample group were confounded so sample group was not included in the instrument effect test models. Significant instrument effects cannot be fully separated from sample group effects. Any significant instrument effects noted here could actually be due to biological sample group differences.'   
        model_formula <- 'instEffectID'
        reduced_model_formula <- 1
      } else {
        # if sampleGroupCovar is specified and there is more than one category, 
        # fit model with sampleGroupCovar as covariate
        model_formula <- paste0('instEffectID + ', params$sampleGroupCovar)
        reduced_model_formula <- params$sampleGroupCovar
      }
      # fit model
      inst_effect_results[[1]]$inst_test_lm <- lmNULISAseq(data=plate_test_data, 
                                                           sampleInfo = sample_metadata[,c('full_sampleName', 'instEffectID', params$sampleGroupCovar)], 
                                                           sampleName_var = 'full_sampleName',
                                                           modelFormula = model_formula, 
                                                           reduced_modelFormula = reduced_model_formula,
                                                           return_model_fits = TRUE)
      inst_effect_results[[1]]$Ftest_volcano <- volcanoPlot(coefs=inst_effect_results[[1]]$inst_test_lm$Fstats$Fstat, 
                                                            p_vals = inst_effect_results[[1]]$inst_test_lm$Fstats$Ftest_pval, 
                                                            target_labels = inst_effect_results[[1]]$inst_test_lm$Fstats$target,
                                                            title = 'Instrument effect ANOVA F-test',
                                                            xlabel = paste0('F-statistic (df=', inst_effect_results[[1]]$inst_test_lm$Fstats$Df[1], ')'),
                                                            ylabel = '-log10(unadjusted p-value)',
                                                            sig_label = paste0('p = ', params$plate_effect_pval_ANOVA), 
                                                            sig_threshold = params$plate_effect_pval_ANOVA)
      
    } # end if use_covariates
    
    
    #####################################
    # MAKE INSTRUMENT EFFECT TARGET TABLE
    #####################################
    inst_effect_results[[1]]$target_table <- inst_effect_results[[1]]$inst_test_lm$Fstats
    # remove some cols
    inst_effect_results[[1]]$target_table <- inst_effect_results[[1]]$target_table[,c(1,2,4)]
    inst_effect_results[[1]]$target_table$inst_Ftest_significant <- inst_effect_results[[1]]$target_table$Ftest_pval < params$plate_effect_pval_ANOVA
    # merge with the plate target table 
    plate_effect_target_table <- merge(plate_effect_target_table, 
                                       inst_effect_results[[1]]$target_table[,c("target","inst_Ftest_significant")], sort=FALSE)
    
    colnames(plate_effect_target_table)[colnames(plate_effect_target_table)=="inst_Ftest_significant"] <- "inst Ftest significant"
  } # end do_inst_effect_test
} # end if multipleFiles & !is.null(params$assayRunInfo)
```

---
title: "`r title_var`"
---

```{r run-summary, eval=(params$outRunSummary & params$reportType=='internal' & !is.null(params$assayRunInfo)), results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.6, message = "Writing Document ...")

if(!is.null(params$assayRunInfo)){
  cat("## Run summary\n\n")
  if(!is.null(PlateNameMessage)) cat(PlateNameMessage, "\n\n")
  
  run_summary <- data.frame(`Plate ID`=PlateNames,
                            `Assay date`=sapply(assayRunInfo, function(x) x[[1]]),
                            `Assay instrument`=sapply(assayRunInfo, function(x) x[[2]]), 
                            check.names = FALSE, row.names = NULL)
  
  render_table(run_summary, 
               table_name = "Run Summary", 
               table_id = "id=\"run-summary\"")
}
```

```{r plate-layout, eval=(params$outPlateLayout), results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.6, message = "Writing Document ...")

cat("## Plate layout\n\n")
cat(paste0("Shows the layout of samples, controls (e.g., negative controls (NC), ", CAL_IPC_full, " and special wells if any (e.g., ", AQSC_SC_full, ") on the 96 well assay plate."), "\n\n")

if(!is.null(PlateNameMessage)) cat(PlateNameMessage, "\n\n")

for(i in 1:numFiles){
  cat(paste0("\n### ", PlateNames[i], "\n\n"))
  val <- matrixify(runs[[i]]$samples, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC) well_types <- append(well_types, list(SC_wells[[i]]))
  if(indicatorBridge) well_types <- append(well_types, list(Bridge_wells[[i]]))
  for (j in 1:length(well_types)){
    inds <- grep(paste0("^", well_types[[j]], "$", collapse="|"), val)
    if(length(inds) > 0){
      if(AbsData){
        val[inds] <- sub("^IPC_([1234])$", "CAL_\\1", val[inds])
        val[inds] <- sub("^SC_([1234])$", "AQSC_\\1", val[inds])
      }
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1], escape=FALSE)
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space for text wrapping
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  kable_obj <- kableExtra::kbl(val, caption=paste0(PlateNames[i], ": ", xmlFiles[i]), 
                               align="c", escape=FALSE, table.attr=table.attr) %>%
    kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                  full_width = TRUE) %>%
    column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
    row_spec(0:8, extra_css = "border-bottom: 1px solid")
  cat(kable_obj)
  if(params$outputPlots && params$reportType != "webApp"){
    html_content <- paste0(
      '<!DOCTYPE html>\n<html>\n<head>\n<meta charset="utf-8"/>\n',
      '<style>body{background-color:white;}</style>\n',
      '</head>\n<body>\n',
      as.character(kable_obj),
      '\n</body>\n</html>'
    )
    
    cat(html_content,
        file = paste0(params$outfolder, 'outputFiles/', PlateNames[i], '_layout.html'))
  }
}
```

```{r plate-read-summary, eval=(params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("## Read summary\n\n")
cat("Summary of the number and classification of reads for the assay run\n\n")
cat(paste0("- ", c("Parseable - Valid next generation sequencing (NGS) read (assay signal or background)",
              "Parseable Match - Valid NGS read (assay signal)",
              "Parseable Non-match - Vaild NGS read (assay background)",
              "Unparseable - Sequencing background",
              "Total wells - Total number of samples + controls on plate",
              "Total targets - Total number of assay targets (including internal controls)",
              "&#35; of zeros (%) - Number and percentage of targets * samples which had zero sequencing reads (no assay signal)"
), "\n", collapse = ""))
render_table(read_summary, 
             table_name = " ", 
             table_id = "id=\"read-summary\"", 
             first_colName = "Run")
```

```{r IC-read-summary, eval=(params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("### Internal controls (IC)\n\n")
cat("Each sample of the assay is spiked with the same concentration of at least one internal control (IC). This is used both as part of a well normalization procedure and as a method for assessing the uniformity of the assay run. SD: standard deviation. CV: coefficient of variation\n\n") 
IC_name <- Reduce(intersect, lapply(runs, function(x) x$IC))
for(j in 1:length(IC_name)){
  IC_tables <- NULL
  for (i in 1:numFiles){
    IC_tables <- rbind(IC_tables, runSummaries[[i]]$IC_table[j,])
  }
  rownames(IC_tables) <- PlateNames
  print(render_table(IC_tables, 
                     table_name = paste0("Internal Control (IC) summary - ", IC_name[j]), 
                     table_id = paste0("id=\"IC-summary-", IC_name[j], "\""),
                     first_colName = "Run"))
}
```

```{r IPC-read-summary, eval=(params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat(paste0("### ", CAL_IPC_full, "\n\n"))
cat(paste0(CAL_IPC, " samples are pooled plasma controls used both to normalize samples between experiments and to assess performance (e.g., precision) of the assay."), "\n\n")
cat("Note: %CV in this table does not exclude values below LOD. See Coefficient of variation section for %CV (before and after normalization) that excludes values below LOD.\n\n")
IPC_table <- do.call(rbind,
                     lapply(seq_along(runSummaries), function(i) {
                       if(AbsData){
                         rownames(runSummaries[[i]]$IPC_table) <- gsub("^IPC_([1234])$", "CAL_\\1", rownames(runSummaries[[i]]$IPC_table))
                       }
                       df <- as.data.frame(runSummaries[[i]]$IPC_table)
                       if(!"Sample" %in% colnames(df)){
                         df$Sample <- rownames(df)
                       }
                       df$Run <- PlateNames[i]
                       df <- df[, c("Run", "Sample", setdiff(names(df), c("Sample", "Run")))]
                       df
                     })
)
render_table(IPC_table, 
             table_name = "IPC summary", 
             table_id = "id=\"IPC-summary\"", 
             rownames=FALSE)
```

```{r NC-read-summary, eval=(params$outReadSummary), results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.7, message = "Writing Document ...")

knitr::asis_output("\n\n---\n\n")
cat("### Negative controls (NC)\n\n")
cat("NC wells are reactions where no sample input is provided (i.e., buffer only). These are used to assess Limit of Detection (LOD) for each target assay and to assess run quality (e.g., background levels).\n\n")
NC_table <- do.call(rbind,
                    lapply(seq_along(runSummaries), function(i) {
                      df <- as.data.frame(runSummaries[[i]]$NC_table)
                      if(!"Sample" %in% colnames(df)){
                        df$Sample <- rownames(df)
                      }
                      df$Run <- PlateNames[i]
                      df <- df[, c("Run", "Sample",  setdiff(names(df), c("Sample", "Run")))]
                      df
                    })
)
render_table(NC_table, 
             table_name = "NC summary", 
             table_id = "id=\"NC-summary\"", 
             rownames=FALSE)
```

```{r NC-outliers, eval=(params$reportType=='internal'), results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.725, message = "Writing Document ...")

cat("#### Negative controls outlier table\n\n")
cat("The following values for NC wells and targets were identified as outliers and excluded from LOD calculations.\n\n")
if(!is.null(blank_outlier_table)){
  render_table(blank_outlier_table,
               table_name = ' ',
               table_id = "id=\"NC-outliers\"",
               rownames = FALSE)
} else {
  cat("No NC outliers were identified.\n\n")
}
```

```{r SC-read-summary, eval=(indicatorSC & params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat(paste0("### ", AQSC_SC_full, "\n\n"))
cat(paste0(AQSC_SC, " samples are pooled plasma controls from an independent pooled plasma source that is different from ", CAL_IPC, "s. ", AQSC_SC, "s are used for calculating intra- and inter-plate coefficient of variation (CV). They are used to obtain an unbiased measure of inter-plate CV when ", CAL_IPC, " normalization is used."), "\n\n")
cat("Note: %CV in this table does not exclude values below LOD. See Coefficient of variation section for %CV (before and after normalization) that excludes values below LOD.\n\n")
SC_table <- do.call(rbind,
                    lapply(seq_along(runSummaries), function(i) {
                      if(AbsData){
                        rownames(runSummaries[[i]]$SC_table) <- gsub("^SC_([1234])$", "AQSC_\\1", rownames(runSummaries[[i]]$SC_table))
                      }
                      df <- as.data.frame(runSummaries[[i]]$SC_table)
                      if(!"Sample" %in% colnames(df)){
                        df$Sample <- rownames(df)
                      }
                      df$Run <- PlateNames[i]
                      df <- df[, c("Run", "Sample", setdiff(names(df), c("Sample", "Run")))]
                      df
                    })
)
render_table(SC_table, 
             table_name = paste0(AQSC_SC, " summary"), 
             table_id = paste0("id=\"", AQSC_SC, "-summary\""), 
             rownames=FALSE)
```

```{r bridge-read-summary, eval=(indicatorBridge & params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("### Bridge samples (Bridge)\n\n")
cat("Bridge samples can be used for inter-plate normalization. Bridge sample normalization uses the bridge sample subset to estimate median target-specific differences in NPQ, and then uses these NPQ differences to normalize all samples in a manner similar to intensity normalization.\n\n")
for(i in 1:numFiles){
  if(!is.null(runSummaries[[i]]$Bridge_table)){
    print(render_table(runSummaries[[i]]$Bridge_table, 
                       table_name = paste0(PlateNames[i], ": Bridge summary"), 
                       table_id = paste0("id=\"Bridge-summary", i, "\""), 
                       first_colName = "Sample"))
  }
}
```

```{r total-count-IC-heatmaps, out.width='100%', eval=(params$outHeatmaps), fig.asp=0.333, results='asis', warning=FALSE}
knitr::asis_output("\n\n---\n\n")
cat("## Heatmaps\n\n")
heatmap_description <- if (params$heatMapRel==TRUE) "percent relative to plate median" else "absolute normalized read count"
cat(paste0("Heatmaps show the ", heatmap_description, " for log2(total counts) and the specified internal control(s)."), "\n\n")
for(i in 1:numFiles){
  cat(knitr::asis_output(paste0("\n\n### ", PlateNames[i], "\n\n")))
  ICs <- which(tolower(runs[[i]]$targets$targetType) == "control")
  val <- matrixify(runs[[i]]$samples)
  vals <- unlist(as.list(t(val)))
  par(mfrow=c(1, length(ICs)+1), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsIC <- if(params$heatMapRel) 1 else 0
  logVals <- log2(colSums(runs[[i]]$Data, na.rm=TRUE))
  well_order <- wellorder(runs[[i]]$sample)
  val <- vals
  val[which(!is.na(vals))] <- logVals[well_order]
  plateHeatmap(as.numeric(val), 
               title=paste0(PlateNames[i], ": ", 'log2(total counts)'), 
               cex=0.5, digits=1,
               relative=params$heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    val <- vals
    val[which(!is.na(vals))] <- runs[[i]]$Data[ICs[j],][well_order]
    ICname <- if(length(ICs) == 1) "IC" else paste0("IC(", runs[[i]]$targets$targetName[ICs[j]], ")")
    plateHeatmap(as.numeric(val), 
                 title=paste0(PlateNames[i],": ", ICname),
                 cex=0.5, digits=digitsIC, 
                 relative=params$heatMapRel, cex.axis=0.5)
  }
}
```

```{r plateQC, eval=(params$outQC), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("## Quality control\n\n")
cat("### Plate QC\n\n")
cat("Plate-specific QC criteria:\n\n")
qcText <- QCPlateCriteria(AQ=AbsData)

qc_criteria <- paste0(qcText$properNames, " - ", qcText$explanations)
cat(paste0("- ", qc_criteria, "\n", collapse = ""))
cat(paste0("QC criteria are assessed either on unnormalized (raw) or ", CAL_IPC, "-normalized (", CAL_IPC, ") data."), "\n\n")

# Initialize empty list to store all QC data
all_qc_data <- list()

for(i in 1:numFiles){
  runs[[i]]$qcTarget <- QCFlagTarget(runs[[i]]$AQ$Data_AQ_aM, runs[[i]]$Data, runs[[i]]$normed$interNormData[[1]], runs[[i]]$detectability$all$detectability, runs[[i]]$lod$aboveLOD, runs[[i]]$AQ$withinDR, AbsData, runs[[i]]$targets, runs[[i]]$samples, runs[[i]]$AQ$targetAQ_param$SC_conc, advancedQC=params$advancedQC)

  # Filter out excluded targets from qcTarget (IC, hidden, noDetectability, user-excluded)
  if(!is.null(runs[[i]]$qcTarget)){
    targets_to_exclude_qc <- c(
      runs[[i]]$IC,
      runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)],
      runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)]
    )
    if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[i]])) {
      targets_to_exclude_qc <- c(targets_to_exclude_qc, params$excludeTargets[[i]])
    }
    runs[[i]]$qcTarget <- runs[[i]]$qcTarget %>% filter(!target %in% targets_to_exclude_qc)
  }

  qcPlate <- QCFlagPlate(runs[[i]]$Data, normData[[i]], runs[[i]]$lod$aboveLOD, runs[[i]]$targets, runs[[i]]$samples, AQ=AbsData, AQ_QC=runs[[i]]$qcTarget, Sample_QC=runs[[i]]$qcSample)
  qcPlate$status[which(qcPlate$status == FALSE)] <- "Pass"
  qcPlate$status[which(qcPlate$status == TRUE)] <- "Warning"
  qcFormat = QCPlateCriteria(AQ=AbsData)
  ind <- which(qcPlate$flagName %in% names(which(qcFormat$format == "percentage")))
  qcPlate$QCthreshold[ind] <- paste0(format(as.numeric(qcPlate$QCthreshold[ind])*100, digits=2), "%")
  qcPlate$val[ind] <- paste0(format(as.numeric(qcPlate$val[ind])*100, digits=2), "%")
  
  ind <- which(qcPlate$flagName %in% names(which(qcFormat$format == "integer")))
  qcPlate$QCthreshold[ind] <- format(as.numeric(qcPlate$QCthreshold[ind]), big.mark=",", scientific=FALSE)
  qcPlate$val[ind] <- format(as.numeric(qcPlate$val[ind]), big.mark=",")
  qcPlate <- qcPlate %>% mutate (flagName = qcText$properNames[flagName])
  
  if(AbsData){
    qcPlate <- qcPlate %>%
      mutate(normMethod = case_when(
        normMethod == "IPC" ~ "CAL",
        TRUE ~ normMethod
      ))
  }
  
  # Add plate name as first column and store in list
  qcPlateTable <- qcPlate[,1:5] %>%
    mutate(Plate = PlateNames[i], .before = 1)
  
  all_qc_data[[i]] <- qcPlateTable
}

# Combine all QC data into single table
combined_qc_table <- do.call(rbind, all_qc_data)

# Set column names
colnames(combined_qc_table) <- c("Run", "QC Criterion", "Normalization", "QC Status", "QC Value", "QC Threshold")

# Create highlight vector for all rows with Warning status
highlight_warnings <- combined_qc_table$`QC Status` == "Warning"

cat(tableWarningText(highlight_warnings, textColor = "white", bgColor = "red"), "\n\n")

# Print the combined table
print(render_table(combined_qc_table,
                   table_name = "Combined Plate QC Summary",
                   table_id = "id=\"QCFlagPlate-combined-summary\"",
                   rownames = FALSE,
                   highlight = list(Data = highlight_warnings,
                                    bgColor = "red",
                                    textColor = "white",
                                    bold = TRUE)))
```

```{r sampleQC-header, eval=(params$outQC), out.width='100%', results='asis'}
cat("### Sample QC\n\n")
cat("#### Sample QC summary tables\n\n")
cat("Sample-specific QC criteria:\n\n")
```

```{r sampleQC-criteria, eval=(params$outQC), out.width='100%', results='asis'}
if(params$reportType=="internal"){
  qcText <- QCSampleCriteria(TAP=TRUE)
} else {
  qcText <- QCSampleCriteria(TAP=FALSE)
}

items <- paste0(qcText$properNames, " - ", qcText$explanations)
cat(paste0("- ", items, "\n", collapse = ""))

zero_samples <- lapply(runs, function(x) x$zero_samples)
zero_samples_message <- formatZeroSamples(zero_samples, "Samples excluded, zero total reads: ")
if(!is.null(zero_samples_message)) {
  cat(zero_samples_message, "\n\n")
}

IC_zero_samples <- lapply(runs, function(x) x$IC_zero_samples)
IC_zero_samples_message <- formatZeroSamples(IC_zero_samples, "Samples excluded, zero IC reads: ")
if(!is.null(IC_zero_samples_message)) {
  cat(IC_zero_samples_message, "\n\n")
}

printExcludedSamples(params$excludeSamples, PlateNames)
```

```{r sampleQC-summary-table, eval=(params$outQC), out.width='100%', results='asis'}
# make empty sample QC summary table
criteria <- QCSampleCriteria()
rowNameQC <- c()
# Only add Total row if there are multiple runs
numRows <- if(numFiles > 1) numFiles + 1 else numFiles
QCSummary <- matrix(nrow=numRows, ncol=length(criteria$thresholds) - length(which(startsWith(names(criteria$thresholds), "Detectability"))) + 1 + 1)

for (i in 1:numFiles){
  QCSummary[i,1] <- length(runs[[i]]$SampleNames)
  rowNameQC <- c(rowNameQC, PlateNames[i]) 
}

# loop over criteria
# get xlim for plots
val <- valT <- list()
QCplot_axis_limits <- vector(mode='list', length=numFiles)
QCplot_target_axis_limits <- vector(mode='list', length=numFiles)

for (i in 1:numFiles){
  well_order <- wellorder(runs[[i]]$samples)
  qcSample <- QCFlagSample(runs[[i]]$Data, runs[[i]]$lod$aboveLOD, runs[[i]]$samples, runs[[i]]$targets, well_order, TAP=params$reportType=="internal", QCS=runs[[i]]$QCS, SN=runs[[i]]$SN)
  
  rmin <- rmax <- rminT <- rmaxT <- c()
  for (j in 1:length(criteria$thresholdNames)){
    inds <- which(startsWith(names(criteria$thresholdNames)[j], qcSample$flagName))
    QC_criterion_j_data <- qcSample[inds, ]
    if (startsWith(names(criteria$thresholdNames)[j], "Detectability")){
      val[j] <- criteria$thresholds[1]
    }else{
      val[j] <- criteria$thresholds[which(names(criteria$thresholds) == names(criteria$thresholdNames)[j])]
    }
    
    
    val[j] <- criteria$thresholds[j] #if(names(criteria$thresholds)[j] == "Detectability") as.numeric(unlist(strsplit(criteria$thresholds[j],",")))*100 else unlist(strsplit(criteria$thresholds[j],","))
    if(names(criteria$thresholdNames)[j] == "Detectability"){
      xval <- as.numeric(QC_criterion_j_data$val)*100
      rmax[j] <- 100.0
      rmin[j] <- 0.0 #min(as.numeric(val[[j]])*100, as.numeric(xval), na.rm=TRUE)
    }else if (names(criteria$thresholdNames)[j] == "IC_Median"){
      xval <- as.numeric(QC_criterion_j_data$val)*100
      minmaxVal <- unname(unlist(strsplit(val[[j]], ",")))
      rmin[j] <- min(as.numeric(minmaxVal[1])*100, as.numeric(xval), na.rm=TRUE)
      rmax[j] <- max(as.numeric(minmaxVal[2])*100, as.numeric(xval), na.rm=TRUE)
    }else{
      xval <- as.numeric(QC_criterion_j_data$val)
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=TRUE)
      rmax[j] <- max(as.numeric(val[[j]]), as.numeric(xval), na.rm=TRUE)
    }
    
    # add a small amount of padding to x axis limits
    if(names(criteria$thresholdNames)[j] %in% c("ICReads", "NumReads")){
      rlim_delta <- log10(rmax[j]) - log10(rmin[j])
      rmin[j] <- 10^(log10(rmin[j]) - 0.025 * rlim_delta)
      rmax[j] <- 10^(log10(rmax[j]) + 0.025 * rlim_delta)
    } else {
      rlim_delta <- rmax[j] - rmin[j]
      rmin[j] <- rmin[j] - 0.025 * rlim_delta
      rmax[j] <- rmax[j] + 0.025 * rlim_delta
    }
    # count how many samples fail QC (excludes controls)
    QCSummary[i, j+1] <- length(which(QC_criterion_j_data[QC_criterion_j_data$sampleName %in% runs[[i]]$SampleNames,]$status=="TRUE"))
    
  }
  QCplot_axis_limits[[i]] <- list(rmin=rmin, rmax=rmax)
  
  if(length(Tcriteria) > 0){
    for (j in 1:length(Tcriteria$thresholdNames)){
      # Calculate limits for Targets
      valT[j] <- Tcriteria$thresholds[which(names(Tcriteria$thresholds) == names(Tcriteria$thresholdNames)[j])]
      indsT <- which(startsWith(names(Tcriteria$thresholdNames)[j], runs[[i]]$qcTarget$flagName))  
      QC_criterion_Target_j_data <- runs[[i]]$qcTarget[indsT, ]
      
      xval <- as.numeric(QC_criterion_Target_j_data$val) * 100
      if(names(Tcriteria$thresholdNames)[j] == "Target_Conc_Accuracy"){
        minmaxValT <- unname(unlist(strsplit(valT[[j]], ",")))
        rminT[j] <- min(as.numeric(minmaxValT[1])*100, as.numeric(xval), na.rm=TRUE)
        rmaxT[j] <- max(as.numeric(minmaxValT[2])*100, as.numeric(xval), na.rm=TRUE)
      } else if(names(Tcriteria$thresholdNames)[j] %in%  c("Target_Conc_CV", "Target_Detectability", "Target_Min_Reads", "Target_Conc_CV_RQ")){
        rminT[j] <- min(as.numeric(valT[[j]])*100, as.numeric(xval), na.rm=TRUE)
        rmaxT[j] <- max(as.numeric(valT[[j]])*100, as.numeric(xval), na.rm=TRUE)
      } else if(names(Tcriteria$thresholdNames)[j] %in% c("Target_IPC_Min_Reads")){
        rminT[j] <- 0
        rmaxT[j] <- log2(max(as.numeric(valT[[j]]), as.numeric(xval), na.rm=TRUE))
      }
    }
    QCplot_target_axis_limits[[i]] <- list(rmin=rminT, rmax=rmaxT)
  }
}

# fill in & format QCSummary
# Only add Total row if there are multiple runs
if(numFiles > 1){
  QCSummary[i+1, ] <- colSums(QCSummary, na.rm=TRUE)
  rownames(QCSummary) <- c(rowNameQC, "Total")
} else {
  rownames(QCSummary) <- rowNameQC
}
colnames(QCSummary) <- c("# of Wells", criteria$properNames)
numPlateWarnings <- sum(QCSummary[, 1] > 0) - 1 

# add percentages (use drop=FALSE to preserve matrix structure with single row)
QCSummary[,2:ncol(QCSummary)] <- apply(QCSummary[,2:ncol(QCSummary), drop=FALSE], 2, function(x){
  pct <- paste0(x, ' (', format(round(x / QCSummary[,1] * 100, 1), nsmall=1), '%)')
  return(pct)
})

render_table(QCSummary, 
             table_name = paste0("Number (%) of samples that have warnings for each QC criterion (excludes ", CAL_IPC, ", ", AQSC_SC, " & NC samples)"),
             table_id = "id=\"QC-summary-table\"", 
             first_colName = "Run",
             defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(QCSummary)) else 10,
             highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, bgColor="yellow", textColor="black") else NULL)
```

```{r sampleQC-failed, eval=(params$outQC), out.width='100%', results='asis'}
# table to show which specific samples fail each QC flag
QC_sample_fail <- vector(mode='list', length=length(names(criteria$thresholdNames)))

names(QC_sample_fail) <- names(criteria$thresholdNames)
QC_sample_fail <- lapply(QC_sample_fail, function(x) x <- data.frame(Plate=character(0), QC_fail_samples=character(0)))
for (i in 1:numFiles){
  well_order <- wellorder(runs[[i]]$samples)
  qcSample <- QCFlagSample(runs[[i]]$Data, runs[[i]]$lod$aboveLOD, runs[[i]]$samples, runs[[i]]$targets, well_order, TAP=params$reportType=="internal", QCS=runs[[i]]$QCS, SN=runs[[i]]$SN)
  qcSample <- qcSample[which(qcSample$status != "NA"),]
  for (j in 1:length(criteria$thresholdNames)){
    QC_criterion_j_data <- qcSample[qcSample$flagName == names(criteria$thresholdNames)[j], ]
    QC_criterion_j_data_samples <- QC_criterion_j_data[QC_criterion_j_data$sampleName %in% runs[[i]]$SampleNames,]
    QC_fail_samples_j <- QC_criterion_j_data_samples$sampleName[QC_criterion_j_data_samples$status==TRUE & !is.na(QC_criterion_j_data_samples$status)]
    QC_fail_samples_j_vals <- QC_criterion_j_data_samples$val[QC_criterion_j_data_samples$status==TRUE & !is.na(QC_criterion_j_data_samples$status)]
    # Format values based on criteria format
    if(criteria$format[j] == "integer"){
      QC_fail_samples_j_vals <- format(round(as.numeric(QC_fail_samples_j_vals)), big.mark = ",", scientific = FALSE)
    } else if(criteria$format[j] == "percentage"){
      QC_fail_samples_j_vals <- formatC(as.numeric(QC_fail_samples_j_vals) * 100, format = "f", digits = 1)
    }
    # reverse so they are sorted A1 - H12
    QC_fail_samples_j <- rev(QC_fail_samples_j)
    QC_fail_samples_j_vals <- rev(QC_fail_samples_j_vals)
    if(length(QC_fail_samples_j) > 0){
      QC_sample_fail[[j]] <- rbind(QC_sample_fail[[j]], data.frame(Run=PlateNames[i], Samples=QC_fail_samples_j, Value=QC_fail_samples_j_vals))
    }
  }
}
# print QC fail tables
for(i in 1:length(names(criteria$thresholdNames))){
  qcName <- names(criteria$thresholdNames)[i]
  if(nrow(QC_sample_fail[[qcName]]) > 0){
    tableMsg = if(names(criteria$thresholdNames)[i] == "QCS" || names(criteria$thresholdNames)[i] == "SN") "Failed Wells: " else "Wells with warnings: "
    print(render_table(QC_sample_fail[[qcName]], 
                       table_name = paste0(tableMsg, criteria$properNames)[i], 
                       table_id = paste0("id=\"sample-QC-summary-table","-", qcName, "\""), 
                       highlight = if(names(criteria$thresholdNames)[i]=='IC_Median' & params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, textColor="black", bgColor="yellow") else NULL,
                       rownames = FALSE))
  }
}
```

```{r sampleQC-plots, eval=(params$outQC), out.width='100%', fig.asp=1, results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.8, message = "Writing Document ...")
cat("#### Sample QC plots\n\n")
# Note: pass / fail status of SN QC criterion is: SN/QCS < threshold1 AND QCS > threshold2. Values shown are SN/QCS.
# make sample QC plots
for( i in 1:numFiles){
  # sort in order: samples, IPC, SC, Bridge, NC
  sampleType_factor <- factor(runs[[i]]$sample$sampleType,
                              levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  well_order <- wellorder(runs[[i]]$samples,
                          sampleTypeFactor=sampleType_factor)
  # do sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, runs[[i]]$lod$aboveLOD, runs[[i]]$samples, runs[[i]]$targets, well_order, TAP=params$reportType=="internal", QCS=runs[[i]]$QCS, SN=runs[[i]]$SN)
  if(indicatorSC){
    inds <- which(grepl(paste(runs[[i]]$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(runs[[i]]$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }
  
  # make plots
  par(mfcol=c(1, length(criteria$thresholdNames)+1), mar=c(3.5,0.05,3.5,0.05), mgp=c(2,1,0))
  # empty plot
  dotchart(x=rep(0, length(sampleType_factor)),
           xlab='',
           xlim=c(50, 100),
           labels=qcSample[inds, ]$sampleName,
           color="white",
           lcolor='white',
           gcolor='black',
           xaxt='n', frame.plot=FALSE,
           offset=-1,
           cex=0.45)
  title(main=PlateNames[i])
  
  
  label_map <- c(
    Detectability = "Detectability %",
    IC_Median     = "% of IC Median",
    QCS           = "QCS",
    SN            = "SN / QCS"
  )
  for(j in 1:length(names(criteria$thresholdNames))){
    key <- names(criteria$thresholdNames)[j]
    inds <- which(qcSample$flagName == key)
    vals <- as.numeric(qcSample[inds, ]$val)
    xlab <- label_map[key]
    if(is.na(xlab)) xlab <- "Number of Reads"
    
    # compute xval depending on the key
    if (key %in% c("Detectability", "IC_Median")) {
      xval <- vals * 100
    } else {
      xval <- vals
      if (xlab == "Number of Reads") {
        # special case: avoid zeros
        xval[which(xval == 0)] <- xval[which(xval == 0)] + 1
      }
    } 
    
    # use log scale for number of reads
    log <- if(names(criteria$thresholdNames)[j] != "Detectability" && names(criteria$thresholdNames)[j] != "IC_Median" && names(criteria$thresholdNames)[j] != "QCS" && names(criteria$thresholdNames)[j] != "SN") "x" else ""
    # use y labels only for first plot
    if(j==1) {
      labels <- qcSample[inds, ]$sampleName
      if(AbsData){
        labels <- gsub("^IPC_([1234])$", "CAL_\\1", labels)
        labels <- gsub("^SC_([1234])$", "AQSC_\\1", labels)
      }
    } else {
      labels <- rep('', length(xval))
    }
    # define colors
    color <- rep("black", length(inds))
    color[which(qcSample[inds,]$sampleType == "IPC")] <- boxplot_colors[2]
    color[which(qcSample[inds,]$sampleType == "NC")] <- boxplot_colors[3]
    if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "SC")] <- boxplot_colors[4]
    }
    if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "Bridge")] <- boxplot_colors[5]
    }
    
    valMin = if(is.finite(QCplot_axis_limits[[i]]$rmin[j])) QCplot_axis_limits[[i]]$rmin[j] else 0
    valMax = if(is.finite(QCplot_axis_limits[[i]]$rmax[j])) QCplot_axis_limits[[i]]$rmax[j] else 1
    dotchart(x=as.numeric(xval),
             xlab=xlab,
             labels=rep('', length(xval)), las=1,
             cex=0.45, xlim=c(valMin, valMax),
             color=color, log=log)
    if(j==1){
      # need to loop over labels and color individuals
      for (k in 1:length(xval)){
        axis(side=2, at=k,
             labels=labels[k], col.axis=color[k], las=1,
             cex.axis=0.5)
      }
    }
    # color points green if PASS, yellow if WARNING, red if FAIL 
    warnFailTxt <- "Warning"
    warnFailColor <- '#ebc634'
    if(names(criteria$thresholdNames)[j] == "QCS" || names(criteria$thresholdNames)[j] == "SN"){
      warnFailTxt <- "Fail"
      warnFailColor <- 'red'
    }
    xvalFail <- xval
    xvalFail[which(qcSample[inds,]$status != TRUE)] <- NA
    xvalPass <- xval
    xvalPass[which(qcSample[inds,]$status != FALSE)] <- NA
    points(as.numeric(xvalFail),1:length(xvalFail), pch=19, col=warnFailColor)
    points(as.numeric(xvalPass),1:length(xvalPass), pch=19, col="green")
    
    if(names(criteria$thresholdNames)[j] == "IC_Median"){
      minmaxVal <- unlist(strsplit(criteria$thresholds["IC_Median"], ","))
      abline(v=as.numeric(minmaxVal[[1]])*100, col='brown')
      abline(v=as.numeric(minmaxVal[[2]])*100, col='brown')
      abline(v=0, col='brown', lty=2)
    } else if(names(criteria$thresholdNames)[j] == "Detectability"){
      detectVals <- as.numeric(qcSample$QCthreshold[which(qcSample$flagName == "Detectability")]) * 100
      # Remove NA values and get their indices
      valid_idx <- which(!is.na(detectVals))
      valid_vals <- detectVals[valid_idx]
      
      # Draw all segments at once
      segments(valid_vals, valid_idx - 0.5, valid_vals, valid_idx + 0.5, col = "brown")
    } else{
      #      value <- if(criteria$format[j] == "percentage") as.numeric(val[[j]])*100 else as.numeric(val[[j]])
      thresh <- criteria$thresholds[which(names(criteria$format)[j] == names(criteria$thresholds))]
      value <- if(criteria$format[j] == "percentage") as.numeric(thresh) * 100 else as.numeric(thresh)
      abline(v=value, col='brown')
    }
    legend('bottomright', legend=c('Pass', warnFailTxt), col=c('green', warnFailColor), pch=19, cex=0.4, bty='n', inset=c(0,1), xpd=T,horiz=T)
    title(main=criteria$properNames[j], cex.main=1, line=1.1)
  } 
}
```

```{r AQ-targetQC-header, eval=(params$outQC & AbsData | params$advancedQC), out.width='100%', results='asis'}
if(params$outQC){
  cat("### Target QC\n\n")
  printExcludedTargets(params$excludeTargets, PlateNames)
  cat("#### Target QC summary tables\n\n")
  cat("Target-specific QC criteria:\n\n")
  qcText <- QCTargetCriteria(AQ=AbsData, advancedQC=params$advancedQC)
  items <- paste0(qcText$properNames, " - ", qcText$explanations)
  cat(paste0("- ", items, "\n", collapse = ""))
  TargetQCSummary <- TargetQCTotal <- matrix(NA, nrow=numFiles, ncol=length(Tcriteria$thresholds) + 1)
  
  rownames(TargetQCSummary) <- rownames(TargetQCTotal) <- PlateNames
  colnames(TargetQCSummary) <- colnames(TargetQCTotal) <- c("# of Targets", names(Tcriteria$properNames))
  targetsWithWarnings <- c()  
  for(i in 1:numFiles){
    tempStorage <- runs[[i]]$qcTarget %>% filter(status==TRUE) %>% count(flagName)
    tempStorage2 <- (runs[[i]]$qcTarget %>% count(flagName))
    temp <- runs[[i]]$qcTarget %>% filter(status==TRUE) %>% pull(target)
    targetsWithWarnings <- c(targetsWithWarnings, temp)
    TargetQCSummary[i, tempStorage$flagName] <-  c(tempStorage$n)
    TargetQCSummary[is.na(TargetQCSummary)] <- 0
    TargetQCTotal[i, tempStorage2$flagName] <-  c(tempStorage2$n)
    max_targetQCTotal <- max(TargetQCTotal[i, ], na.rm=TRUE)
    if(AbsData){
      min_targetQCTotal <- min(TargetQCTotal[i, ], na.rm=TRUE)
      if(max_targetQCTotal == min_targetQCTotal){
        TargetQCSummary[i, 1] <- max_targetQCTotal
      } else {
        TargetQCSummary[i, 1] <- paste0(max_targetQCTotal, " (", min_targetQCTotal, ")") 
      }
    } else {
      TargetQCSummary[i, 1] <- max_targetQCTotal
    }
  }
  
  #numPlateWarnings <- sum(rowSums(TargetQCSummary[, 2:ncol(TargetQCSummary), drop=FALSE] > 0) > 0)
  numTargetWarnings <- length(unique(targetsWithWarnings))
  
  # add percentages
  TargetQCSummary[,2:ncol(TargetQCSummary)] <- mapply(function(x, y) {
    pct <- paste0(x, ' (', format(round(as.numeric(x) / as.numeric(y) * 100, 1), nsmall=1), '%)')
    return(pct)
  }, TargetQCSummary[,2:ncol(TargetQCSummary)], TargetQCTotal[,2:ncol(TargetQCTotal)])
  
  
  if(!AbsData){
    target_number_label <- "# of Targets"
  } else {
    if(!params$advancedQC){
      target_number_label <- "# of AQ Targets"
    } else {
      target_number_label <- "# of RQ (AQ) Targets"
    }
  }
  colnames(TargetQCSummary) <- c(target_number_label, Tcriteria$properNames)
  
  cat(tableWarningText(rep(TRUE, numTargetWarnings), textColor = "white", bgColor = "red", warningText="Number of Targets with warnings"), "\n\n")
  
  # Create base table
  render_table(TargetQCSummary, 
               first_colName = "Run",
               table_name = paste0("Number (%) of targets that have warnings for each QC criterion"), 
               table_id = "id=\"QC-summary-table-targets\"", 
               defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(TargetQCSummary)) else 10,
               highlight = if(params$highlight_TAP_report_fields) list(Data=TRUE, textColor="black", bgColor="yellow") else NULL)
}
```

```{r AQ-targetQC-tables, eval=(params$outQC), out.width='100%', results='asis'}
if(length(Tcriteria) > 0){
  for(i in 1:length(names(Tcriteria$thresholdNames))){
    resultTargetQC <- list()
    for(j in 1:numFiles){
      filtered <- runs[[j]]$qcTarget %>% filter(status == TRUE & flagName == names(Tcriteria$thresholdNames)[i])
      filtered$plateNames <- rep(PlateNames[j], nrow(filtered))
      names(filtered)[names(filtered) == "val"] <- "value"
      resultTargetQC[[j]] <- filtered[, c("plateNames", "target", "value")]
      if(Tcriteria$format[i] == "percentage"){
        resultTargetQC[[j]]$value <- suppressWarnings({as.numeric(formatC(as.numeric(resultTargetQC[[j]]$value) * 100, format="f", digits=1))})
      }
    }
    resultTable <- do.call(rbind, resultTargetQC)
    # Replace NA values with "N/A" text (CV couldn't be calculated for these targets)
    resultTable$value[is.na(resultTable$value)] <- "N/A"
    if(nrow(resultTable) > 0){
      tableMsg = "Targets with warnings: "
      # Each table needs a unique ID to prevent JavaScript rendering issues
      table_id <- paste0("id=\"target-QC-summary-table-", names(Tcriteria$thresholdNames)[i], "\"")
      if ("plateNames" %in% colnames(resultTable)) {
        colnames(resultTable)[colnames(resultTable) == "plateNames"] <- "Run"
      }
      # Add highlighting if needed
      # Create table
      print(render_table(resultTable, 
                         table_name = Tcriteria$properNames[i], 
                         table_id = table_id, 
                         rownames = FALSE,
                         highlight = if(names(Tcriteria$thresholdNames)[i]=='Target_Conc_Accuracy' && params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, textColor="black", bgColor="yellow") else NULL ))
    }
  }
}
```

```{r AQ-targetQC-plots, eval=(params$outQC & (params$advancedQC | AbsData)), out.width='100%', fig.asp=1.25, results='asis'}
# make Target QC plots
cat("#### Target QC plots\n\n")
for( i in 1:numFiles){
  # do Target QC
  qcTargetOrder <- runs[[i]]$qcTarget[rev(1:nrow(runs[[i]]$qcTarget)),]
  
  # make plots
  par(mfcol=c(1, length(Tcriteria$thresholdNames)+1), mar=c(3.5,0.05,3.5,0.05), mgp=c(2,1,0))
  # empty plot
  dotchart(x=rep(0, length(sampleType_factor)),
           xlab='',
           xlim=c(50, 100),
           labels=qcTargetOrder[inds, ]$sampleName,
           color="white",
           lcolor='white',
           gcolor='black',
           xaxt='n', frame.plot=FALSE,
           offset=-1,
           cex=0.45)
  title(main=PlateNames[i])
  
  targetNames <- NULL
  label_map <- c(
    Target_Conc_Accuracy   = "Target % Accuracy",
    Target_Conc_CV         = "% CV (AQ)",
    Target_Detectability   = "Target Detectability",
    Target_Min_Reads       = "Target Min Reads",
    Target_Conc_CV_RQ      = "%CV",
    Target_IPC_Min_Reads   = "Target IPC Min Reads (log2)"
  )
  
  for(j in 1:length(names(Tcriteria$thresholdNames))){
    inds <- which(qcTargetOrder$flagName == names(Tcriteria$properNames)[j])
    
    key <- names(Tcriteria$thresholdNames)[j]
    xlab <- label_map[[key]]
    
    if(Tcriteria$format[j] == "percentage"){
      xval <- as.numeric(qcTargetOrder[inds,]$val) * 100
    } else if(Tcriteria$format[j] == "integer"){
      xval <- as.numeric(qcTargetOrder[inds,]$val)
      if(names(Tcriteria$thresholdNames)[j] == "Target_IPC_Min_Reads"){
        xval <- log2(xval)
        xval[xval == -Inf] <- 0
      }
    }
    
    # use y labels only for first plot
    if(j==1) {
      labels <- qcTargetOrder[inds, ]$target
      targetNames <- labels
    } else {
      labels <- rep('', length(targetNames))
      names(xval)<- qcTargetOrder[inds,]$target
      # Create named vector of NAs for all labels
      complete_xval <- rep(NA, length(targetNames))
      names(complete_xval) <- targetNames
      
      # Fill in values where they exist
      complete_xval[names(xval)] <- xval
      
      # Replace xval with complete version
      xval <- complete_xval
    }
    # define colors
    color <- rep("black", length(inds))
    
    valMin = if(is.finite(QCplot_target_axis_limits[[i]]$rmin[j])) QCplot_target_axis_limits[[i]]$rmin[j] else 0
    valMax = if(is.finite(QCplot_target_axis_limits[[i]]$rmax[j])) QCplot_target_axis_limits[[i]]$rmax[j] else 1
    dotchart(x=as.numeric(xval),
             xlab=xlab,
             labels=rep('', length(xval)), las=1,
             cex=0.45, xlim=c(valMin, valMax),
             color=color, log=log)
    if(j==1){
      # need to loop over labels and color individuals
      for (k in 1:length(xval)){
        axis(side=2, at=k,
             labels=labels[k], col.axis=color[k], las=1,
             cex.axis=0.5)
      }
    }
    # color points green if PASS, yellow if WARNING, red if FAIL 
    warnFailTxt <- "Warning"
    warnFailColor <- '#ebc634'
    xvalFail <- xval
    xvalFail[which(qcTargetOrder[inds,]$status != TRUE)] <- NA
    xvalPass <- xval
    xvalPass[which(qcTargetOrder[inds,]$status != FALSE)] <- NA
    points(as.numeric(xvalFail),1:length(xvalFail), pch=19, col=warnFailColor)
    points(as.numeric(xvalPass),1:length(xvalPass), pch=19, col="green")
    
    if(names(Tcriteria$thresholdNames)[j] == "Target_Conc_Accuracy"){
      minmaxVal <- unlist(strsplit(Tcriteria$thresholds["Target_Conc_Accuracy"], ","))
      abline(v=as.numeric(minmaxVal[[1]])*100, col='brown')
      abline(v=as.numeric(minmaxVal[[2]])*100, col='brown')
      abline(v=0, col='black', lty=2)
    } else if(names(Tcriteria$thresholdNames)[j] %in% c("Target_Conc_CV_RQ", "Target_Detectability", "Target_Min_Reads", "Target_IPC_Min_Reads")){
      abline(v=0)
      if(names(Tcriteria$thresholdNames)[j] == "Target_IPC_Min_Reads"){
        detectVals <- log2(as.numeric(qcTargetOrder$QCthreshold[which(qcTargetOrder$flagName == names(Tcriteria$properNames)[j])]))
      } else{
        detectVals <- as.numeric(qcTargetOrder$QCthreshold[which(qcTargetOrder$flagName == names(Tcriteria$properNames)[j])]) * 100
      }
      # Remove NA values first, then vectorize
      valid_indices <- which(!is.na(detectVals))
      valid_vals <- detectVals[valid_indices]
      
      segments(valid_vals, valid_indices - 0.5, valid_vals, valid_indices + 0.5, col = "brown")
      
    } else if(names(Tcriteria$thresholdNames)[j] %in% c("Target_Conc_CV")){
      abline(v=0)
      threshold <- as.numeric(Tcriteria$thresholds[j]) * 100
      idx <- seq_len(length(xval))
      segments(threshold, idx - 0.5, threshold, idx + 0.5, col = "brown")
    }
    legend('bottomright', legend=c('Pass', warnFailTxt), col=c('green', warnFailColor), pch=19, cex=0.4, bty='n', inset=c(0,1), xpd=T,horiz=T)
    title(main=Tcriteria$properNames[j], cex.main=1, line=1.1)
  }
}

```

```{r top-reads-QC, eval=params$reportType=='internal', results='asis'}
cat("### Top % Reads\n\n")
cat("#### Top 10 targets\n\n")
cat("For top 10 targets by % reads on each plate, the table shows target name, % of grand total plate reads, and total target reads. Note that all targets are considered including any excluded or IC targets.\n\n")
render_table(top_targets_table,
             table_name = 'Top 10 targets by % reads',
             table_id='id=\"top-10-targets-by-reads\"',
             first_colName = "Run",
             HTML = TRUE)

cat("#### Top 10 samples\n\n")
cat("For top 10 samples by % reads on each plate, the table shows sample name, % of grand total plate reads, and total sample reads. Note that all samples are considered including any excluded or control samples.\n\n")
render_table(top_samples_table,
             table_name = 'Top 10 samples by % reads',
             table_id = 'id=\"top-10-samples-by-reads\"',
             first_colName = "Run",
             HTML = TRUE)
```

---

```{r set-detect-fig-asp, echo=FALSE}
# calculate fig.asp for detectability plots
detect_fig_asp <- min(2*ceiling(numFiles/2), 20)
```

```{r detectability-summary, results='asis', eval=(params$outDetectability), out.width='100%', fig.asp=tryCatch(detect_fig_asp, error = function(e) 0.75)}
if (params$rendered_by_shiny) shiny::setProgress(0.9, message = "Writing Document ...")
cat("## Detectability\n\n")
cat(paste0("Target detectability is the percentage of samples that are above the limit of detection for that target. A target is considered \"detectable\" if it is above limit of detection in greater than 50% of samples. \"Overall\" detectability is the overall percentage of samples across all plates that are above LOD for a given target. Target detectability reported here excludes ", CAL_IPC, ", ", AQSC_SC, ",", " & NC samples."), "\n\n")
printExcludedTargets(params$excludeTargets, PlateNames)
cat("### Detectability summary\n\n")
# Detectability summary
if (combine_detectability){
  render_table(detectability_return_summary[["Combined"]], 
               table_name = " ", 
               first_colName = "Run",
               table_id = paste0("id=\"detectability-summary-combined", "\""),
               defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(detectability_return_summary[["Combined"]])) else 10,
               highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, textColor="black", bgColor="yellow") else NULL)
  
} else {
  for (i in names(detectability_return_summary)){
    print(render_table(detectability_return_summary[[i]], 
                       table_name = paste(as.character(i)), 
                       first_colName = "Run",
                       table_id = paste0("id=\"detectability-summary", i, "\""),
                       defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(detectability_return_summary[[i]])) else 10,
                       highlight = if(params$highlight_TAP_report_fields==TRUE & i=='Overall') list(Data=TRUE, textColor="black", bgColor="yellow") else NULL))
  }
}
```

```{r detectability-target-table, results='asis', eval=(params$outDetectability), out.width='100%', fig.asp=tryCatch(detect_fig_asp, error = function(e) 0.75)}
cat("### Target detectability table\n\n")
# Target detectability
if (combine_detectability){
  render_table(detectability_return_targets[["Combined"]], 
               table_name = " ", 
               table_id = paste0("id=\"detectability-indepth-combined", "\""))
} else{
  htmltools::tagList(
    lapply(names(detectability_return_targets), function(i) {
      knitr::asis_output(render_table(detectability_return_targets[[i]],
                                      table_name = paste(as.character(i)), 
                                      table_id = paste0("id=\"detectability-indepth", i, "\""), 
                                      first_colName = "Target"))
    }))
}
```

```{r detectability-output-table, eval=params$outputDetectCSV==TRUE, include=FALSE}
# Target detectability -- output CSV file
# code depends on multipleFiles TRUE / FALSE and sampleGroupCovar NULL / non-NULL
if(multipleFiles==FALSE & is.null(params$sampleGroupCovar)){
  # put overall summary first
  detect_output_table <- detectability_return_targets[[1]]
  detect_table_names <- colnames(detect_output_table)
  detect_summary_output_table <- detectability_return_summary[[1]]
  # add n's to column name
  colnames(detect_output_table)[1] <- paste0(PlateNames[1], ' (n = ', detect_summary_output_table[1,2], ')')
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

if(multipleFiles==FALSE & !is.null(params$sampleGroupCovar)){
  # put overall summary first
  detect_output_table <- detectability_return_targets[[1]]
  detect_table_names <- colnames(detect_output_table)
  detect_summary_output_table <- detectability_return_summary[[1]]
  # add n's to columns
  for (i in 1:length(detect_table_names)){
    colnames(detect_output_table)[i] <- paste0(detect_table_names[i], ' (n = ', detect_summary_output_table[i,2], ')')
  }
  # save colnames
  detect_output_table_colnames <- colnames(detect_output_table)
  if(ncol(detect_output_table) > 1) {
    detect_output_table_colnames <-  detect_output_table_colnames[-grep("all ", colnames(detect_output_table))]
  }
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # remove "all" column
  if(ncol(detect_output_table) > 1) {
    detect_output_table <- data.frame(detect_output_table[,-grep("all ", colnames(detect_output_table))])
  }
  colnames(detect_output_table) <- detect_output_table_colnames
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

if(multipleFiles==TRUE){
  if(is.null(params$sampleGroupCovar)){
    # put overall summary first
    detect_output_table <- detectability_return_targets$Combined[,c(ncol(detectability_return_targets$Combined), 1:(ncol(detectability_return_targets$Combined) - 1))]
    detect_table_names <- colnames(detect_output_table)
    detect_summary_output_table <- detectability_return_summary$Combined[c(nrow(detectability_return_summary$Combined), 1:(nrow(detectability_return_summary$Combined) - 1)),]
    # add plate name and n's to columns
    for (i in 1:length(detect_table_names)){
      colnames(detect_output_table)[i] <- paste0(detect_table_names[i], ' (n = ', detect_summary_output_table[i,2], ')')
    }
  } else{
    # put overall summary first
    detect_output_table <- detectability_return_targets[c(length(detectability_return_targets), 1:(length(detectability_return_targets) - 1))]
    detect_table_names <- names(detect_output_table)
    detect_summary_output_table <- detectability_return_summary[c(length(detectability_return_summary), 1:(length(detectability_return_summary) - 1))]
    # add plate name and n's to columns
    for (i in 1:length(detect_table_names)){
      colnames(detect_output_table[[i]]) <- paste0(detect_table_names[i], ': ', colnames(detect_output_table[[i]]))
      colnames(detect_output_table[[i]]) <- paste0(colnames(detect_output_table[[i]]), ' (n = ', detect_summary_output_table[[i]][,2], ')')
    }
    #detect_output_table <- do.call(cbind, detect_output_table)
    # Ensure all are data frames and row names are a column
    detect_output_table <- combineCols(detect_output_table)
    # remove "all" columns
    detect_output_table <- detect_output_table[,-grep(" all ", colnames(detect_output_table))]
  }
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

# remove any columns with "combined" in the header name -- these were found to duplicate other columns
detect_output_table <- detect_output_table[,!(colnames(detect_output_table) %in% colnames(detect_output_table)[grep('combined', tolower(colnames(detect_output_table)))])]

if(params$reportType != "webApp"){
  write.csv(detect_output_table, paste0(params$outfolder, 'outputFiles/target_detectability_table.csv'))
}
```

```{r detectability-target-boxplot, results='asis', eval=(params$outDetectability), out.width='100%', fig.asp=tryCatch(detect_fig_asp, error = function(e) 0.75)}
# Target Boxplot
cat("### Target detectability boxplot\n\n")
cat(paste0("Plot shows target IC-", CAL_IPC, "-normalized count distributions relative to LOD. For each target, log2(LOD) was subtracted from log2(count) for IC-normalized data. Reverse-curve quantified targets are denoted by a \"*\" and are plotted as forward-curve targets for compatibility"), "\n\n")
par(mfrow=c(ceiling(numFiles/2), 2), mar=c(4,2,2,1))
for (i in 1:numFiles){
  # Create vector of targets to exclude: IC + hidden targets + noDetectability targets + user excluded targets
  boxplot_exclude_targets <- c(runs[[i]]$IC,
                               runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)],
                               runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)])
  if(!is.null(params$excludeTargets) && !is.null(params$excludeTargets[[i]])) {
    boxplot_exclude_targets <- c(boxplot_exclude_targets, params$excludeTargets[[i]])
  }
  boxplot_exclude_targets <- unique(boxplot_exclude_targets)

  targetBoxplot(IC_IPC$interNormData[[i]],
                title=PlateNames[i],
                subtractLOD=TRUE,
                blanks=runs[[i]]$NC,
                targetNoOutlierDetection=targetNoOutlierDetection[[i]],
                horizontal=TRUE,
                replace_zero_LOD=FALSE,
                axis_lab_normalized=TRUE,
                cex.targets=0.3,
                excludeTargets=boxplot_exclude_targets,
                excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC),
                match_matrix=runs[[i]]$match_matrix,
                targets = runs[[i]]$targets)
}
```

```{r AQ-quantifiability, results='asis', eval=(AbsData), out.width='100%', warning=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.925, message = "Writing Document ...")
knitr::asis_output("\n\n---\n\n")
cat("## Quantifiability\n\n")
cat(paste0("Target quantifiability is the percentage of samples that are within the dynamic range, that is, above the lower limit of quantification (LLOQ) and below the upper limit of quantification (ULOQ) for that target. A target is considered \"quantifiable\" if at least 50% of samples fall within the dynamic range. \"Overall\" quantifiability is the overall percentage of samples across all plates that are within the dynamic range for a given target. Target quantifiability reported here excludes ", CAL_IPC, ", ", AQSC_SC, ",", " & NC samples."), "\n\n")
cat("### Quantifiability summary\n\n")
# Quantifiability summary
AQ_quant <- tryCatch(
  AQ_quant <- quantifiability(runs, 
                              sampleGroupCovar = params$sampleGroupCovar),
  error = function(cond){
    return(NA)
  } 
)

if(is.na(AQ_quant[1])){
  cat("LLOQ and ULOQ are not present in run data for one or more runs. Quantifiability cannot be calculated.\n\n")
} else if(!is.na(AQ_quant[1])){
  group_names <- names(AQ_quant$summary_tables)
  for(i in 1:length(group_names)){
    
    print(render_table(AQ_quant$summary_tables[[i]], 
                       table_name = group_names[i], 
                       first_colName = "Run",
                       table_id = paste0("id=\"quantifiability-summary-", group_names[i], "\""),
                       defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(AQ_quant$summary_tables[[i]])) else 10,
                       highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, bgColor="yellow", textColor="black") else NULL))
  }
}

```

```{r intraCV-tables, eval=(params$outIntraPlateNorm & indicatorSC==TRUE), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("## Coefficient of variation\n\n")
cat("### Intra-plate CV summary\n\n")
cat(paste0("%CV was calculated for each target (excluding internal controls) for the ", AQSC_SC, "s and ", CAL_IPC, "s. Only values above LOD were used to calculate %CV. Some targets may have missing CV due to too many values below LOD."), "\n\n")
printExcludedTargets(params$excludeTargets, PlateNames)

cat("#### Intra-plate CV table -- unnormalized\n\n")
render_table(SC_intraCV_unnorm_summary_table, 
             table_name = paste0(AQSC_SC, ' intra-plate %CV -- unnormalized'), 
             table_id = "id=\"SC-intra-plateCV-unnorm-summary\"", 
             first_colName = "Run")

render_table(IPC_intraCV_unnorm_summary_table, 
             table_name = paste(CAL_IPC, ' intra-plate %CV -- unnormalized'), 
             table_id = "id=\"IPC-intra-plateCV-unnorm-summary\"", 
             first_colName = "Run")

cat("#### Intra-plate CV table -- IC-normalized\n\n")

render_table(SC_intraCV_IC_summary_table, 
             table_name = paste0(AQSC_SC, ' intra-plate %CV -- IC-normalized'), 
             table_id = "id=\"SC-intra-plateCV-mCherry-summary\"", 
             defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(SC_intraCV_IC_summary_table)) else 10,
             highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, textColor="black", bgColor="yellow") else NULL,
             first_colName = "Run")
render_table(IPC_intraCV_IC_summary_table, 
             table_name = paste0(CAL_IPC, ' intra-plate %CV -- IC-normalized'), 
             table_id = "id=\"IPC-intra-plateCV-mCherry-summary\"", 
             first_colName = "Run")
```

```{r intraCV-tables-no-SC, eval=(params$outIntraPlateNorm & params$reportType=="internal" & indicatorSC==FALSE), results='asis'}
cat("#### Intra-plate CV table -- unnormalized\n\n")
render_table(IPC_intraCV_unnorm_summary_table,
             table_name = paste0(CAL_IPC, ' intra-plate %CV -- unnormalized'),
             table_id = "id=\"IPC-intra-plateCV-unnorm-summary\"",
             first_colName = "Run")

cat("#### Intra-plate CV table -- IC-normalized\n\n")
render_table(IPC_intraCV_IC_summary_table, 
             table_name = paste0(CAL_IPC, ' intra-plate %CV -- IC-normalized'), 
             table_id = "id=\"intra-plateCV-mCherry-summary\"", 
             first_colName = "Run")
```

```{r keep-device-alive1, eval=TRUE, echo=FALSE, fig.show='hide'}
plot.new()
```

```{r intraCV-boxplots-SC, out.width='100%', eval=(params$outIntraPlateNorm & indicatorSC == TRUE), fig.asp=(0.05*numFiles + 0.25), results='asis'}
cat("#### Intra-plate CV boxplots by plate\n\n")
SC_intraCV_unnorm2 <- SC_intraCV_unnorm
colnames(SC_intraCV_unnorm2) <- paste0(colnames(SC_intraCV_IC), ' unnormalized')
SC_intraCV_IC2 <- SC_intraCV_IC
colnames(SC_intraCV_IC2) <- paste0(colnames(SC_intraCV_IC), ' IC-normalized')
SC_intraCV_vals <- t(interleave(t(SC_intraCV_unnorm2), t(SC_intraCV_IC2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(SC_intraCV_vals[1,])/2),
                                     nReps=2,
                                     interpolate = ifelse(
                                       ceiling(length(SC_intraCV_vals[1,])/2) > 13, TRUE, FALSE
                                     ))))
par(mar=c(5, 7, 2, 1))
if(!all(is.na((SC_intraCV_vals[, ncol(SC_intraCV_vals):1])))){
  boxplot(SC_intraCV_vals[,ncol(SC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
          ylim=c(0, max(c(SC_intraCV_vals), na.rm=TRUE)),
          main=paste0(AQSC_SC, " Intra-plate CV"), horizontal=T, cex.axis=0.5, lex.order=T,
          col=col)
  abline(v=c(0:200*5), col='grey', lty=3)
}
```

```{r intraCV-boxplots-IPC, out.width='100%', eval=(params$outIntraPlateNorm), fig.asp=(0.05*numFiles + 0.25)}
IPC_intraCV_unnorm2 <- IPC_intraCV_unnorm
colnames(IPC_intraCV_unnorm2) <- paste0(colnames(IPC_intraCV_unnorm), ' unnormalized')
IPC_intraCV_IC2 <- IPC_intraCV_IC
colnames(IPC_intraCV_IC2) <- paste0(colnames(IPC_intraCV_IC), ' IC-normalized')
IPC_intraCV_vals <- t(interleave(t(IPC_intraCV_unnorm2), t(IPC_intraCV_IC2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(IPC_intraCV_vals[1,])/2),
                                     nReps=2,
                                     interpolate = ifelse(
                                       ceiling(length(IPC_intraCV_vals[1,])/2) > 13, TRUE, FALSE
                                     ))))
par(mar=c(5, 7, 2, 1))
tmpValsY <- IPC_intraCV_vals[is.finite(IPC_intraCV_vals)]
if(length(tmpValsY) != 0){ # only plot if there are valid values
  boxplot(IPC_intraCV_vals[,ncol(IPC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
          ylim=c(0, max(tmpValsY, na.rm=TRUE)),
          main=paste0(CAL_IPC, " Intra-plate CV"), horizontal=T, cex.axis=0.5, lex.order=T,
          col=col)
  abline(v=c(0:200*5), col='grey', lty=3)
}
```

```{r AQ-intraCV-tables, eval=(params$outIntraPlateNorm & indicatorSC==TRUE & AbsData), results='asis'}
cat("#### Intra-plate CV table -- AQ\n\n")

# make AQ intra CV tables
AQ_CV <- CV_AQ(runs)
make_AQ_intraCV_table <- function(CV_data, sampleName){
  CV_table <- column_summary_stats(combineCols(lapply(CV_data$run_intraCV, function(x) x$intraCV[,sampleName])))
  rownames(CV_table) <- names(CV_data$run_intraCV)
  if(nrow(CV_table) > 1){
    average_CV <- column_summary_stats(CV_data$average_intraCV$intraCV[,sampleName])
    CV_table <- rbind(CV_table, average_CV)
    rownames(CV_table)[nrow(CV_table)] <- 'Average'
  }
  return(CV_table)
}

AQ_SC_intraCV_table <- make_AQ_intraCV_table(AQ_CV, sampleName = 'SC')
AQ_IPC_intraCV_table <- make_AQ_intraCV_table(AQ_CV, sampleName = 'IPC')

n_AQ_targets <- nrow(AQ_CV$average_intraCV$intraCV)
cat(paste0("CVs reported here were calculated on the aM units AQ data. Based on ", n_AQ_targets, " AQ targets."), "\n\n")
render_table(AQ_SC_intraCV_table, 
             table_name = paste0(AQSC_SC, ' intra-plate %CV -- AQ'), 
             table_id = "id=\"SC-intra-plateCV-AQ-summary\"", 
             defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(AQ_SC_intraCV_table)) else 10,
             highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, bgColor="yellow", textColor="black") else NULL,
             first_colName = "Run")
render_table(AQ_IPC_intraCV_table, 
             table_name = paste0(CAL_IPC, ' intra-plate %CV -- AQ'), 
             table_id = "id=\"IPC-intra-plateCV-AQ-summary\"", 
             first_colName = "Run")
```

```{r interCV-header, eval=(multipleFiles & params$outInterPlateNorm), results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.95, message = "Writing Document ...")

knitr::asis_output("\n\n---\n\n")
cat("### Inter-plate CV summary\n\n")
cat(paste0("%CV was calculated for each target (excluding internal controls) for the ", AQSC_SC, "s. Only values above LOD were used to calculate %CV. Some targets may have missing CV due to too many values below LOD."))
printExcludedTargets(params$excludeTargets, PlateNames)
```

```{r interCV-tables, eval=(multipleFiles & params$outInterPlateNorm), results='asis'}
cat("#### Inter-plate CV table\n\n")

if(params$reportType != "internal"){
  remove <- "IC + IN"
  if(indicatorSC==TRUE){
    SC_interCV_summary_table2 <- SC_interCV_summary_table[!(rownames(SC_interCV_summary_table) %in% remove),]
    SC_interCV_results2 <- SC_interCV_results[, !(colnames(SC_interCV_results) %in% remove)]
  }
  IPC_interCV_summary_table2 <- IPC_interCV_summary_table[!(rownames(IPC_interCV_summary_table) %in% remove),]
  IPC_interCV_results2 <- IPC_interCV_results[, !(colnames(IPC_interCV_results) %in% remove)]
} else {
  if(indicatorSC==TRUE){
    SC_interCV_summary_table2 <- SC_interCV_summary_table
    SC_interCV_results2 <- SC_interCV_results
  }
  IPC_interCV_summary_table2 <- IPC_interCV_summary_table
  IPC_interCV_results2 <- IPC_interCV_results
}
if(AbsData){
  rownames(SC_interCV_summary_table2) <- gsub(" IPC$", " CAL", rownames(SC_interCV_summary_table2))
  rownames(IPC_interCV_summary_table2) <- gsub(" IPC$", " CAL", rownames(IPC_interCV_summary_table2))
  colnames(SC_interCV_results2) <- gsub(" IPC$", " CAL", colnames(SC_interCV_results2))
  colnames(IPC_interCV_results2) <- gsub(" IPC$", " CAL", colnames(IPC_interCV_results2))
}

if(indicatorSC==TRUE){
  
  render_table(SC_interCV_summary_table2, 
               table_name = paste0(AQSC_SC, " inter-plate CV"), 
               table_id = "id=\"SC-inter-plateCV-summary\"", 
               defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(SC_interCV_summary_table2)) else 10,
               highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=rownames(SC_interCV_summary_table2)==paste0('IC + ', CAL_IPC), bgColor="yellow", textColor="black") else NULL,
               first_colName = "Normalization")
}
render_table(IPC_interCV_summary_table2, 
             table_name = paste0(CAL_IPC, ' inter-plate CV'), 
             table_id = "id=\"IPC-inter-plateCV-summary\"", 
             first_colName = "Normalization")
```

```{r interCV-boxplot-SC, out.width='100%', fig.asp=0.35, eval=(params$outInterPlateNorm & multipleFiles & indicatorSC), results='asis'}
cat("#### Inter-plate CV boxplot\n\n")

par(mar=c(5,12,2,1))
boxplot(SC_interCV_results2[,ncol(SC_interCV_results2):1], las=1, 
        xlab='inter-plate CV (%)',
        ylim=c(0, max(SC_interCV_results2, na.rm=TRUE)), 
        main=paste0(AQSC_SC, ' Inter-plate CV'),
        col=rev(alamarColorPalette(ncol(SC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r interCV-boxplot-IPC, out.width='100%', fig.asp=0.35, eval=(params$outInterPlateNorm & multipleFiles), results='asis'}
par(mar=c(5,12,2,1))
boxplot(IPC_interCV_results2[,ncol(IPC_interCV_results2):1], las=1, 
        xlab='inter-plate CV (%)',
        ylim=c(0, max(IPC_interCV_results2, na.rm=TRUE)), 
        main=paste0(CAL_IPC, ' Inter-plate CV'),
        col=rev(alamarColorPalette(ncol(IPC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r AQ-interCV-table, eval=(params$outInterPlateNorm & indicatorSC==TRUE & AbsData & multipleFiles), results='asis'}
cat("#### Inter-plate CV table -- AQ\n\n")

# make AQ inter CV tables
AQ_CV <- CV_AQ(runs)
make_AQ_interCV_table <- function(CV_data, sampleName){
  CV_table <- column_summary_stats(CV_data$interCV$interCV[,sampleName])
  rownames(CV_table) <- 'AQ'
  return(CV_table)
}

AQ_SC_interCV_table <- make_AQ_interCV_table(AQ_CV, sampleName = 'SC')
AQ_IPC_interCV_table <- make_AQ_interCV_table(AQ_CV, sampleName = 'IPC')

n_AQ_targets <- nrow(AQ_CV$interCV$interCV)

cat(paste0("CVs reported here were calculated on the aM units AQ data. Based on ", n_AQ_targets, " AQ targets."), "\n\n")

render_table(AQ_SC_interCV_table, 
             table_name = paste0(AQSC_SC, ' inter-plate %CV -- AQ'), 
             table_id = "id=\"SC-inter-plateCV-AQ-summary\"", 
             defaultPageSize = if(params$highlight_TAP_report_fields) max(10, nrow(AQ_SC_interCV_table)) else 10,
             highlight = if(params$highlight_TAP_report_fields==TRUE) list(Data=TRUE, bgColor="yellow", textColor="black") else NULL,
             first_colName = " ")

render_table(AQ_IPC_interCV_table, 
             table_name = paste0(CAL_IPC, ' inter-plate %CV -- AQ'), 
             table_id = "id=\"IPC-inter-plateCV-AQ-summary\"", 
             first_colName = " ")
```

```{r intraCV-target-table, eval=(params$outIntraPlateNorm & indicatorSC==TRUE), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat(paste0("### Target ", AQSC_SC, " intra-plate CV table\n\n"))
cat("Targets with any intra-plate CV > 30% are highlighted in red.\n\n")
printExcludedTargets(params$excludeTargets, PlateNames)
SC_intraCV_IC_table <- SC_intraCV_IC

# Flag targets if ANY column exceeds 30%
highlights <- apply(SC_intraCV_IC_table, 1, function(row) any(row > 30, na.rm = TRUE))
cat(tableWarningText(highlights, textColor = "white", bgColor = "red"), "\n\n")

render_table(SC_intraCV_IC_table,
             table_name = paste0(AQSC_SC, " intra-plate CV, IC-normalized"),
             table_id = "id=\"intraCV-SC-IC-norm\"",
             highlight = list(Data = highlights,
                              bgColor = "red",
                              textColor = "white",
                              bold = TRUE),
             first_colName = "Target")
```

```{r interCV-target-table, eval=(params$outInterPlateNorm & multipleFiles & indicatorSC), results='asis'}
knitr::asis_output("\n\n---\n\n")
cat(paste0("### Target ", AQSC_SC, " inter-plate CV table\n\n"))
cat(paste0("Targets with IC + ", CAL_IPC, " inter-plate CV > 30% are highlighted in red."), "\n\n")
printExcludedTargets(params$excludeTargets, PlateNames)
IC_IPCname <- which(colnames(SC_interCV_results)== paste0('IC + ', CAL_IPC))

highlights <- SC_interCV_results[, IC_IPCname] > 30
cat(tableWarningText(highlights, textColor = "white", bgColor = "red"), "\n\n")
render_table(SC_interCV_results, 
             table_name = paste0(AQSC_SC, " inter-plate CV"), 
             table_id = paste0("id=\"interCV-SC", "\""),
             highlight = list(Data = highlights,
                              bgColor = "red", 
                              textColor = "white",
                              bold = TRUE), 
             first_colName = "Target")
```

```{r SC-intraCV-interCV-scatterplot, eval=(params$outIntraPlateNorm & params$outInterPlateNorm & multipleFiles & indicatorSC & params$reportType=='internal'), results='asis', out.width='75%', fig.asp=1, fig.align = 'center', warning=FALSE}
knitr::asis_output("\n\n---\n\n")
cat(paste0("### ", AQSC_SC, " intra-plate vs inter-plate CV scatterplot\n\n"))
# SC IC normed intra CV (this is the same as IC + IPC intra CV) vs IC + IPC normed inter CV

# Get common rows between the two dataframes
common_rows <- intersect(rownames(SC_intraCV_IC), rownames(SC_interCV_results))

# Subset both dataframes to only include common rows
SC_intraCV_subset <- SC_intraCV_IC[common_rows,]
SC_interCV_subset <- SC_interCV_results[common_rows,]

SC_CV_scatter <- volcanoPlot(coefs = SC_intraCV_subset[,ncol(SC_intraCV_subset)],
                             p_vals = SC_interCV_subset[,colnames(SC_interCV_subset)==paste0('IC + ', CAL_IPC)],
                             target_labels = common_rows,
                             title = paste0(AQSC_SC, " inter-plate vs intra-plate CV"), 
                             xlabel = paste0(AQSC_SC, " intra-plate CV (%) after IC-normalization"),
                             ylabel = paste0(AQSC_SC, " inter-plate CV (%) after IC-", CAL_IPC, "-normalization"),
                             xlimits = c(0, max(c(SC_intraCV_subset[,ncol(SC_intraCV_subset)], 
                                                  SC_interCV_subset[,colnames(SC_interCV_subset)==paste0('IC + ', CAL_IPC)]), na.rm=TRUE)),
                             ylimits = c(0, max(c(SC_intraCV_subset[,ncol(SC_intraCV_subset)], 
                                                  SC_interCV_subset[,colnames(SC_interCV_subset)==paste0('IC + ', CAL_IPC)]), na.rm=TRUE)),
                             sig_threshold = -10,
                             sig_label = '',
                             log_y = FALSE, label_all_targets = TRUE, 
                             max.overlaps = 20, 
                             target_label_colors = 'darkred',
                             target_point_colors = 'black', 
                             target_label_segment_color = 'grey') +
  ggplot2::geom_abline(intercept=0, slope=1, color='grey')

SC_CV_scatter
```

```{r IPC-intraCV-interCV-scatterplot, eval=(params$outIntraPlateNorm & params$outInterPlateNorm & multipleFiles & params$reportType=='internal'), results='asis', out.width='75%', fig.asp=1, fig.align = 'center', warning=FALSE}
knitr::asis_output("\n\n---\n\n")
cat(paste0("### ", CAL_IPC, " intra-plate vs inter-plate CV scatterplot\n\n"))
# IPC IC normed intra CV vs IC normed inter CV
# Get common rows between the two dataframes
common_rows <- intersect(rownames(IPC_intraCV_IC), rownames(IPC_interCV_results))
# Subset both dataframes to only include common rows
IPC_intraCV_subset <- IPC_intraCV_IC[common_rows,]
IPC_interCV_subset <- IPC_interCV_results[common_rows,]
IPC_CV_scatter <- volcanoPlot(coefs = IPC_intraCV_subset[,ncol(IPC_intraCV_subset)],
                              p_vals = IPC_interCV_subset[,colnames(IPC_interCV_subset)=="IC"],
                              target_labels = common_rows,
                              title = paste0(CAL_IPC, " inter-plate vs intra-plate CV"), 
                              xlabel = paste0(CAL_IPC, " intra-plate CV (%) after IC-normalization"),
                              ylabel = paste0(CAL_IPC, " inter-plate CV (%) after IC-normalization"),
                              xlimits = c(0, max(c(IPC_intraCV_subset[,ncol(IPC_intraCV_subset)], 
                                                   IPC_interCV_subset[,colnames(IPC_interCV_subset)=="IC"]), na.rm=TRUE)),
                              ylimits = c(0, max(c(IPC_intraCV_subset[,ncol(IPC_intraCV_subset)], 
                                                   IPC_interCV_subset[,colnames(IPC_interCV_subset)=="IC"]), na.rm=TRUE)),
                              sig_threshold = -10,
                              sig_label = '',
                              log_y = FALSE, label_all_targets = TRUE, 
                              max.overlaps = 20, 
                              target_label_colors = 'darkred',
                              target_point_colors = 'black', 
                              target_label_segment_color = 'grey') +
  ggplot2::geom_abline(intercept=0, slope=1, color='grey')

IPC_CV_scatter
```

```{r keep-device-alive2, eval=TRUE, echo=FALSE, fig.show='hide'}
plot.new()
```

```{r SC-IPC-ratio-plot, eval=(params$out_SC_IPC_Ratio & params$reportType=='internal' & indicatorSC), results='asis', out.width='100%', fig.asp=(min(3.5*ceiling(numFiles*(nrow(runs[[1]]$targets)/200)/2), 20)), fig.align = 'center', warning=FALSE, fig.show="hold"}
knitr::asis_output("\n\n---\n\n")
cat(paste0("## ", AQSC_SC, " / ", CAL_IPC, " ratio plot\n\n"))
cat(paste0("Plot shows the log2-transformed ratio (left) or the unlogged ratio (right) of the mean IC-normalized counts for ", AQSC_SC, " vs ", CAL_IPC, "."), "\n\n")

if(numFiles > 13) barplot_colors <- rev(sapply(alamarColorPalette(numFiles, interpolate = TRUE, nReps = 10), function(x) x[6]))
if(numFiles <= 13) barplot_colors <- rev(sapply(alamarColorPalette(numFiles, interpolate = FALSE, nReps = 10), function(x) x[6]))

par(mar=c(2.5, 1, 3, 1), mgp=c(3, 0.2, 0), cex.axis=0.6, oma=c(0, 0, 3, 0), mfrow=c(1,1))
b <- barplot(t(SC_IPC_ratio_matrix),
             beside=TRUE,
             horiz=TRUE,
             las=1,
             col=barplot_colors,
             border=NA,
             xlab='', xaxt='n',
             cex.axis=0.6,
             cex.names=0.6,
             main='', 
             axisnames=FALSE, 
             yaxs="i")
b_y_coord <- apply(b, 2, mean)
grid(ny=NA)
axis(side=1, tck=-0.01, cex.axis=0.6)
axis(side=3, tck=-0.01, cex.axis=0.6)
abline(v = floor(min(SC_IPC_ratio_matrix, na.rm=TRUE)):ceiling(max(SC_IPC_ratio_matrix, na.rm=TRUE)),
       col='black', lty=1, lwd=0.5)
abline(v = floor(min(SC_IPC_ratio_matrix, na.rm=TRUE)):ceiling(max(SC_IPC_ratio_matrix, na.rm=TRUE)) + 0.5,
       col='black', lty=3, lwd=0.5)
abline(h = b_y_coord + diff(b_y_coord)[1]/2)
abline(v = 0, col = 'red', lwd=1)
text(par('usr')[1], b_y_coord, labels=rownames(SC_IPC_ratio_matrix), cex=0.5, font=2, pos = 4)
mtext(paste0("log2 (", AQSC_SC, " / ", CAL_IPC, ")"), side=1, line=1, cex=0.6)
mtext(paste0("log2 (", AQSC_SC, " / ", CAL_IPC, ")"), side=3, line=1, cex=0.6)

add_legend <- function(...) {
  opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), 
              mar=c(0, 0, 0, 0), new=TRUE)
  on.exit(par(opar))
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend(...)
}
add_legend('top',
           legend=PlateNames,
           col=rev(barplot_colors),
           pch=15, bty='n', ncol=6,
           cex=0.6, pt.cex=1.5)
```

```{r save-SC-IPC-ratio-table, eval=(params$output_SC_IPC_Ratio_CSV & indicatorSC), include=FALSE}

# SC IPC log2 ratio -- output CSV file
if(params$reportType != "webApp"){
  # make directory -- we will put the file in the outputFiles directory
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
  write.csv(SC_IPC_ratio_table, paste0(params$outfolder, "outputFiles/SC_IPC_log2_ratio_table.csv"))
}
```

```{r SC-NC-ratio-plot, eval=(params$out_SC_NC_Ratio & params$reportType=='internal' & indicatorSC), results='asis', out.width='100%', fig.asp=(min(3.5*ceiling(numFiles*(nrow(runs[[1]]$targets)/200)/2), 20)), fig.align = 'center', warning=FALSE}
knitr::asis_output("\n\n---\n\n")
cat(paste0("## ", AQSC_SC, " / NC ratio plot\n\n"))
cat(paste0("Plot shows the log2-transformed ratio of the mean IC-normalized counts for ", AQSC_SC, " versus NC. Asterisk next to target name indicates the NC mean was zero for one or more plates, so ", AQSC_SC, " / NC ratio could not be calculated for these plates."), "\n\n")

if(numFiles > 13) barplot_colors <- rev(sapply(alamarColorPalette(numFiles, interpolate = TRUE, nReps = 10), function(x) x[6]))
if(numFiles <= 13) barplot_colors <- rev(sapply(alamarColorPalette(numFiles, interpolate = FALSE, nReps = 10), function(x) x[6]))

par(mar=c(2.5, 1, 3, 1), mgp=c(3, 0.2, 0), cex.axis=0.6, oma=c(0, 0, 3, 0), mfrow=c(1,1))
b <- barplot(t(SC_NC_ratio_matrix),
             beside=TRUE,
             horiz=TRUE,
             las=1,
             col=barplot_colors,
             border=NA,
             xlab='', xaxt='n',
             cex.axis=0.6,
             cex.names=0.6,
             main='', 
             axisnames=FALSE, 
             yaxs="i")
b_y_coord <- apply(b, 2, mean)
grid(ny=NA)
axis(side=1, tck=-0.01, cex.axis=0.6)
axis(side=3, tck=-0.01, cex.axis=0.6)
abline(v = floor(min(SC_NC_ratio_matrix, na.rm=TRUE)):ceiling(max(SC_NC_ratio_matrix, na.rm=TRUE)),
       col='black', lty=1, lwd=0.5)
abline(v = floor(min(SC_NC_ratio_matrix, na.rm=TRUE)):ceiling(max(SC_NC_ratio_matrix, na.rm=TRUE)) + 0.5,
       col='black', lty=3, lwd=0.5)
abline(h = b_y_coord + diff(b_y_coord)[1]/2)
abline(v = 0, col = 'red', lwd=1)
target_labels <- rownames(SC_NC_ratio_matrix)
target_labels[target_labels %in% NC_mean_zero_targets] <- paste0(target_labels[target_labels %in% NC_mean_zero_targets], '*')
text(par('usr')[1], b_y_coord, labels=target_labels, cex=0.5, font=2, pos = 4)
mtext(ifelse(AbsData, 'log2 (AQSC / NC)', 'log2 (SC / NC)'), side=1, line=1, cex=0.6)
mtext(ifelse(AbsData, 'log2 (AQSC / NC)', 'log2 (SC / NC)'), side=3, line=1, cex=0.6)
add_legend <- function(...) {
  opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), 
              mar=c(0, 0, 0, 0), new=TRUE)
  on.exit(par(opar))
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend(...)
}
add_legend('top',
           legend=PlateNames,
           col=rev(barplot_colors),
           pch=15, bty='n', ncol=6,
           cex=0.6, pt.cex=1.5)
```

```{r save-SC-NC-ratio-table, eval=(params$output_SC_NC_Ratio_CSV & indicatorSC), include=FALSE}

# SC NC log2 ratio -- output CSV file
if(params$reportType != "webApp"){
  # make directory -- we will put the file in the outputFiles directory
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
  write.csv(SC_NC_ratio_table, paste0(params$outfolder, "outputFiles/SC_NC_log2_ratio_table.csv"))
}
```

```{r save-target-CV-table, eval=params$outputCoefVarCSV==TRUE, include=FALSE}

if(params$reportType != "webApp"){
  # make directory -- we will put the file in the outputFiles directory
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
}

# Coefficient of variation -- output CSV file
# interCV output depends on indicatorSC and multipleFiles TRUE / FALSE 

if(indicatorSC & multipleFiles){
  # set intraCV colnames
  colnames(SC_intraCV_unnorm) <- paste0('SC_intraCV_unnorm_', colnames(SC_intraCV_unnorm))
  colnames(SC_intraCV_IC) <- paste0('SC_intraCV_IC_norm_', colnames(SC_intraCV_IC))
  colnames(IPC_intraCV_unnorm) <- paste0('IPC_intraCV_unnorm_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- paste0('IPC_intraCV_IC_norm_', colnames(IPC_intraCV_IC))
  colnames(SC_intraCV_unnorm) <- gsub(' ', '_', colnames(SC_intraCV_unnorm))
  colnames(SC_intraCV_IC) <- gsub(' ', '_', colnames(SC_intraCV_IC))
  colnames(IPC_intraCV_unnorm) <- gsub(' ', '_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- gsub(' ', '_', colnames(IPC_intraCV_IC))
  # merge intra CV
  intraCV_list <- list(SC_intraCV_unnorm, SC_intraCV_IC, IPC_intraCV_unnorm, IPC_intraCV_IC)
  intraCV_table <- Reduce(merge, lapply(intraCV_list, function(x) data.frame(x, rn = row.names(x))))
  rownames(intraCV_table) <- intraCV_table[,1]
  intraCV_table <- intraCV_table[,2:ncol(intraCV_table)]
  # set interCV colnames
  colnames(SC_interCV_results) <- paste0('SC_interCV_', colnames(SC_interCV_results))
  colnames(SC_interCV_results) <- gsub(' | \\+ ', '_', colnames(SC_interCV_results))
  colnames(IPC_interCV_results) <- paste0('IPC_interCV_', colnames(IPC_interCV_results))
  colnames(IPC_interCV_results) <- gsub(' | \\+ ', '_', colnames(IPC_interCV_results))
  # merge inter CV 
  interCV_table <- merge(SC_interCV_results, IPC_interCV_results, by='row.names')
  rownames(interCV_table) <- interCV_table[,1]
  interCV_table <- interCV_table[,2:ncol(interCV_table)]
  # merge intraCV and interCV tables
  CV_output_table <- merge(intraCV_table, interCV_table, by='row.names')
  CV_output_table_rownames <- CV_output_table[,1]
  CV_output_table <- CV_output_table[,2:ncol(CV_output_table)]
  # round to 1 decimal place
  CV_output_table <- apply(CV_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(CV_output_table) <- CV_output_table_rownames
}

if(!indicatorSC & multipleFiles){
  # set intraCV colnames
  colnames(IPC_intraCV_unnorm) <- paste0('IPC_intraCV_unnorm_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- paste0('IPC_intraCV_IC_norm_', colnames(IPC_intraCV_IC))
  colnames(IPC_intraCV_unnorm) <- gsub(' ', '_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- gsub(' ', '_', colnames(IPC_intraCV_IC))
  # merge intra CV
  intraCV_list <- list(IPC_intraCV_unnorm, IPC_intraCV_IC)
  intraCV_table <- Reduce(merge, lapply(intraCV_list, function(x) data.frame(x, rn = row.names(x))))
  rownames(intraCV_table) <- intraCV_table[,1]
  intraCV_table <- intraCV_table[,2:ncol(intraCV_table)]
  # set interCV colnames
  colnames(IPC_interCV_results) <- paste0('IPC_interCV_', colnames(IPC_interCV_results))
  colnames(IPC_interCV_results) <- gsub(' | \\+ ', '_', colnames(IPC_interCV_results))
  interCV_table <- IPC_interCV_results
  # merge intraCV and interCV tables
  CV_output_table <- merge(intraCV_table, interCV_table, by='row.names')
  CV_output_table_rownames <- CV_output_table[,1]
  CV_output_table <- CV_output_table[,2:ncol(CV_output_table)]
  # round to 1 decimal place
  CV_output_table <- apply(CV_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(CV_output_table) <- CV_output_table_rownames
}

if(indicatorSC & !multipleFiles){
  # set intraCV colnames
  colnames(SC_intraCV_unnorm) <- paste0('SC_intraCV_unnorm_', colnames(SC_intraCV_unnorm))
  colnames(SC_intraCV_IC) <- paste0('SC_intraCV_IC_norm_', colnames(SC_intraCV_IC))
  colnames(IPC_intraCV_unnorm) <- paste0('IPC_intraCV_unnorm_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- paste0('IPC_intraCV_IC_norm_', colnames(IPC_intraCV_IC))
  colnames(SC_intraCV_unnorm) <- gsub(' ', '_', colnames(SC_intraCV_unnorm))
  colnames(SC_intraCV_IC) <- gsub(' ', '_', colnames(SC_intraCV_IC))
  colnames(IPC_intraCV_unnorm) <- gsub(' ', '_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- gsub(' ', '_', colnames(IPC_intraCV_IC))
  # merge intra CV
  intraCV_list <- list(SC_intraCV_unnorm, SC_intraCV_IC, IPC_intraCV_unnorm, IPC_intraCV_IC)
  intraCV_table <- Reduce(merge, lapply(intraCV_list, function(x) data.frame(x, rn = row.names(x))))
  rownames(intraCV_table) <- intraCV_table[,1]
  intraCV_table <- intraCV_table[,2:ncol(intraCV_table)]
  # round to 1 decimal place
  CV_output_table <- intraCV_table
  CV_output_table_rownames <- rownames(CV_output_table)
  CV_output_table <- apply(CV_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(CV_output_table) <- CV_output_table_rownames
}

if(!indicatorSC & !multipleFiles){
  # set intraCV colnames
  colnames(IPC_intraCV_unnorm) <- paste0('IPC_intraCV_unnorm_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- paste0('IPC_intraCV_IC_norm_', colnames(IPC_intraCV_IC))
  colnames(IPC_intraCV_unnorm) <- gsub(' ', '_', colnames(IPC_intraCV_unnorm))
  colnames(IPC_intraCV_IC) <- gsub(' ', '_', colnames(IPC_intraCV_IC))
  # merge intra CV
  intraCV_list <- list(IPC_intraCV_unnorm, IPC_intraCV_IC)
  intraCV_table <- Reduce(merge, lapply(intraCV_list, function(x) data.frame(x, rn = row.names(x))))
  rownames(intraCV_table) <- intraCV_table[,1]
  intraCV_table <- intraCV_table[,2:ncol(intraCV_table)]
  # round to 1 decimal place
  CV_output_table <- intraCV_table
  CV_output_table_rownames <- rownames(CV_output_table)
  CV_output_table <- apply(CV_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(CV_output_table) <- CV_output_table_rownames
}
if(params$reportType != "webApp"){
  write.csv(CV_output_table, paste0(params$outfolder, "outputFiles/target_CV_table.csv"))
}
```

```{r sample-boxplots, out.width='100%', eval=(params$outSampleBoxplot), fig.asp=1, results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.975, message = "Writing Document ...")
knitr::asis_output("\n\n---\n\n")
cat("## Sample boxplots\n\n")
cat(paste0("Sample boxplots show distributions of the log2 counts for each sample, unnormalized and after IC + ", CAL_IPC, " normalization."), "\n\n")
IC_name <- Reduce(intersect, lapply(runs, function(x) x$IC))

# function to draw boxplot
sampleboxplot <- function(data, 
                          data_order, 
                          title, 
                          boxplot_colors, 
                          label_colors, 
                          horiz=TRUE,
                          data_axis_limits=NULL,
                          internal_control_label='IC',
                          data_axis_label='log2(count + 1)'){
  suppressWarnings({
    par(mar=c(2,6,2,0.5))
    xlimits <- NULL
    ylimits <- data_axis_limits
    if(horiz==TRUE){
      sample_axis_side <- 2
      data_axis_side <- 1
    } else if(horiz==FALSE){
      sample_axis_side <- 1
      data_axis_side <- 2
    }
    
    boxplot(log2(data[,data_order] + 1),
            xlim=xlimits,
            ylim=ylimits,
            las=1, 
            yaxt='n',
            xaxt='n',
            ylab='',
            main=title,
            outcex=0.5,
            col=boxplot_colors[data_order], 
            horizontal=horiz, 
            cex=0.5,
            cex.main=0.75,
            cex.lab=0.75)
    
    # draw axes, Pre-compute all values once
    n_cols <- ncol(data)
    ordered_labels <- colnames(data)[data_order]
    ordered_colors <- label_colors[data_order]
    
    # Single axis call for all ticks
    axis(sample_axis_side, at=1:n_cols, labels=FALSE, cex.axis=0.3, las=2, tck=-0.01)
    
    # Single axis call for all labels (colored individually via a trick)
    for(j in 1:n_cols) {
      axis(sample_axis_side, at=j, labels=ordered_labels[j],
           cex.axis=0.3, las=2, col.axis=ordered_colors[j],
           tick=FALSE, line=-0.75)
    }
    # add internal control line
    lines(cbind(log2(data[IC_name, data_order] + 1), 1:ncol(data)), col='red', las=1)
    # add data axis label
    mtext(data_axis_label, side=1, line=0.75, cex=0.5)
    # legend
    legend('topleft', internal_control_label, col='red', lty=1, cex=0.4, bty='n')
    # grid lines
    abline(v=c(-50:50*5), col='grey', lty=3)
  })
}

for(i in 1:numFiles){
  cat(knitr::asis_output(paste0("\n\n### ", PlateNames[i], "\n\n")))
  sample_type <- runs[[i]]$samples$sampleType
  sample_type <- factor(sample_type, levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  
  # make colors
  boxplot_colors2 <- boxplot_colors[c(1,2,4,5,3)][as.numeric(sample_type)]
  label_colors <- grDevices::hcl.colors(5, palette = "Set3")[c(4,3,5,2,1)]
  label_colors[1] <- 'black'
  label_colors2 <- label_colors[as.numeric(sample_type)]
  
  # get well order
  ordering2 <- wellorder(runs[[i]]$samples, index=T) 
  ordering <- NULL
  types <- sort(unique(sample_type))
  sample_type_factor <- factor(sample_type[ordering2], levels = types)
  ordering <- c(ordering, ordering2[order(sample_type_factor)])
  
  # reverse ordering so special wells are at the bottom
  ordering <- rev(ordering)
  
  # make plots
  par(mfrow=c(1,2), mar=c(4,6,2,0))
  
  sample_boxplot_data_unnorm <- runs[[i]]$Data
  sample_boxplot_data_norm <- IC_IPC$interNormData[[i]]
  
  if(AbsData){ # change display names for IPC / CAL and SC / AQSC
    colnames(sample_boxplot_data_unnorm) <- gsub("^IPC_([1234])$", "CAL_\\1", colnames(sample_boxplot_data_unnorm))
    colnames(sample_boxplot_data_unnorm) <- gsub("^SC_([1234])$", "AQSC_\\1", colnames(sample_boxplot_data_unnorm))
    
    colnames(sample_boxplot_data_norm) <- gsub("^IPC_([1234])$", "CAL_\\1", colnames(sample_boxplot_data_norm))
    colnames(sample_boxplot_data_norm) <- gsub("^SC_([1234])$", "AQSC_\\1", colnames(sample_boxplot_data_norm))
  }
  
  sampleboxplot(sample_boxplot_data_unnorm, data_order=ordering, 
                title=paste0(PlateNames[i], ": unnormalized"), 
                boxplot_colors=boxplot_colors2,
                label_colors=label_colors2)
  
  recorded_plot <- recordPlot()
  sampleboxplot(sample_boxplot_data_norm, data_order=ordering, 
                title=paste0(PlateNames[i], ": IC + ", CAL_IPC), 
                boxplot_colors=boxplot_colors2,
                label_colors=label_colors2)
  
  if(params$outputPlots && params$reportType != "webApp"){
    pdf(paste0(params$outfolder, "outputFiles/sample_boxplot_", PlateNames[i], '.pdf'), width=4, height=9)
    par(mfrow=c(1,1), mar=c(4,6,2,0))
    replayPlot(recorded_plot)
    dev.off()
  }
}
```

```{r keep-device-alive3, eval=TRUE, echo=FALSE, fig.show='hide'}
plot.new()
```

```{r sample-correlation-heatmap, out.width='100%', eval=(params$outSampleCorrelation), fig.asp=1, results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("## Sample correlation\n\n")
cat("Plot shows the Pearson correlation between samples. Hierarchical clustering is done using complete linkage.\n\n")

# Precompute correlations
cor_mats <- lapply(data_IC_IPC_log2_scaled, function(x) cor(x, use="complete.obs"))
process_plate <- function(i, cmat, IPC_wells, NC_wells, SC_wells, Bridge_wells,
                          indicatorSC, indicatorBridge, AbsData, PlateNames, boxplot_colors, colorpalette){
  hc <- hclust(as.dist(1-cmat), method="complete")
  ord <- hc$order
  cmat <- cmat[ord, ord]
  well_types <- list(IPC_wells, NC_wells)
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells))}
  colors <- wellcolors(data=cmat, 
                       well_types=well_types, 
                       boxplot_colors=boxplot_colors)
  if(AbsData){
    colnames(cmat) <- sub("^IPC_([1234])$", "CAL_\\1", colnames(cmat))
    colnames(cmat) <- sub("^SC_([1234])$", "AQSC_\\1", colnames(cmat))
    rownames(cmat) <- sub("^IPC_([1234])$", "CAL_\\1", rownames(cmat))
    rownames(cmat) <- sub("^SC_([1234])$", "AQSC_\\1", rownames(cmat))
  }
  cat(paste0("\n\n### ", PlateNames[i], "\n\n"))
  corrplot::corrplot(
    cmat,
    tl.cex=0.4,
    mar=c(1,1,1,1),
    tl.col=colors,
    order="original",
    title=PlateNames[i],
    col=colorpalette, 
    is.corr=FALSE)
  cat("\n")
  invisible(NULL)
}
colorpalette <- colorRampPalette(c("blue","white","red"))(200)
for(i in seq_along(cor_mats)){
  process_plate(
    cmat = cor_mats[[i]],  # Only pass the specific matrix needed
    IPC_wells = IPC_wells[[i]],
    NC_wells = NC_wells[[i]],
    SC_wells = SC_wells[[i]],
    Bridge_wells = Bridge_wells[[i]],
    indicatorSC = indicatorSC,
    indicatorBridge = indicatorBridge,
    AbsData = AbsData,
    PlateNames = PlateNames[i],  # Only pass the specific plate name
    boxplot_colors = boxplot_colors,
    colorpalette = colorpalette
  )
}
```

```{r sample-target-clustered-heatmap, out.width='100%', eval=(params$outSampleClustering), fig.asp=1, results='asis'}
knitr::asis_output("\n\n---\n\n")
cat("## Sample and target clustering\n\n")
cat(paste0("Hierarchical clustering of both samples and targets was done using a Euclidean distance metric and complete linkage. Data is log2 and IC-", CAL_IPC, " normalized; targets are centered and scaled."), "\n\n")
# define colors
paletteLength <- 50
heatmapColors <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
# loop over plates and draw heatmaps
for(i in 1:numFiles){
  cat(paste0("\n### ", PlateNames[i], "\n\n"))
  # define label colors
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  label_colors <- wellcolors(data=data_IC_IPC_log2_scaled[[i]], 
                             well_types=well_types, 
                             boxplot_colors=boxplot_colors)
  # define color scale breaks
  # omit NCs for determining min
  breaks <- c(seq(min(data_IC_IPC_log2_no_NC_scaled[[i]],na.rm=TRUE), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_IC_IPC_log2_scaled[[i]], na.rm=TRUE)/paletteLength, 
                  max(data_IC_IPC_log2_scaled[[i]], na.rm=TRUE), length.out=floor(paletteLength/2)))
  # transpose and add color variable
  data_IC_IPC_log2_scaled2 <- data.frame(t(data_IC_IPC_log2_scaled[[i]]))
  data_IC_IPC_log2_scaled2$label_colors <- label_colors
  # generate heatmap for plate i
  if(AbsData){
    rownames(data_IC_IPC_log2_scaled2) <- gsub("^IPC_([1234])$", "CAL_\\1", rownames(data_IC_IPC_log2_scaled2))
    rownames(data_IC_IPC_log2_scaled2) <- gsub("^SC_([1234])$", "AQSC_\\1", rownames(data_IC_IPC_log2_scaled2))
  }
  vals <- data_IC_IPC_log2_scaled2[,1:(ncol(data_IC_IPC_log2_scaled2) - 1)]
  
  # Define some default values
  # These default values will be consumed by the pheatmap function when the `sampleGroupCovar` parameter is NULL
  annotation_row <- NULL
  annotation_legend <- FALSE
  annotation_colors <- NULL
  
  # if sampleGroupCovar is defined, add annotation
  if(!is.null(params$sampleGroupCovar)){
    annotation_row <- as.data.frame(as.factor(runs[[i]]$samples[,params$sampleGroupCovar]))
    rownames(annotation_row) <- runs[[i]]$samples$sampleName
    colnames(annotation_row) <- 'Sample group'
    annotation_legend <- TRUE
    n_levels <- length(levels(annotation_row$`Sample group`))
    if(n_levels <= 9) {
      annotation_colors <- alamarColorPalette(n=13)[c(1:6,8,10,13)]
    } else if (n_levels > 9) {
      annotation_colors <- alamarColorPalette(n=n_levels, interpolate = TRUE)
    }
    annotation_colors <- list(`Sample group`=annotation_colors[1:n_levels])
    names(annotation_colors$`Sample group`) <- levels(annotation_row$`Sample group`)
  }
  heatmap_i <- pheatmap::pheatmap(vals[,colSums(is.na(vals))==0],
                                  main = PlateNames[i], 
                                  fontsize=5,
                                  color=heatmapColors,
                                  breaks=breaks,
                                  show_colnames=FALSE, 
                                  annotation_row = annotation_row,
                                  annotation_legend = annotation_legend,
                                  annotation_names_row=FALSE,
                                  annotation_colors = annotation_colors,
                                  silent=TRUE)
  # put colors in order
  label_colors_ordered <- data_IC_IPC_log2_scaled2[order(match(rownames(data_IC_IPC_log2_scaled2), heatmap_i$gtable$grobs[[5]]$label)),]$label_colors
  # add label colors to plot
  heatmap_i$gtable$grobs[[5]]$gp=gpar(col=label_colors_ordered)
  grid::grid.newpage()
  grid::grid.draw(heatmap_i$gtable)
  cat("\n")
}
```

```{r keep-device-alive4, eval=TRUE, echo=FALSE, fig.show='hide'}
plot.new()
```

```{r samplePCA, out.width='100%', fig.asp=(0.55)+as.numeric(multipleFiles)*0.25, results='asis', eval=(params$outSamplePCA)}
knitr::asis_output("\n\n---\n\n")
cat("## Sample PCA\n\n")
# function to make PCA plot
PCAplot <- function(data, plateID, IPC_samples, SC_samples, Bridge_samples, scale=TRUE, center=TRUE, title=NULL, showlegend=TRUE, nrows=1, showButtons=TRUE){
  
  data <- data[, which(apply(data, 2, function(x) sd(x, na.rm=TRUE)) != 0)] # remove columns with stdev = 0
  data <- data[which(apply(data, 1, function(x) sd(x, na.rm=TRUE)) != 0),] # remove rows with stdev = 0
  data <- data[which(rowSums(is.na(data)) == 0),] # remove rows with NA values (presumably missing targets)
  
  pca <- prcomp(log2(t(data) + 1), scale=scale, center=center)
  plateID <- factor(plateID)
  
  colors <- alamarColorPalette(length(levels(plateID)),
                               interpolate = ifelse(
                                 length(levels(plateID)) > 13, TRUE, FALSE
                               ))
  
  # Axis labels with % variance
  pc1 <- pca$x[, 1]
  pc2 <- pca$x[, 2]
  x_lab <- paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), '% variance)')
  y_lab <- paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), '% variance)')
  
  # Create dataframe with sample information
  df <- data.frame(
    PC1 = pc1,
    PC2 = pc2,
    plateID = plateID,
    sampleName = colnames(data),
    stringsAsFactors = FALSE
  )
  
  # Determine sample types
  df$sampleType <- "Regular"
  df$sampleType[df$sampleName %in% IPC_samples] <- "IPC"
  df$sampleType[df$sampleName %in% SC_samples] <- "SC"
  df$sampleType[df$sampleName %in% Bridge_samples] <- "Bridge"
  
  # Define symbols for each sample type
  shape_mapping <- list(
    "Regular" = "circle",
    "IPC" = "star",
    "SC" = "diamond",
    "Bridge" = "triangle-up"
  )
  
  # Build trace information BEFORE creating the plot to ensure correct order
  trace_info <- list()
  trace_count <- 0
  
  for (i in seq_along(levels(plateID))) {
    plate <- levels(plateID)[i]
    for (sample_type in unique(df$sampleType)) {
      df_subset <- df[df$plateID == plate & df$sampleType == sample_type, ]
      if (nrow(df_subset) > 0) {
        trace_count <- trace_count + 1
        trace_info[[trace_count]] <- list(
          plate = plate, 
          sample_type = sample_type,
          trace_index = trace_count
        )
      }
    }
  }
  
  plt <- plot_ly()
  used_legends <- character(0)
  
  # Create traces for each plate-sampletype combination (same order as trace_info)
  current_trace <- 0
  for (i in seq_along(levels(plateID))) {
    plate <- levels(plateID)[i]
    plate_color <- colors[i]
    
    for (sample_type in unique(df$sampleType)) {
      df_subset <- df[df$plateID == plate & df$sampleType == sample_type, ]
      
      if (nrow(df_subset) > 0) {
        current_trace <- current_trace + 1
        
        # Show legend only for Regular samples (represents the plate)
        show_legend <- showlegend && sample_type == "Regular" && !(plate %in% used_legends)
        if (show_legend) used_legends <- union(used_legends, plate)
        
        # Create trace name that includes sample type for identification
        trace_name <- if (sample_type == "Regular") plate else paste0(plate, "_", sample_type)
        
        plt <- add_trace(
          plt,
          data = df_subset,
          x = ~PC1,
          y = ~PC2,
          type = 'scatter',
          mode = 'markers',
          name = trace_name,
          marker = list(
            color = plate_color,
            size = 6,
            symbol = shape_mapping[[sample_type]]
          ),
          text = ~paste0(plateID, ": ", sampleName, " (", sampleType, ")"),
          hoverinfo = 'text',
          showlegend = show_legend,
          legendgroup = plate, # All samples from same plate grouped together
          visible = TRUE
        )
      }
    }
  }
  
  # Get unique sample types (excluding Regular)
  sample_types_present <- unique(df$sampleType[df$sampleType != "Regular"])
  
  # Create button list
  button_list <- list()
  
  # Create "Hide All" button that hides only special sample types
  hide_all_array <- sapply(trace_info, function(trace) {
    if (trace$sample_type == "Regular") {
      TRUE  # Keep regular samples visible
    } else {
      FALSE  # Hide special sample types
    }
  })
  
  # Add "Hide All" button first
  button_list[[1]] <- list(
    method = "restyle",
    args = list("visible", hide_all_array),
    label = " Hide All Controls"
  )
  
  button_list[[2]] <- list(
    method = "restyle",
    args = list("visible", rep(TRUE, trace_count)),
    label = " Show All Controls"
  )
  
  # Individual sample type toggle buttons
  for (i in seq_along(sample_types_present)) {
    sample_type <- sample_types_present[i]
    # Get symbol for this sample type
    symbol_map <- list("IPC" = "", "SC" = "", "Bridge" = "")
    symbol <- ifelse(sample_type %in% names(symbol_map), symbol_map[[sample_type]], "")
    
    # Create arrays for showing/hiding this sample type
    hide_array <- sapply(trace_info, function(trace) {
      if (trace$sample_type == sample_type) {
        FALSE  # Hide this sample type
      } else {
        TRUE   # Keep others visible
      }
    })
    
    show_array <- sapply(trace_info, function(trace) {
      TRUE  # Show all (used for show button)
    })
    
    # Hide button
    button_list[[length(button_list) + 1]] <- list(
      method = "restyle",
      args = list("visible", hide_array),
      label = paste0(" Hide ", symbol, " ", sample_type)
    )
    
    # Show button
    button_list[[length(button_list) + 1]] <- list(
      method = "restyle",
      args = list("visible", show_array),
      label = paste0(" Show ", symbol, " ", sample_type)
    )
  }
  
  # Adjust legend and button y-positions based on number of rows

  # When nrows=1, position legend higher and buttons well below the plot
  # When nrows=2, use original positioning (buttons fit between rows)
  legend_y <- if (nrows == 1) 0.9 else 0.75
  button_y_start <- if (nrows == 1) -0.08 else 0.25
  button_y_spacing <- if (nrows == 1) 0.18 else 0.10

  plt <- plt %>%
    plotly::config(
      displaylogo = FALSE,
      displayModeBar = TRUE,
      modeBarButtonsToRemove = c("hoverClosestCartesian", "hoverCompareCartesian", "lasso2d", "select2d", "autoScale2d")
    ) %>%
    layout(
      annotations = list(
        list(
          text = title,
          x = 0.5,
          y = 1,
          xref = "paper",
          yref = "paper",
          yanchor = "bottom",
          xanchor = "center",
          align = "center",
          showarrow = FALSE
        ),
        list(
          text = " ",
          x = 0.02,
          y = 0.98,
          xref = "paper",
          yref = "paper",
          yanchor = "top",
          xanchor = "left",
          align = "left",
          showarrow = FALSE,
          font = list(size = 10, color = "gray")
        )
      ),
      xaxis = list(title = x_lab),
      yaxis = list(title = y_lab),
      legend = list(
        title = list(text = 'Plate ID'),
        tracegroupgap = 10,
        y = legend_y,
        yanchor = "middle",
        x = 1.02,
        xanchor = "left",
        bgcolor = "rgba(255,255,255,0.9)",
        bordercolor = "rgba(0,0,0,0.3)",
        borderwidth = 1,
        itemsizing = "constant",
        itemwidth = 30,
        font = list(size = 10)
      ),
      updatemenus = if (showButtons) {
        menu_list <- list()

        # Show/Hide All buttons - positioned well below legend
        menu_list[[1]] <- list(
          type = "buttons",
          direction = "right",
          showactive = FALSE,
          x = 1.02,
          y = button_y_start,
          xanchor = "left",
          yanchor = "top",
          buttons = list(button_list[[1]], button_list[[2]])
        )

        # Create paired buttons for each sample type
        for (i in seq_along(sample_types_present)) {
          sample_type <- sample_types_present[i]
          symbol_map <- list("IPC" = "", "SC" = "", "Bridge" = "")
          symbol <- ifelse(sample_type %in% names(symbol_map), symbol_map[[sample_type]], "")

          # Find the correct button indices for this sample type
          hide_button_index <- 2 + (i-1)*2 + 1  # Skip the first 2 buttons, then pairs
          show_button_index <- 2 + (i-1)*2 + 2

          # Add horizontal button pair for this sample type
          menu_list[[length(menu_list) + 1]] <- list(
            type = "buttons",
            direction = "right",
            showactive = FALSE,
            x = 1.02,
            y = button_y_start - (i * button_y_spacing),
            xanchor = "left",
            yanchor = "top",
            buttons = list(
              button_list[[hide_button_index]],
              button_list[[show_button_index]]
            )
          )
        }

        menu_list
      } else {
        list()  # Empty list when buttons not shown
      }
    )
  
  return(plt)
}


# function to remove targets and samples
removeTargetsSamples <- function(data, NC, IC){
  data <- data[-which(grepl(paste(IC, collapse="|"), rownames(data))),]
  data <- data[,-which(grepl(paste(NC, collapse="|"), colnames(data)))]
  return(data)
}

# merge data across plates for PCA
# Initialize lists to store data from each plate
dataPCA_unnorm_list <- dataPCA_IC_list <- dataPCA_ICIPC_list <- dataPCA_ICIN_list <- list()
plateID <- NULL

# First collect all data into lists
for(i in 1:numFiles) {
  dataPCA_unnorm_list[[i]] <- removeTargetsSamples(runs[[i]]$Data, runs[[i]]$NC, runs[[i]]$IC)
  dataPCA_IC_list[[i]] <- removeTargetsSamples(intraPlateNormData[[i]]$normData, runs[[i]]$NC, runs[[i]]$IC)
  dataPCA_ICIPC_list[[i]] <- removeTargetsSamples(IC_IPC$interNormData[[i]], runs[[i]]$NC, runs[[i]]$IC)
  dataPCA_ICIN_list[[i]] <- removeTargetsSamples(IC_IN$interNormData[[i]], runs[[i]]$NC, runs[[i]]$IC)
  plateID <- c(plateID, rep(PlateNames[i], ncol(dataPCA_unnorm_list[[i]])))
}

# Get all unique row names across all plates
all_rows_unnorm <- unique(unlist(lapply(dataPCA_unnorm_list, rownames)))
all_rows_IC <- unique(unlist(lapply(dataPCA_IC_list, rownames)))
all_rows_ICIPC <- unique(unlist(lapply(dataPCA_ICIPC_list, rownames)))
all_rows_ICIN <- unique(unlist(lapply(dataPCA_ICIN_list, rownames)))

# Get all col names across all plates
all_cols_unnorm <- unlist(lapply(dataPCA_unnorm_list, colnames))
all_cols_IC <- unlist(lapply(dataPCA_IC_list, colnames))
all_cols_ICIPC <- unlist(lapply(dataPCA_ICIPC_list, colnames))
all_cols_ICIN <- unlist(lapply(dataPCA_ICIN_list, colnames))

# Initialize matrices with NA
dataPCA_unnorm <- matrix(NA, nrow=length(all_rows_unnorm), ncol=length(plateID))
dataPCA_IC <- matrix(NA, nrow=length(all_rows_IC), ncol=length(plateID))
dataPCA_ICIPC <- matrix(NA, nrow=length(all_rows_ICIPC), ncol=length(plateID))
dataPCA_ICIN <- matrix(NA, nrow=length(all_rows_ICIN), ncol=length(plateID))

# Fill matrices with data
col_start <- 1
for(i in 1:numFiles) {
  cols <- col_start:(col_start + ncol(dataPCA_unnorm_list[[i]]) - 1)
  
  # For unnormalized data
  match_rows <- match(rownames(dataPCA_unnorm_list[[i]]), all_rows_unnorm)
  dataPCA_unnorm[match_rows, cols] <- as.matrix(dataPCA_unnorm_list[[i]])
  
  # For IC data
  match_rows <- match(rownames(dataPCA_IC_list[[i]]), all_rows_IC)
  dataPCA_IC[match_rows, cols] <- as.matrix(dataPCA_IC_list[[i]])
  
  # For ICIPC data
  match_rows <- match(rownames(dataPCA_ICIPC_list[[i]]), all_rows_ICIPC)
  dataPCA_ICIPC[match_rows, cols] <- as.matrix(dataPCA_ICIPC_list[[i]])
  
  # For ICIN data
  match_rows <- match(rownames(dataPCA_ICIN_list[[i]]), all_rows_ICIN)
  dataPCA_ICIN[match_rows, cols] <- as.matrix(dataPCA_ICIN_list[[i]])
  
  col_start <- col_start + ncol(dataPCA_unnorm_list[[i]])
}

# Set row names
rownames(dataPCA_unnorm) <- all_rows_unnorm
rownames(dataPCA_IC) <- all_rows_IC
rownames(dataPCA_ICIPC) <- all_rows_ICIPC
rownames(dataPCA_ICIN) <- all_rows_ICIN
colnames(dataPCA_unnorm) <- all_cols_unnorm
colnames(dataPCA_IC) <- all_cols_IC
colnames(dataPCA_ICIPC) <- all_cols_ICIPC
colnames(dataPCA_ICIN) <- all_cols_ICIN
IPC_all <- unlist(lapply(runs, function(x) x$IPC))
SC_all <- unlist(lapply(runs, function(x) x$SC))
Bridge_all <- unlist(lapply(runs, function(x) x$Bridge))

# set plot layout params
nRowsPCA <- if(multipleFiles) 2 else 1
nCols <- 2

# draw plots
plots <- list()

# --- Plot 1: Generate the master legend (no buttons) ---
plots[[1]] <- PCAplot(dataPCA_unnorm, plateID, IPC_samples=IPC_all,
                      SC_samples=SC_all, Bridge_samples=Bridge_all,
                      title="Unnormalized",
                      showlegend = TRUE,
                      nrows = nRowsPCA,
                      showButtons = FALSE)

# --- Plot 2: IC plot with buttons (top-right position) ---
plots[[2]] <- PCAplot(dataPCA_IC, plateID, IPC_samples=IPC_all,
                      SC_samples=SC_all, Bridge_samples=Bridge_all,
                      title="IC",
                      showlegend = FALSE,
                      nrows = nRowsPCA,
                      showButtons = TRUE)

if(multipleFiles){
  plots[[3]] <- PCAplot(dataPCA_ICIPC, plateID, IPC_samples=IPC_all,
                        SC_samples=SC_all, Bridge_samples=Bridge_all,
                        title=paste0("IC + ", CAL_IPC),
                        showlegend = FALSE,
                        nrows = nRowsPCA,
                        showButtons = FALSE)

  if(params$reportType == "internal"){
    plots[[4]] <- PCAplot(dataPCA_ICIN, plateID, IPC_samples=IPC_all,
                          SC_samples=SC_all, Bridge_samples=Bridge_all,
                          title="IC + IN",
                          showlegend = FALSE,
                          nrows = nRowsPCA,
                          showButtons = FALSE)
  }
}

plotly::subplot(plots, nrows = nRowsPCA, shareX = FALSE, shareY = FALSE,
                margin = 0.1, titleX = TRUE, titleY = TRUE)
```

```{r plate-effect-QC-summary, eval=(params$outPlateEffect & multipleFiles), results='asis', warning=FALSE}
if(multipleFiles){
  cat("\n\n---\n\n")
  cat("## Batch effect assessment\n\n")

  # Report excluded noDetectability targets (e.g., rare variant-specific or PTM targets)
  if(length(batch_effect_noDetectability_targets) > 0){
    cat(paste0("Note: Rare variant-specific, PTM, or other special targets were excluded from batch effect assessment: ",
                    paste(batch_effect_noDetectability_targets, collapse = ", "), "."), "\n\n")
  }

  if(!is.null(params$sampleGroupCovar)){
    additionalText <- if(params$reportType != "webApp") "Change the plate_effect_group parameter to test for batch effects in other sample subgroups. " else ""
    cat(paste0("Note: Batch effect assessment was performed for samples with the value ", plate_effect_group, " for the sample group variable ", params$sampleGroupCovar, ". All other samples were omitted from batch effect assessment. ", additionalText, "Results assume samples were randomly assigned to each run; non-randomized designs may yield spurious batch effects."), "\n\n")
  }

  if(length(plate_effect_excluded_plates) > 0){
    cat(paste0("Note: The following runs were excluded from batch effect assessment because they had no samples after filtering: ",
                    paste(plate_effect_excluded_plates, collapse = ", "), "."), "\n\n")
  }

  cat("### Batch effect summary table\n\n")

  plate_effect_column_descriptions <- c(
    paste0("Batch effect QC - A run will have a batch effect QC warning if ", params$plate_effect_sig_pct_threshold, '% or more of targets are significant. Significant targets have a significant global ANOVA F-test (unadjusted p < ', params$plate_effect_pval_ANOVA, ') and significant pairwise tests (Tukey-adjusted p < ', params$plate_effect_pval_pairwise, ') in comparisons with 50% or more of the other runs.'),
    paste0("n % sig targets - Number and percent of targets that show significant pairwise difference in sample mean for that run versus 50% or more of the other runs. Significant targets have a significant ANOVA F-test (unadjusted p < ", params$plate_effect_pval_ANOVA, ") and significant pairwise differences have Tukey-adjusted p < ", params$plate_effect_pval_pairwise, '. Click on values to show/hide target names.'),
    "n % low IPC reads - Number and percent of targets with median IPC raw reads below 200. Click on values to show/hide target names.",
    "n % low sample reads - Number and percent of targets with median sample raw reads below 200. Click on values to show/hide target names."
  )

  cat(paste0("- ", plate_effect_column_descriptions, "\n", collapse = ""))
  
  colnames(plate_effect_plate_table)[colnames(plate_effect_plate_table)=='PlateID'] <- 'Run'
  colnames(plate_effect_plate_table)[colnames(plate_effect_plate_table)=='plate effect QC'] <- 'Batch effect QC'
  plate_effect_table_columns <- c("Run","n samples","instrument","Batch effect QC",
                                  "n % sig targets", "sig targets",
                                  "n % low IPC reads","low IPC reads targets",
                                  "n % low sample reads", "low sample reads targets")
  
  # Create subset for display
  plate_effect_display_table <- plate_effect_plate_table[,colnames(plate_effect_plate_table) %in% plate_effect_table_columns]
  
  # Count warnings from the Batch effect QC column
  warning_highlights <- plate_effect_display_table$`Batch effect QC` == "Warning"
  cat(tableWarningText(warning_highlights, textColor = "white", bgColor = "red"), "\n\n")
  
  # Create highlights for table rows
  highlights <- plate_effect_display_table$`Batch effect QC` == "Warning"
  render_table(plate_effect_display_table,
               table_name = 'Batch effect statistics by run',
               table_id = "id=\"plate-effect-QC-summary-table\"",
               highlight = list(Data = highlights,
                                bgColor="#ebc634",
                                textColor="black"),
               tooltips = list(
                 "n % sig targets" = "sig targets",
                 "n % low IPC reads" = "low IPC reads targets",
                 "n % low sample reads" = "low sample reads targets"
               ),
               rownames = FALSE,
               custom_columns = list(`n samples` = colDef(format = colFormat(digits = 0))))
}
```

```{r plate-effect-targets-table, eval=(params$outPlateEffect & multipleFiles), results='asis', warning=FALSE}
if(multipleFiles){
  cat("\n\n---\n\n")
  cat("### Batch effect: Target QC summary\n\n")

  cat(paste0("A target will have a QC warning if run ICC > ", params$plate_effect_icc_threshold, "%, significant F-test (unadjusted p < ", params$plate_effect_pval_ANOVA, ") and significant pairwise tests (Tukey-adjusted p < ", params$plate_effect_pval_pairwise, ") for at least one run."), "\n\n")

  if (is.null(plate_effect_boxplot_targets)){
    cat("**There were no targets with a batch effect QC warning.**\n\n")
  } else if (!is.null(plate_effect_boxplot_targets)){
    if (length(plate_effect_boxplot_targets)==0){
      cat("**There were no targets with a batch effect QC warning.**\n\n")
    } else {
      cat(paste0("**", length(plate_effect_boxplot_targets), " targets have a batch effect QC warning.**"), "\n\n")

      plate_effect_target_column_descriptions <- c(
        "Fstat - Batch effect ANOVA F-statistic. Targets are sorted in order of F statistic.",
        "Ftest pval - ANOVA F-test p-value. P-values are unadjusted.",
        "ICC plate - Inter-class correlation, the percentage of variability attributable to plate.",
        "% sig pairwise - Percent of plates that show significant pairwise differences in mean with at least 50% of other plates",
        "% plates low IPC - Percent of plates that have median IPC reads < 200.",
        "% plates low sample reads - Percent of plates that have median sample reads < 200."
      )

      plate_effect_target_table_columns <- c("target", "Fstat", "Ftest pval", "ICC plate",
                                             "% sig pairwise", "% plates low IPC", "% plates low sample reads")

      cat(paste0("- ", plate_effect_target_column_descriptions, "\n", collapse = ""))
      df <- plate_effect_target_table[plate_effect_target_table$target %in% plate_effect_boxplot_targets,plate_effect_target_table_columns]
      df[, -1] <- lapply(df[, -1], as.numeric)
      render_table(df,
                   table_name = 'Targets with batch effect QC warning',
                   table_id = paste0("id=\"plate-effect-targets-table", "\""),
                   rownames=FALSE)
    }
  }
  
  # DT::datatable(plate_effect_target_table,
  #               options=list(lengthMenu = list(c(-1, 50, 100, 200),
  #                                   c('All', '50', '100', '200'))))
}
```

```{r random_plate-effect-icc_scatterplot, eval=(params$outPlateEffect & multipleFiles), results='asis', out.width='75%', fig.asp=1, fig.align = 'center', warning=FALSE}
if(multipleFiles){
  cat("\n\n---\n\n")
  cat("### Batch effect ICC scatterplot\n\n")
  cat(paste0("A linear mixed effect model was fit for each target with plate ID as random effect. The run-related intra-class correlation is the ratio of the estimated run-related variance to the sum of run and residual variance. This is multiplied by 100 and can be interpreted as the percent of variance attributable to run. Target is highlighted if ICC > ", params$plate_effect_icc_threshold, "%."), "\n\n")

  cat(paste0("**", sum(plate_effect_target_table$`ICC plate significant`, na.rm=TRUE), " targets have run ICC > ", params$plate_effect_icc_threshold, "%.**"), "\n\n")
  
  printExcludedTargets(params$excludeTargets, PlateNames)
  
  suppressWarnings(plate_effect_icc_results[[1]]$ICC_scatter)
}
```

```{r set-plate-test-boxplot-params, eval=(params$outPlateEffect & multipleFiles), include=FALSE}
if(!multipleFiles){
  n_plot_cols <- 1
  n_plot_rows <- 1
} else if(multipleFiles){
  n_boxplots <- min(params$plate_effect_max_target_boxplots, length(plate_effect_boxplot_targets), na.rm=TRUE)
  if(n_boxplots == 0){
    n_plot_cols <- 1
    n_plot_rows <- 1
  } else {
    # set number of boxplot columns and rows
    n_plot_cols <- 2
    n_plot_rows <- ceiling(n_boxplots / n_plot_cols)
  }
} 

figure_aspect <- 0.8 * (n_plot_rows / n_plot_cols)
```

```{r plate-effect-test-target-boxplots, eval=(params$outPlateEffect & multipleFiles), results='asis', out.width='100%', fig.align = 'center',  fig.asp = tryCatch(figure_aspect, error = function(e) 0.75), warning=FALSE}
if(multipleFiles){
  cat("### Target boxplots\n\n")

  cat(paste0("Boxplots are shown for targets with batch effect QC warning. A target will have a QC warning if run ICC > ", params$plate_effect_icc_threshold, "%, global ANOVA F-test is significant (unadjusted p < ", params$plate_effect_pval_ANOVA, ") and target has significant pairwise tests for at least one run (Tukey-adjusted p < ", params$plate_effect_pval_pairwise, " with at least 50% of other runs). Red asterisks above boxplots indicate runs showing significant pairwise test with 50% or more runs."), "\n\n")
  
  if (is.null(plate_effect_boxplot_targets)){
    cat("**There were no targets with a batch effect QC warning.**\n\n")
  } else if (!is.null(plate_effect_boxplot_targets)){
    if (length(plate_effect_boxplot_targets)==0){
      cat("**There were no targets with a batch effect QC warning.**\n\n")
    } else {
      cat(paste0("**", length(plate_effect_boxplot_targets), " targets have a batch effect QC warning.**"), "\n\n")
      if(length(plate_effect_boxplot_targets) != n_boxplots){
        cat(paste0("Plots for the top ", n_boxplots, " targets based on plate ICC are shown below."), "\n\n")
      }
      
      # make plate colors
      if(numFiles < 13) plate_effect_boxplot_colors <- alamarColorPalette(numFiles)
      if(numFiles >= 13) plate_effect_boxplot_colors <- alamarColorPalette(numFiles, interpolate = TRUE)
      
      
      par(mfrow=c(n_plot_rows, n_plot_cols))
      for(i in 1:n_boxplots){
        if(!is.null(params$sampleGroupCovar)){
          par(mar=c(8,2.5,2,0.5))
          # par(mar=c(0,0,0,0))
          ymin <- min(plate_test_data[plate_effect_boxplot_targets[i],], na.rm=TRUE)
          ymax <- max(plate_test_data[plate_effect_boxplot_targets[i],], na.rm=TRUE)
          ymax <- ymax + 0.2*(ymax - ymin)
          b <- boxplot(plate_test_data[plate_effect_boxplot_targets[i],] ~ sample_metadata$plateEffectID + sample_metadata[,params$sampleGroupCovar],
                       ylab = '', xlab = '', las=3, yaxt='n', ylim=c(ymin, ymax),
                       main = plate_effect_boxplot_targets[i], cex.axis=0.5,
                       col=plate_effect_boxplot_colors)
          axis(side=2, las=1, cex.axis=0.75)
          mtext("NPQ", side=2, line=1.5, cex=0.75)
          grid()
          sig_plates <- pairwise_sig_plates[[plate_effect_boxplot_targets[i]]]
          if(length(sig_plates) > 0){
            plot_plate_names <- sapply(strsplit(b$names, '\\.'), function(x) x[1])
            points(which(plot_plate_names %in% sig_plates), rep(ymax, length(which(plot_plate_names %in% sig_plates))), pch=8, col='darkred', cex=2, lwd=1.5)
          }
        } else if(is.null(params$sampleGroupCovar)){
          par(mar=c(8,2.5,2,0.5))
          ymin <- min(plate_test_data[plate_effect_boxplot_targets[i],], na.rm=TRUE)
          ymax <- max(plate_test_data[plate_effect_boxplot_targets[i],], na.rm=TRUE)
          ymax <- ymax + 0.2*(ymax - ymin)
          b <- boxplot(plate_test_data[plate_effect_boxplot_targets[i],] ~ sample_metadata$plateEffectID,
                       ylab = '', xlab = '', las=3, yaxt='n', ylim=c(ymin, ymax),
                       main = plate_effect_boxplot_targets[i], cex.axis=0.5,
                       col=plate_effect_boxplot_colors)
          axis(side=2, las=1, cex.axis=0.75)
          mtext("NPQ", side=2, line=1.5, cex=0.75)
          grid()
          sig_plates <- pairwise_sig_plates[[plate_effect_boxplot_targets[i]]]
          if(length(sig_plates) > 0){
            plot_plate_names <- sapply(strsplit(b$names, '\\.'), function(x) x[1])
            points(which(plot_plate_names %in% sig_plates), rep(ymax, length(sig_plates)), pch=8, col='darkred', cex=2, lwd=1.5)
          }
        }
      }
    }
  }
}
```

```{r target-mean-by-plate-heatmap, eval=(params$outPlateEffect & multipleFiles & params$reportType != "webApp" & numFiles >= 3), results='asis', out.width='100%', fig.asp=3, fig.align = 'center', warning=FALSE}
if(multipleFiles){
  cat("### Target means by run heatmap\n\n")
  cat("Sample mean NPQ for each target is shown run in the heatmap. Target values are centered and scaled. Control samples were excluded from mean calculations.\n\n")
  # center and scale NPQ data
  mat_scaled <- t(scale(target_means))
  # Define color scale for NPQ
  col_fun <- circlize::colorRamp2(c(-4, -2, 0, 2, 4), # Adjust depending on the range of your scaled data
                                  rev(RColorBrewer::brewer.pal(n = 5, name = "RdBu")))
  
  # create row annotations
  row_annotation <- plate_effect_target_table[,c("target","Fstat","n sig pairwise","ICC plate","n plates low IPC","n plates low sample reads")]
  row_annotation$Fstat <- as.numeric(row_annotation$Fstat)
  row_annotation$`ICC plate` <- as.numeric(row_annotation$`ICC plate`)
  row_annotation$`QC warning` <- as.numeric(row_annotation$`n sig pairwise` > 0 & row_annotation$`ICC plate` > params$plate_effect_icc_threshold)
  rownames(row_annotation) <- row_annotation$target
  row_annotation <- row_annotation[,c("QC warning","Fstat","n sig pairwise","ICC plate","n plates low IPC","n plates low sample reads")]
  row_annotation <- row_annotation[colnames(target_means),]
  
  rownames(row_annotation) <- colnames(target_means)
  row_anno <- ComplexHeatmap::rowAnnotation(
    df = row_annotation,
    annotation_legend_param = list(
      direction = "horizontal"),
    annotation_name_gp = gpar(fontsize = 6))
  
  # draw heatmap
  if(!is.null(params$assayRunInfo)) {
    column_annotation <- data.frame(instrument=factor(instruments))
    top_anno <- ComplexHeatmap::HeatmapAnnotation(
      df = column_annotation, 
      annotation_legend_param = list(
        direction = "horizontal"))
    
    ht <- ComplexHeatmap::Heatmap(
      mat_scaled,
      name = "NPQ z-score", # Legend title
      col = col_fun,
      cluster_rows = TRUE,
      cluster_columns = TRUE,
      show_row_names = TRUE,
      show_column_names = TRUE,
      row_names_gp = gpar(fontsize = 5),
      top_annotation = top_anno,
      right_annotation = row_anno,
      heatmap_legend_param = list(direction = "horizontal"), # for bottom legend
      column_title = NULL  # Equivalent to main = '' in pheatmap
    )
    
    ComplexHeatmap::draw(ht,
                         heatmap_legend_side = "bottom",
                         annotation_legend_side = "bottom")
    
  } else {
    
    ht <- ComplexHeatmap::Heatmap(
      mat_scaled,
      name = "NPQ z-score", # Legend title
      col = col_fun,
      cluster_rows = TRUE,
      cluster_columns = TRUE,
      show_row_names = TRUE,
      show_column_names = TRUE,
      row_names_gp = gpar(fontsize = 5),
      right_annotation = row_anno,
      heatmap_legend_param = list(direction = "horizontal"), # for bottom legend
      column_title = NULL  # Equivalent to main = '' in pheatmap
    )
    
    ComplexHeatmap::draw(ht,
                         heatmap_legend_side = "bottom",
                         annotation_legend_side = "bottom")
  }
}

```

```{r save-target-mean-by-plate-heatmap, eval=(params$outPlateEffect & multipleFiles & params$reportType=="internal" & numFiles >= 3), warning=FALSE, include=FALSE}
if(multipleFiles & params$reportType != "webApp"){
  # Target means by plate heatmap pdf
  plot_width <- (nrow(target_means) / 4.5) + 6
  plot_height <- (ncol(target_means) / 10) + 3
  
  pdf(file = paste0(params$outfolder, "outputFiles/target_means_by_plate_heatmap.pdf"),
      width=plot_width, height=plot_height)
  ComplexHeatmap::draw(ht,
                       heatmap_legend_side = "bottom",
                       annotation_legend_side = "bottom",
                       column_title = "Sample Mean NPQ by Plate and Target",
                       column_title_gp = gpar(fontsize = 14, fontface = "bold"))
  
  dev.off()
}
```

```{r pca-by-plate, eval=(params$outPlateEffect & multipleFiles & numFiles >= 3), results='asis', out.width='70%', fig.asp=1, fig.align = 'center', warning=FALSE}
if(multipleFiles & numFiles >= 3){
  cat("### PCA by run\n\n")
  if(params$reportType != "webApp"){
    cat("PCA was performed on the sample mean by target and run matrix shown in the heatmap above.\n\n")
  } else {
    cat("PCA was performed on the sample mean by target and run matrix.\n\n")
  }
  par(xpd=TRUE)
  stats::biplot(target_mean_pca, var.axes=FALSE, cex=c(1, 0.0001), main='PCA of target means by run')
  par(xpd=FALSE)
}
```

```{r plate-effect-sample-PCA, eval=(params$outPlateEffect & multipleFiles & params$reportType != "webApp"), results='asis', out.width='100%', fig.asp=1, fig.align = 'center', warning=FALSE, message=FALSE}
if(multipleFiles){
  cat("\n\n---\n\n")
  cat("### Sample PCA\n\n")
  cat("PCA shown below was performed on the samples only, excluding any control samples. Samples are colored according to run.\n\n")

  cat("#### Pairs plots\n\n")
  cat("Pairs plots show the first 10 PCs plotted against each other. Any clustering by run in the plots indicates potential batch effect(s).\n\n")
  
  metavars <- colnames(sample_metadata)[colnames(sample_metadata) %in% c("SAMPLE_MATRIX", "plateEffectID", "instEffectID", unique_plateEffectID, instrument_names)]
  
  sample_PCA <- PCAtools::pca(mat=t(scale(t(plate_test_data))), metadata = sample_metadata[,metavars])
  
  PCAtools::pairsplot(sample_PCA,
                    components = PCAtools::getComponents(sample_PCA, c(1:10)),
                    triangle = TRUE, trianglelabSize = 12,
                    hline = 0, vline = 0,
                    pointSize = 0.4,
                    gridlines.major = FALSE, gridlines.minor = FALSE,
                    colby = 'plateEffectID',
                    title = NULL, plotaxes = FALSE,
                    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'),
                    ellipse = TRUE, 
                    ellipseType = 't',
                    ellipseAlpha = 0.15,
                    ellipseFill = TRUE,
                    ellipseLineSize = 0)
}
```

```{r plate-effect-sample-PCA-legend, eval=(params$outPlateEffect & multipleFiles & params$reportType != "webApp"), results='asis', out.width='100%', fig.asp=eval(ceiling(length(PlateNames) / 5) * 0.1), fig.align = 'center', warning=FALSE, message=FALSE}
if(multipleFiles){
  # plot PCA legend
  PCA_legend <- PCAtools::biplot(sample_PCA, legendPosition = 'top', legendLabSize = 10, legendTitleSize = 10, legendIconSize = 5, colby='plateEffectID')
  PCA_legend <- ggpubr::get_legend(PCA_legend)
  ggpubr::as_ggplot(PCA_legend)
}
```

```{r plate-effect-sample-PCA-eigencorplot-fig-setup-initial, include=FALSE}
fig_height <- 1
```

```{r plate-effect-sample-PCA-eigencorplot-fig-setup, eval=(params$outPlateEffect & multipleFiles & params$reportType != "webApp"), results='asis', fig.align = 'center', warning=FALSE, message=FALSE}
fig_height <- 1
if(params$outPlateEffect & multipleFiles){
  include_sample_matrix <- length(unique(sample_metadata[params$sampleGroupCovar])) > 1
  if(!include_sample_matrix) {
    metavars <- c(unique_plateEffectID)
  } else {
    metavars <- c(params$sampleGroupCovar, unique_plateEffectID)
  }
  if(!is.null(params$assayRunInfo)){
    if(do_inst_effect_test){
      metavars <- c(metavars, instrument_names)
    }
  }
  fig_height <- length(metavars) / 3 + 1
}
```

```{r plate-effect-sample-PCA-eigencorplot, eval=(params$outPlateEffect & multipleFiles & params$reportType != "webApp"), results='asis', fig.height=fig_height, out.width='100%', fig.width=10, fig.align = 'center', warning=FALSE, message=FALSE}
if(params$outPlateEffect & multipleFiles){
  cat("#### PC correlations with metadata\n\n")
  cat("Sample metadata variables including run and sample matrix, if provided, were correlated against the principal component scores for the first 10 PCs. P-values are adjusted using the Bonferroni correction. Significance scale for adjusted p-values: * < 0.05, ** < 0.01, *** < 0.001.\n\n")
  
  PCAtools::eigencorplot(sample_PCA, metavars = metavars, 
                         cexCorval = 1, cexLabY = 1,
                         col = c("darkblue", "blue1","lightblue", "white", "pink", "red1", "darkred"),
                         corMultipleTestCorrection = 'bonferroni', scale=FALSE)
}
```

```{r save-plate-effect-test-result, eval=(params$outPlateEffect & multipleFiles & params$outputPlateEffectCSV==TRUE), include=FALSE}
if(multipleFiles & params$reportType != "webApp"){
  # make directory -- we will put the file in the outputFiles directory
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
  
  # Batch effect test -- output CSV file
  write.csv(plate_effect_target_table, paste0(params$outfolder, "outputFiles/target_plate_effect_table.csv"))
  # output batch effect qs2 file
  # do sample PCA plate test
  sample_PCA <- PCAtools::pca(mat=t(scale(t(plate_test_data))), metadata = sample_metadata[,unique_plateEffectID])
  sample_PCA_eigencor <- suppressWarnings(PCAtools::eigencorplot(sample_PCA, metavars = unique_plateEffectID, returnPlot = FALSE))
  sample_PCA_eigencor_corvals <- environment(sample_PCA_eigencor[["panel"]])$corvals
  sample_PCA_eigencor_pvals <- environment(sample_PCA_eigencor[["panel"]])$pvals
  qs2::qs_savem(sample_PCA, sample_PCA_eigencor_corvals, sample_PCA_eigencor_pvals,
                file=file.path(paste0(params$outfolder, "outputFiles"), "batch_effect_test.qs2"))
}
```

```{r inst-effect-test-samples-table, eval=(params$outPlateEffect & multipleFiles & !is.null(params$assayRunInfo)), results='asis', out.width='75%', fig.asp=1, fig.align = 'center', warning=FALSE}
if(multipleFiles & !is.null(params$assayRunInfo)){
  if(do_inst_effect_test){
    cat("\n\n---\n\n")
    cat("## Instrument effect tests\n\n")
    cat("### Instrument effect ANOVA test\n\n")
    cat("Instrument effect test is based on a linear model with instrument as a categorical variable (equivalent to an ANOVA model). Models are adjusted by the sample group covariate (sampleGroupCovar parameter), if defined. Instrument effect test assumes that all other variation is technical in nature. Significant instrument effect may be due to biological variation if samples were not randomized and / or if biological groups are not balanced across the instruments (after adjusting for covariate, if specified).\n\n")
    cat(paste0("Instrument effect ANOVA test significance threshold was set at p < ", params$plate_effect_pval_ANOVA, "."), "\n\n")

    if(!is.null(model_fit_message_inst)){
      cat(model_fit_message_inst, "\n\n")
    }

    cat("#### Samples per instrument table\n\n")

    render_table(inst_effect_results[[1]]$n_samples_table,
                 table_name = 'Number of samples per instrument',
                 table_id = paste0("id=\"n-samples-per-inst", "\""),
                 rownames = FALSE)

    if(nrow(samples_omitted) > 0){
      cat("#### Samples omitted from instrument effect test table\n\n")

      cat("The following samples were omitted from instrument effect test due to their sample metadata name not matching a NPQ data matrix column name.\n\n")
      
      render_table(samples_omitted, 
                   table_name = 'Samples omitted from instrument effect test', 
                   table_id = paste0("id=\"inst-effect-test-samples-omitted", "\""),
                   rownames = FALSE)
    }
  }
}
```

```{r inst-effect-test-volcano-plot, eval=(params$outPlateEffect & multipleFiles & !is.null(params$assayRunInfo)), results='asis', out.width='75%', fig.asp=1, fig.align = 'center', warning=FALSE}
if(multipleFiles){
  if(do_inst_effect_test){
    cat("#### Instrument effect ANOVA volcano plot\n\n")

    if(length(inst_effect_results[[1]]$remove_targets) > 0){
      cat(paste0("NOTE: The following targets were removed from instrument effect test due to zero variance: ", paste(inst_effect_results[[1]]$remove_targets, collapse=", ")), "\n\n")
    }

    n_significant_Ftest_inst <- sum(inst_effect_results[[1]]$inst_test_lm$Fstats$Ftest_pval[!is.na(inst_effect_results[[1]]$inst_test_lm$Fstats$Ftest_pval)] < params$plate_effect_pval_ANOVA)
    if(n_significant_Ftest_inst == 0){
      cat(paste0("There were no targets with significant (unadjusted p < ", params$plate_effect_pval_ANOVA, ") ANOVA test instrument effects."), "\n\n")
    } else if(n_significant_Ftest_inst > 0){
      cat(paste0(n_significant_Ftest_inst, " targets showed significant ANOVA test instrument effects (unadjusted p < ", params$plate_effect_pval_ANOVA, ")."), "\n\n")
    }
    suppressWarnings(inst_effect_results[[1]]$Ftest_volcano)
  }
}
```

```{r save-inst-effect-test-result, eval=(params$outPlateEffect & multipleFiles & params$outputPlateEffectCSV==TRUE & params$reportType=="internal" & !is.null(params$assayRunInfo)), include=FALSE}
if(multipleFiles & params$reportType != "webApp"){
  if(do_inst_effect_test){
    # make directory -- we will put the file in the outputFiles directory
    dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
    
    # Batch effect test -- output CSV file
    write.csv(inst_effect_results[[1]]$target_table, paste0(params$outfolder, "outputFiles/target_inst_effect_table.csv"))
  }
}
```

```{r generate-pdf-plots, include=FALSE, eval=params$outputPlots==TRUE}
if(params$reportType != "webApp"){
  # create directory for outputFiles
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
}

##########################
# IC median QC plot
##########################
for(i in 1:numFiles){
  # sort in order: samples, IPC, SC, Bridge, NC
  sampleType_factor <- factor(runs[[i]]$sample$sampleType,
                              levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  well_order <- wellorder(runs[[i]]$samples, 
                          sampleTypeFactor=sampleType_factor)
  # do sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, runs[[i]]$lod$aboveLOD, runs[[i]]$samples, runs[[i]]$targets, well_order, TAP=params$reportType=="internal", QCS=runs[[i]]$QCS, SN=runs[[i]]$SN)
  # define sample types
  if(indicatorSC){
    inds <- which(grepl(paste(runs[[i]]$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(runs[[i]]$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }
  # values
  inds <- which(qcSample$flagName == 'IC_Median')
  xval <- as.numeric(qcSample[inds, ]$val)*100
  # replace values < -100 or > 100 
  xval[xval < -100] <- -100
  xval[xval > 100] <- 100
  # define labels
  labels <- qcSample[inds, ]$sampleName
  # define colors
  label_colors <- unlist(lapply(alamarColorPalette(n=5, nReps=5), function(x) x[2]))
  color <- rep("black", length(inds))
  color[which(qcSample[inds,]$sampleType == "IPC")] <- label_colors[2]
  color[which(qcSample[inds,]$sampleType == "NC")] <- label_colors[3]
  if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
    color[which(qcSample[inds,]$sampleType == "SC")] <- label_colors[4]
  }
  if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
    color[which(qcSample[inds,]$sampleType == "Bridge")] <- label_colors[5]
  }
  # make plot
  if(params$reportType != "webApp"){
    pdf(paste0(params$outfolder, "outputFiles/sample_QC_IC_median_", PlateNames[i], '.pdf'), width=12, height=4)
    par(mfcol=c(1, 1), mar=c(5,4,2,0.5))
    plot(x=1:length(xval),
         y=rev(as.numeric(xval)), 
         ylab="% of Internal Control Median", 
         xlab='',
         xaxt='n', 
         las=1, 
         cex=0.7, ylim=c(-100, 100), 
         col='white',
         main=paste0(PlateNames[i], ' Sample QC: Internal Control Median'))
    # need to loop over labels and color individuals
    axis(side=1, at=1:length(xval), labels=FALSE, tck=-0.01)
    for (k in 1:length(xval)){
      text(x=k, y=par('usr')[3] - 4, 
           labels=rev(labels)[k], xpd=NA, col=rev(color)[k],
           srt=45, adj=1,
           cex=0.45)
    }
    abline(v=1:length(xval), col='lightgray', lty='dotted')
    # color points green if PASS, red if FAIL
    xvalFail <- xval
    xvalFail[which(qcSample[inds,]$status != TRUE)] <- NA
    xvalPass <- xval
    xvalPass[which(qcSample[inds,]$status != FALSE)] <- NA
    points(1:length(xvalPass), rev(as.numeric(xvalPass)), pch=19, col="green", cex=0.75)
    points(1:length(xvalFail), rev(as.numeric(xvalFail)), pch=19, col="red", cex=0.75)
    abline(h=-40, col='gray41')
    abline(h=40, col='gray41')
    abline(h=0, col='gray41', lty=2)
    legend('bottomright', legend=c('Pass', "Warning"), col=c('green', 'red'), 
           pch=19, cex=0.75, bty='n', inset=c(0,1), xpd=T,horiz=T)
    dev.off()
  }
}

##########################
# intra-plate and inter-plate CV histograms
##########################
# intra-plate CV 
if(params$reportType != "webApp"){
  pdf(paste0(params$outfolder, "outputFiles/intraCV_histogram.pdf"), 
      width=5, height=5)
  colors <- alamarColorPalette(2, nReps = 5, palette = 2)
  par(mar=c(4.5, 4.5, 2, 1))
  if(indicatorSC==TRUE){
    intraCV_mean <- SC_intraCV_IC[,ncol(SC_intraCV_IC)]
  } else {
    intraCV_mean <- IPC_intraCV_IC[,ncol(IPC_intraCV_IC)]
  }
  if(!all(is.na(intraCV_mean))){
    hist(intraCV_mean,
         main='Intra-plate CV (%)',
         xlab='CV (%)', las=1, breaks=50,
         col=colors[[1]][5],
         border=colors[[1]][2])
    abline(v=mean(intraCV_mean, na.rm=TRUE), col=colors[[2]][3], lwd=2)
    abline(v=median(intraCV_mean, na.rm=TRUE), col=colors[[2]][3], lty=2, lwd=2)
    legend('topright', c(paste0('mean CV% = ', format(round(mean(intraCV_mean, na.rm=TRUE), 1), nsmall=1)), 
                         paste0('median CV% = ', format(round(median(intraCV_mean, na.rm=TRUE), 1), nsmall=1))),
           lty=c(1,2), col=colors[[2]][3], bty='n', lwd=2, cex=1.25)
  }
  dev.off()
}

# inter-plate CV
if(multipleFiles==TRUE){
  if(params$reportType != "webApp"){
    pdf(paste0(params$outfolder, "outputFiles/interCV_histogram.pdf"), 
        width=5, height=5)
    colors <- alamarColorPalette(2, nReps = 5, palette = 2)
    par(mar=c(4.5, 4.5, 2, 1))
    if(indicatorSC==TRUE){
      interCV <- interCV_IC_IPC[,'SC']
    } else {
      interCV <- interCV_IC_IPC[,'IPC']
    }
    hist(interCV,
         main='Inter-plate CV (%)',
         xlab='CV (%)', las=1, breaks=50,
         col=colors[[1]][5],
         border=colors[[1]][2])
    abline(v=mean(interCV, na.rm=TRUE), col=colors[[2]][3], lwd=2)
    abline(v=median(interCV, na.rm=TRUE), col=colors[[2]][3], lty=2, lwd=2)
    legend('topright', c(paste0('mean CV% = ', format(round(mean(interCV, na.rm=TRUE), 1), nsmall=1)), 
                         paste0('median CV% = ', format(round(median(interCV, na.rm=TRUE), 1), nsmall=1))),
           lty=c(1,2), col=colors[[2]][3], bty='n', lwd=2, cex=1.25)
    dev.off()
  }
}

##########################
# target detectability histograms
##########################
if(multipleFiles==FALSE & is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table
  detectability_data_name <- colnames(detect_output_table)
  # make histogram
  if(params$reportType != "webApp"){
    pdf(paste0(params$outfolder, "outputFiles/target_detectability_histogram.pdf"),
        width=5, height=5)
    par(mar=c(4.5, 4.5, 2, 1))
    hist(detectability_data,
         main=paste0('Target detectability (%):\n', detectability_data_name),
         xlab='Detectability (%)', las=1, breaks=50, 
         col=colors[[1]][5],
         border=colors[[1]][2],
         xlim=c(0, 100))
    abline(v=50, col=colors[[2]][3], lwd=1)
    ydist <- par('usr')[4] - par('usr')[3]
    text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
         col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
    legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data, na.rm=TRUE), 1), nsmall=1)),
                        paste0('median = ', format(round(median(detectability_data, na.rm=TRUE), 1), nsmall=1))),
           bty='n', cex=1)
    dev.off()
  }
}

if(multipleFiles==FALSE & !is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table
  if(nrow(detectability_return_summary[[1]]) > 1){
    sample_groups <- detectability_return_summary[[1]][2:nrow(detectability_return_summary[[1]]),1]
  } else {
    sample_groups <- detectability_return_summary[[1]][1,1]
  }
  sample_groups <- gsub(' ', replacement = '_', sample_groups)
  # if detectability_data is a vector, make into a data.frame
  if(is.null(dim(detectability_data))){
    detectability_data <- data.frame(detectability_data)
    colnames(detectability_data) <- sample_groups[1]
  } 
  colnames(detectability_data) <- paste0('Target detectability (%):\n', colnames(detectability_data))
  if(params$reportType != "webApp"){
    filenames <- paste0(params$outfolder, "outputFiles/target_detectability_histogram_", sample_groups, '.pdf')
    # make histogram for each sample type
    for (i in 1:ncol(detectability_data)){
      pdf(filenames[i],
          width=5, height=5)
      par(mar=c(4.5, 4.5, 2, 1))
      hist(detectability_data[,i],
           main=colnames(detectability_data)[i],
           xlab='Detectability (%)', las=1, breaks=50, 
           col=colors[[1]][5],
           border=colors[[1]][2],
           xlim=c(0, 100))
      abline(v=50, col=colors[[2]][3], lwd=1)
      ydist <- par('usr')[4] - par('usr')[3]
      text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
           col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
      legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data[,i], na.rm=TRUE), 1), nsmall=1)),
                          paste0('median = ', format(round(median(detectability_data[,i], na.rm=TRUE), 1), nsmall=1))),
             bty='n', cex=1)
      dev.off()
    }
  }
}

if(multipleFiles==TRUE & is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table[,grep('Overall', colnames(detect_output_table))]
  detectability_data_name <- colnames(detect_output_table)[grep('Overall', colnames(detect_output_table))]
  # make histogram
  if(params$reportType != "webApp"){
    pdf(paste0(params$outfolder, "outputFiles/target_detectability_histogram.pdf"),
        width=5, height=5)
    par(mar=c(4.5, 4.5, 2, 1))
    hist(detectability_data,
         main=paste0('Target detectability (%):\n', detectability_data_name),
         xlab='Detectability (%)', las=1, breaks=50, 
         col=colors[[1]][5],
         border=colors[[1]][2],
         xlim=c(0, 100))
    abline(v=50, col=colors[[2]][3], lwd=1)
    ydist <- par('usr')[4] - par('usr')[3]
    text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
         col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
    legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data, na.rm=TRUE), 1), nsmall=1)),
                        paste0('median = ', format(round(median(detectability_data, na.rm=TRUE), 1), nsmall=1))),
           bty='n', cex=1)
    dev.off()
  }
}

if(multipleFiles==TRUE & !is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- as.matrix(detect_output_table[,grep('Overall', colnames(detect_output_table))])
  if(nrow(detectability_return_summary$Overall) > 1){
    sample_groups <- detectability_return_summary$Overall[2:nrow(detectability_return_summary$Overall),1]
  } else {
    sample_groups <- detectability_return_summary$Overall[1,1]
  }
  sample_groups <- gsub(' ', replacement = '_', sample_groups)
  colnames(detectability_data) <- gsub('Overall: ', replacement = 'Target detectability (%):\n', colnames(detectability_data))
  if(params$reportType != "webApp"){ 
    filenames <- paste0(params$outfolder, "outputFiles/target_detectability_histogram_", sample_groups, '.pdf')
    # make histogram for each sample type
    for (i in 1:ncol(detectability_data)){
      pdf(filenames[i],
          width=5, height=5)
      par(mar=c(4.5, 4.5, 2, 1))
      hist(detectability_data[,i],
           main=colnames(detectability_data)[i],
           xlab='Detectability (%)', las=1, breaks=50, 
           col=colors[[1]][5],
           border=colors[[1]][2],
           xlim=c(0, 100))
      abline(v=50, col=colors[[2]][3], lwd=1)
      ydist <- par('usr')[4] - par('usr')[3]
      text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
           col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
      legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data[,i], na.rm=TRUE), 1), nsmall=1)),
                          paste0('median = ', format(round(median(detectability_data[,i], na.rm=TRUE), 1), nsmall=1))),
             bty='n', cex=1)
      dev.off()
    }
  }
}

##########################
# target detectability boxplot -- by plate
##########################
if(params$reportType != "webApp"){
  for(i in 1:numFiles){
    # Exclude IC + hidden targets + noDetectability targets
    pdf_boxplot_exclude_targets <- c(runs[[i]]$IC,
                                     runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)],
                                     runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)])
    pdf(paste0(params$outfolder, 'outputFiles/target_detectability_boxplot_', PlateNames[i], '.pdf'), width=20, height=7)
    targetBoxplot(IC_IPC$interNormData[[i]],
                  title=paste0('Target detectability: ', PlateNames[i]),
                  subtractLOD = TRUE,
                  blanks = runs[[i]]$NC,
                  targetNoOutlierDetection = targetNoOutlierDetection[[i]],
                  horizontal = FALSE,
                  replace_zero_LOD=FALSE,
                  axis_lab_normalized=TRUE,
                  excludeTargets=pdf_boxplot_exclude_targets,
                  excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC),
                  match_matrix=runs[[i]]$match_matrix,
                  targets=runs[[i]]$targets)
    dev.off()
  }
}
##########################
# target detectability boxplot -- combine across plates
# if no sample group specified and more than one plate, combine all data
##########################
if(is.null(params$sampleGroupCovar) & numFiles > 1){
  # calculate LODs on IC - IPC normalized data
  plate_lod_IPC <- vector('list', length(params$xmlFiles))
  for (i in 1:numFiles){
    plate_lod_IPC[[i]] <- lod(data_matrix=IC_IPC$interNormData[[i]], 
                              blanks=runs[[i]]$NC, 
                              targetNoOutlierDetection = targetNoOutlierDetection[[i]],
                              min_count=0,
                              match_matrix=runs[[i]]$match_matrix)
    plate_lod_IPC[[i]]$LOD_log2 <- log2(plate_lod_IPC[[i]]$LOD + 1)
  }
  # subtract LODs from the IC - IPC normalized sample data
  data_minus_LOD <- vector('list', length(params$xmlFiles))
  for (i in 1:length(params$xmlFiles)){
    plate_i_sample_data <- IC_IPC$log2_interNormData[[i]][,runs[[i]]$SampleNames]
    # add plate ID to colnames in case any names are identical across plates
    colnames(plate_i_sample_data) <- paste0('plate_', i, '_', colnames(plate_i_sample_data))
    data_minus_LOD[[i]] <- sweep(plate_i_sample_data, MARGIN=1, STATS=plate_lod_IPC[[i]]$LOD_log2)
    # Exclude IC + hidden targets + noDetectability targets
    combined_exclude_targets <- c(runs[[i]]$IC,
                                  runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)],
                                  runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)])
    data_minus_LOD[[i]] <- data_minus_LOD[[i]][!rownames(data_minus_LOD[[i]]) %in% combined_exclude_targets,]
  }
  data_minus_LOD <- combineCols(data_minus_LOD)

  # sort targets
  target_medians <- apply(data_minus_LOD, 1, median)
  target_medians <- target_medians[order(target_medians, decreasing=TRUE)]
  data_minus_LOD <- data_minus_LOD[names(target_medians),]
  # calculate detectability
  detect <- apply(data_minus_LOD, 1, function(x) sum(x > 0)) / ncol(data_minus_LOD) * 100
  # create colors to indicate detectability
  makeColors <- colorRamp(colors=c('blue', 'pink'))
  detectCleaned <- detect[which(!is.na(detect))]
  detectColors <- makeColors(detectCleaned/100)
  detectColors <- apply(detectColors, 1, 
                        function(x) rgb(x[1], x[2], x[3], maxColorValue=255))
  
  if(params$reportType != "webApp"){
    pdf(paste0(params$outfolder, "outputFiles/target_detectability_boxplot_all_plates.pdf"), width=20, height=7)
    # make plot
    par(mar=c(4,3,2,0.5), mgp=c(2,1,0))
    boxplot(t(data_minus_LOD),
            horizontal=FALSE,
            xlab='',
            ylab='NPQ - LOD',
            main='Target detectability: All plates',
            las=3, 
            lty=1,
            pch=16, 
            cex=0.5,
            staplelty=0,
            cex.axis=0.4,
            yaxt='n',
            col=detectColors)
    axis(side=2, las=1)
    grid(nx=NA, ny=NULL)
    abline(h=0, col='darkred')
    
    # make legend
    # add color gradient legend
    # define coordinates
    axis_limits <- par('usr')
    x_axis_length <- axis_limits[2] - axis_limits[1]
    y_axis_length <- axis_limits[4] - axis_limits[3]
    legend_length <- x_axis_length/6
    legend_right <- axis_limits[2] - x_axis_length/20
    legend_left <- legend_right - legend_length
    legend_height <- y_axis_length/20
    legend_top <- axis_limits[4] - y_axis_length/10
    legend_bottom <- legend_top - legend_height
    # create color gradient
    colfunc <- colorRampPalette(c('blue', 'pink'))
    legend_image <- as.raster(matrix(colfunc(20), nrow=1))
    rasterImage(legend_image, legend_left, legend_bottom, legend_right, legend_top)
    # make labels
    text(x=seq(legend_left, legend_right, l=6), 
         y = legend_bottom - y_axis_length/40,
         labels = seq(0,100,l=6), 
         cex=0.8, adj=0.5)
    text(x=(legend_left+legend_right)/2, y=legend_top,
         labels='Detectability', pos=3, cex=0.8) # end legend
    dev.off()
  }
}

##########################
# target detectability boxplot -- combine across plates, by sample group
# if sample group is specified, combine data across plates
# and make separate plots by sample type
##########################
if(!is.null(params$sampleGroupCovar)){
  # calculate LODs on IC - IPC normalized data
  plate_lod_IPC <- vector('list', length(params$xmlFiles))
  for (i in 1:length(params$xmlFiles)){
    plate_lod_IPC[[i]] <- lod(data_matrix=IC_IPC$interNormData[[i]], 
                              blanks=runs[[i]]$NC, 
                              targetNoOutlierDetection = targetNoOutlierDetection[[i]],
                              min_count=0, 
                              match_matrix=runs[[i]]$match_matrix)
    plate_lod_IPC[[i]]$LOD_log2 <- log2(plate_lod_IPC[[i]]$LOD + 1)
  }
  # subtract LODs from the IC - IPC normalized sample data
  data_minus_LOD <- vector('list', length(params$xmlFiles))
  for (i in 1:length(params$xmlFiles)){
    plate_i_sample_data <- IC_IPC$log2_interNormData[[i]]
    # add plate ID to colnames in case any names are identical across plates
    colnames(plate_i_sample_data) <- paste0('plate_', i, '_', colnames(plate_i_sample_data))
    # add plate ID - sample name to the samples data frame
    runs[[i]]$samples$plate_sampleName <- paste0('plate_', i, '_', runs[[i]]$sample$sampleName)
    data_minus_LOD[[i]] <- sweep(plate_i_sample_data, MARGIN=1, STATS=plate_lod_IPC[[i]]$LOD_log2)
    # Exclude IC + hidden targets + noDetectability targets
    samplegroup_exclude_targets <- c(runs[[i]]$IC,
                                     runs[[i]]$targets$targetName[which(runs[[i]]$targets$hide)],
                                     runs[[i]]$targets$targetName[which(runs[[i]]$targets$noDetectability)])
    data_minus_LOD[[i]] <- data_minus_LOD[[i]][!rownames(data_minus_LOD[[i]]) %in% samplegroup_exclude_targets,]
  }
  data_minus_LOD <- combineCols(data_minus_LOD) 
  
  samples_data <- lapply(runs, function(x) x$samples)
  matching_column <- Reduce(intersect, lapply(samples_data, colnames))
  samples_data <- lapply(samples_data, function(x) x[,matching_column])
  samples_data <- do.call(rbind, samples_data)
  
  # loop over sample groups
  sample_groups <- unique(samples_data[,params$sampleGroupCovar])
  # remove control sample groups
  sample_groups <- sample_groups[!(sample_groups %in% c('IPC', 'SC', 'NC'))]
  for(k in 1:length(sample_groups)){
    
    sample_group_data <- data_minus_LOD[,samples_data$plate_sampleName[samples_data[,params$sampleGroupCovar]==sample_groups[k]]]
    if(is.null(dim(sample_group_data))) next # skip if group has only one sample member
    # remove any control samples -- SC, IPC, NC
    sample_group_data <- sample_group_data[,colnames(sample_group_data) %in% samples_data$plate_sampleName[samples_data$sampleType=='Sample']]
    if(ncol(sample_group_data) == 0){
      next
    }
    if (!is.null(colnames(sample_group_data))) {
      # sort targets
      target_medians <- apply(sample_group_data, 1, median)
      target_medians <- target_medians[order(target_medians, decreasing=TRUE)]
      sample_group_data <- sample_group_data[names(target_medians),]
      # calculate detectability
      detect <- apply(sample_group_data, 1, function(x) sum(x > 0)) / ncol(sample_group_data) * 100
      # create colors to indicate detectability
      
      makeColors <- colorRamp(colors=c('blue', 'pink'))
      detectCleaned <- detect[which(!is.na(detect))]
      detectColors <- makeColors(detectCleaned/100)
      detectColors <- apply(detectColors, 1, 
                            function(x) rgb(x[1], x[2], x[3], maxColorValue=255))
      
      # define filename and plot title
      sample_group_filename <- paste0(params$outfolder, 'outputFiles/target_detectability_boxplot_all_plates_', sample_groups[k], '.pdf')
      sample_group_title <- paste0('Target detectability: All plates, ', sample_groups[k], ' (n = ', ncol(sample_group_data), ')')
      if(params$reportType != "webApp"){
        pdf(sample_group_filename, width=20, height=7)
        # make plot
        par(mar=c(4,3,2,0.5), mgp=c(2,1,0))
        boxplot(t(sample_group_data),
                horizontal=FALSE,
                xlab='',
                ylab='NPQ - LOD',
                main=sample_group_title,
                las=3, 
                lty=1,
                pch=16, 
                cex=0.5,
                staplelty=0,
                cex.axis=0.4,
                yaxt='n',
                col=detectColors)
        axis(side=2, las=1)
        grid(nx=NA, ny=NULL)
        abline(h=0, col='darkred')
        
        # make legend
        # add color gradient legend
        # define coordinates
        axis_limits <- par('usr')
        x_axis_length <- axis_limits[2] - axis_limits[1]
        y_axis_length <- axis_limits[4] - axis_limits[3]
        legend_length <- x_axis_length/6
        legend_right <- axis_limits[2] - x_axis_length/20
        legend_left <- legend_right - legend_length
        legend_height <- y_axis_length/20
        legend_top <- axis_limits[4] - y_axis_length/10
        legend_bottom <- legend_top - legend_height
        # create color gradient
        colfunc <- colorRampPalette(c('blue', 'pink'))
        legend_image <- as.raster(matrix(colfunc(20), nrow=1))
        rasterImage(legend_image, legend_left, legend_bottom, legend_right, legend_top)
        # make labels
        text(x=seq(legend_left, legend_right, l=6), 
             y = legend_bottom - y_axis_length/40,
             labels = seq(0,100,l=6), 
             cex=0.8, adj=0.5)
        text(x=(legend_left+legend_right)/2, y=legend_top,
             labels='Detectability', pos=3, cex=0.8) # end legend
        dev.off()
      }
    }
  }
}

##########################
# AQ only
##########################

if(AbsData==TRUE & params$reportType != "webApp"){
  # 1.target QC plot
  pdf(paste0(params$outfolder, "outputFiles/targetQC.pdf"), width=14, height=4)
  targetQCplot(runs)
  dev.off()
  
  # 2. quantifiability histograms
  quant <- tryCatch(
    quant <- quantifiability(runs),
    error = function(e) NULL
  )
  
  if(!is.null(quant)){
    subgroups <- colnames(quant$combined_quantifiability$quant)
    quant_hist_filenames <- paste0('target_quantifiability_histogram_', subgroups, '.pdf') 
    
    for(i in 1:length(subgroups)){
      pdf(paste0(params$outfolder, 'outputFiles/', quant_hist_filenames[i]), width=5, height=5)
      quantHist(quantifiability_data = quant$combined_quantifiability,
                group_name = subgroups[i])
      dev.off()
    }
  }
  
  # 3. intra and inter CV histograms
  AQ_CV <- CV_AQ(runs)
  
  pdf(paste0(params$outfolder, "outputFiles/AQ_intraCV_histogram.pdf"), width=5, height=5)
  CV_AQ_Hist(CV_data = AQ_CV$average_intraCV$intraCV$SC, plot_type='intra')
  dev.off()
  
  if(multipleFiles){
    pdf(paste0(params$outfolder, "outputFiles/AQ_interCV_histogram.pdf"), width=5, height=5)
    CV_AQ_Hist(CV_data = AQ_CV$interCV$interCV$SC, plot_type='inter')
    dev.off()
  }
}

```

```{r save-RData-file, include=FALSE, eval=params$outputRData==TRUE}
# Save R Data file
# Rename the param variable to avoid conflict when reading multiple qs2 files
if(params$reportType != "webApp"){
  dir.create(paste0(params$outfolder, "outputFiles"), recursive = T)
  input_params <- params
  qs2::qs_save(as.list(environment(), all.names = TRUE),
               file=paste0(params$outfolder, "outputFiles/NULISAseq_QC_report.qs2")
  )
  rm(params)
}
```

```{r delete-temp-files, include=FALSE}

if(fs::is_dir(tempDir)){
  unlink(c(
    paste0(tempDir, "/outSamples.txt"),
    paste0(tempDir, "/outTargets.txt"), 
    paste0(tempDir, "/outRunSummary.txt"), 
    paste0(tempDir, "/outCounts.txt"), 
    paste0(tempDir, "/outCounts_ICnormed.txt")))
}
if(dir.exists(Sys.getenv("TMPDIR"))){
  unlink(Sys.getenv("TMPDIR"), recursive=TRUE)
}

# Plan cleanup. Return future to its original setting 
if (!is.null(.original_future_plan)) {
  future::plan(.original_future_plan)
}
```
