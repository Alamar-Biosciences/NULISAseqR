---
params:
  IC: !r c("mCherry")
  IPC: !r c("IPC")
  NC: !r c("NC")
  Bridge: !r NULL
  SC: !r c("IPC")
  dataDir: "/Users/jbeer/github/TAP-COVID/data"
  rowAnnotName: "Annot2"
  colAnnotName: "Annot3"
  plateAnnotName: "Annot1"
  heatMapRel: !r TRUE
  study_name: "Study Name"
  assayName: "NULISAseq 200-plex Inflammation Panel"
  sample_desc: "This is a sample description."
  goal_desc: "NULISAseq 200-plex Inflammation Panel"
  xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml","20230109_TAP_covid_plate02_nononmatch_XML.xml")
  plateNames: !r c()
output:
  html_document:
    toc: yes
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
library(gdata)
library(dplyr)
```

```{r, include=FALSE}
# function for colorizing wells in heatmap
wellorder <- function(samples, rowAnnotName, colAnnotName){
  cmd <- paste0("samples$", colAnnotName)
  cols <- eval(parse(text=cmd))
  cols <- formatC(as.numeric(cols), width=2, flag=0)
  cmd <- paste0("samples$", rowAnnotName)
  inds <- sort(paste0(eval(parse(text=cmd)), cols), index.return=TRUE)
  return(inds$ix)
}

# function to convert data into matrix for plate layout and heatmap
matrixify <- function(runSamples, rowAnnotName, colAnnotName, plate=FALSE){
  val <- matrix(rep(NA, 96), nrow=8)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  for(j in LETTERS[1:8]){
    for(k in 1:12){
      sample_jk <- runSamples$sampleName[runSamples[rowAnnotName]==j & runSamples[colAnnotName]==k]
      if(length(sample_jk)!=0){
        val[rownames(val)==j, colnames(val)==k] <- sample_jk
      }
      if(plate && length(sample_jk) == 0){
        val[rownames(val)==j, colnames(val)==k] <- ""
      }
    }
  }
  return(val)
}
```

```{r, include=FALSE}
# define plateIDs
xmlFilePlateNames <- c()
if(length(params$plateNames) == 0){
  xmlFilePlateNames <- rep("", times=length(params$xmlFiles))
}
# set multiple file indicator
multipleFiles <- if(length(params$xmlFiles) > 1) TRUE else FALSE
# define title
title_var <- paste(params$study_name, params$assayName, sep='<br>')
# define sample specific boxplot colors for use in plots
boxplot_colors <- unlist(lapply(alamarColorPalette(n=4, tint='light', nReps=4), function(x) x[3]))
# set data directory
knitr::opts_knit$set(root.dir=params$dataDir)
# save xml file path
xmlFilesPath <- paste0(params$dataDir, "/", params$xmlFiles)
# define variables to store results
runs <- vector('list', length(params$xmlFiles))
runSummaries <- vector('list', length(params$xmlFiles))
read_summary <- NULL
PlateNames <- NULL
for(i in 1:length(params$xmlFiles)){
  # read each run
  runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=xmlFilePlateNames[i])
  # save names of IC, IPC and NC
  ICs  <- runs[[i]]$targets$targetName[which(grepl(paste(params$IC, collapse="|"),  runs[[i]]$targets$targetName))]
  IPCs <- runs[[i]]$samples$sampleName[which(grepl(paste(params$IPC, collapse="|"), runs[[i]]$samples$sampleName))]
  NCs  <- runs[[i]]$samples$sampleName[which(grepl(paste(params$NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  if(xmlFilePlateNames[i] !=""){
    IPCs <- paste0(xmlFilePlateNames[i], "_", IPCs)
    NCs  <- paste0(xmlFilePlateNames[i], "_", NCs)
  }
  # summarize each plate
  runSummaries[[i]] <- plateSummary(runs[[i]], ICs=ICs, IPCs=IPCs, NCs=NCs)
  read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
  # create plate names
  PlateNames <- c(PlateNames, paste("Plate", i, sep=" "))
  if (xmlFilePlateNames[i] != ""){
    PlateNames[i] <- paste0(PlateNames[i], "(", xmlFilePlateNames[i], ")")
  }
}
names(runs) <- xmlFilePlateNames
names(runSummaries) <- xmlFilePlateNames
colnames(read_summary) <- PlateNames
# transpose read summary
read_summary <- t(read_summary)
```

```{r, include=FALSE}
# do intra-plate normalization
intraPlateNormData <- vector("list", length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  intraPlateNormData[[i]] <- vector("list", length(ICs))
  for (j in 1:length(ICs)){
    intraPlateNormData[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                                                   method="IC",
                                                   IC=ICs[j])
  }
  names(intraPlateNormData[[i]]) <- ICs
}
names(intraPlateNormData) <- xmlFilePlateNames
```

```{r, include=FALSE}
# calculate LOD on the IC normalized data
# use 1st IC as the primary IC (should be mCherry)
plate_lod <- vector('list', length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  NCs  <- runs[[i]]$samples$sampleName[which(grepl(paste(params$NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  plate_lod[[i]] <- lod(data_matrix=intraPlateNormData[[i]][[1]]$normData, blanks=NCs, min_count=0)
}
```

```{r, include=FALSE}
# do inter-plate normalization 
# save mCherry-normalized data in a list
normData <- lapply(intraPlateNormData, function(x) x[[1]]$normData)

# save IPCs, NCs, and Bridge wells for each plate
IPC_wells <- NC_wells <- Bridge_wells <- vector('list', length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  IPC_wells[[i]] <- runs[[i]]$samples$sampleName[which(grepl(paste(params$IPC, collapse="|"), runs[[i]]$samples$sampleName))]
  NC_wells[[i]]  <- runs[[i]]$samples$sampleName[which(grepl(paste(params$NC, collapse="|"), runs[[i]]$samples$sampleName))]
  if(!is.null(params$Bridge)){
    Bridge_wells[[i]] <- runs[[i]]$samples$sampleName[which(grepl(paste(params$Bridge, collapse="|"), runs[[i]]$samples$sampleName))]
  }
} 

# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')

# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                             IPC=FALSE, IN=TRUE,
                             IPC_wells=IPC_wells,
                             NC_wells=NC_wells)

# mCherry + bridge
if(!is.null(params$Bridge)){
  mCherry_bridge <- interPlateNorm(data_list=normData,
                                   IPC=FALSE, IN=TRUE,
                                   IN_samples=Bridge_wells)
}
```

```{r, include=FALSE}
# calculate intra-plate CVs using sample controls
intraCV_unnorm <- NULL
intraCV_mCherry <- NULL
for (i in 1:length(params$xmlFiles)){
  # define sample control vector
  sample_controls <- rep(NA, nrow(runs[[i]]$samples))
  sample_control_wells <- runs[[i]]$samples$sampleName[which(grepl(paste(params$SC, collapse="|"), runs[[i]]$samples$sampleName))]
  sample_controls[colnames(runs[[i]]$Data) %in% sample_control_wells] <- 'SC'
  # unnormalized intraCV
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                  samples=sample_controls,
                                  aboveLOD=plate_lod[[i]]$aboveLOD,
                                  exclude_targets=ICs)
  # combine plates into one matrix
  intraCV_unnorm <- cbind(intraCV_unnorm, plate_unnorm_intraCV) 
  # mCherry intraCV
  plate_mCherry_intraCV <- intraCV(data_matrix=intraPlateNormData[[i]]$mCherry$normData,
                                   samples=sample_controls,
                                   aboveLOD=plate_lod[[i]]$aboveLOD,
                                   exclude_targets=ICs)
  # combine plates into one matrix
  intraCV_mCherry <- cbind(intraCV_mCherry, plate_mCherry_intraCV)
}

colnames(intraCV_unnorm) <- PlateNames
colnames(intraCV_mCherry) <- PlateNames

# create intra-plate CV table -- unnormalized
intraCV_unnorm_summary_table <- cbind(colMeans(intraCV_unnorm, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, sd, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, median, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, min, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, max, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, function(x){
                                        sum(is.na(x))
                                      }))

rownames(intraCV_unnorm_summary_table) <- PlateNames
colnames(intraCV_unnorm_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')

# create intra-plate CV table -- mCherry
intraCV_mCherry_summary_table <- cbind(colMeans(intraCV_mCherry, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, sd, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, median, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, min, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, max, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, function(x){
                                         sum(is.na(x))
                                       }))

rownames(intraCV_mCherry_summary_table) <- PlateNames
colnames(intraCV_mCherry_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# calculate inter-plate CVs using sample controls
sampleControlList <- vector("list", length(params$xmlFiles))
plateData <- vector("list", length(params$xmlFiles))
aboveLOD <- vector("list", length(params$xmlFiles))
exclude_targets <- vector("list", length(params$xmlFiles))
plate_mCherry <- vector("list", length(params$xmlFiles))
for(i in 1:length(params$xmlFiles)){
  # define sample control vector
  sample_controls <- rep(NA, nrow(runs[[i]]$samples))
  sample_control_wells <- runs[[i]]$samples$sampleName[which(grepl(paste(params$SC, collapse="|"), runs[[i]]$samples$sampleName))]
  sample_controls[colnames(runs[[i]]$Data) %in% sample_control_wells] <- 'SC'
  sampleControlList[[i]] <- sample_controls
  plateData[[i]] <- runs[[i]]$Data
  plate_mCherry[[i]] <- intraPlateNormData[[i]]$mCherry$normData
  aboveLOD[[i]] <- plate_lod[[i]]$aboveLOD
  exclude_targets[[i]] <- ICs
}

# unnormalized interCV
interCV_unnorm <- interCV(data_list=plateData,
                          samples=sampleControlList,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry interCV
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=sampleControlList,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC interCV
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=sampleControlList,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN interCV
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=sampleControlList,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)

# mCherry + bridge interCV
if(!is.null(params$Bridge)){
  interCV_mCherry_bridge <- interCV(data_list=mCherry_bridge$interNormData,
                                    samples=sampleControlList,
                                    aboveLOD=aboveLOD,
                                    exclude_targets=exclude_targets,
                                    useMean=FALSE)
}

# combine results into one matrix
if(!is.null(params$Bridge)){
  interCV_results <- cbind(interCV_unnorm,
                           interCV_mCherry,
                           interCV_mCherry_IPC,
                           interCV_mCherry_IN,
                           interCV_mCherry_bridge)
  colnames(interCV_results) <- c('unnorm',
                                 'mCherry',
                                 'mCherry + IPC',
                                 'mCherry + IN',
                                 'mCherry + bridge')
} else {
  interCV_results <- cbind(interCV_unnorm,
                           interCV_mCherry,
                           interCV_mCherry_IPC,
                           interCV_mCherry_IN)
  colnames(interCV_results) <- c('unnorm',
                                 'mCherry',
                                 'mCherry + IPC',
                                 'mCherry + IN')
}

# create inter-plate CV table
interCV_summary_table <- cbind(colMeans(interCV_results, na.rm=TRUE),
                               apply(interCV_results, 2, sd, na.rm=TRUE),
                               apply(interCV_results, 2, median, na.rm=TRUE),
                               apply(interCV_results, 2, min, na.rm=TRUE),
                               apply(interCV_results, 2, max, na.rm=TRUE),
                               apply(interCV_results, 2, function(x){
                                 sum(is.na(x))
                               }))

if(!is.null(params$Bridge)){
  rownames(interCV_summary_table) <- c('unnorm',
                                       'mCherry',
                                       'mCherry + IPC',
                                       'mCherry + IN',
                                       'mCherry + bridge')
} else {
  rownames(interCV_summary_table) <- c('unnorm',
                                       'mCherry',
                                       'mCherry + IPC',
                                       'mCherry + IN')
}

colnames(interCV_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# calculate detectability
detectability_summary <- NULL
detectability_targets <- NULL
for (i in 1:length(params$xmlFiles)){
  detect_samples <- colnames(intraPlateNormData[[i]]$mCherry$normData)
  # remove IPCs, NCs, and SCs
  detect_samples <- detect_samples[!grepl(paste(params$IPC, collapse="|"), detect_samples)]
  detect_samples <- detect_samples[!grepl(paste(params$NC, collapse="|"), detect_samples)]
  detect_samples <- detect_samples[!grepl(paste(params$SC, collapse="|"), detect_samples)]
  # remove bridge samples if specified
  if(!is.null(params$Bridge)){
    detect_samples <- detect_samples[!grepl(paste(params$Bridge, collapse="|"), detect_samples)]
  }
  plate_detect <- detectability(aboveLOD_matrix=plate_lod[[i]]$aboveLOD,
                                sample_subset=detect_samples,
                                exclude_targets=ICs)
  detectability <- cbind(format(round(mean(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         format(round(sd(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         formatC(median(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(min(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(max(plate_detect$detectability, na.rm=TRUE), width=2),
                         paste0(sum(plate_detect$detectability >= 50),
                                ' (',
                                format(round(sum(plate_detect$detectability > 50)/length(plate_detect$detectability) * 100, 1), nsmall=1),
                                '%)'))
  colnames(detectability) <- c('mean',
                               'sd',
                               'median',
                               'min',
                               'max',
                               'detectable targets n (%)')
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_targets <- cbind(detectability_targets, plate_detect$detectability)
}

rownames(detectability_summary) <- PlateNames
colnames(detectability_targets) <- PlateNames
```

```{r, include=FALSE}
# log transform and scale data for clustered heatmap
data_mCherry_log2_scaled <- list()
for(i in 1:length(params$xmlFiles)){
  # remove negative controls
  data_mCherry <- intraPlateNormData[[i]]$mCherry$normData
  data_mCherry <- data_mCherry[,!grepl(paste(params$NC, collapse="|"), colnames(data_mCherry))]
  # remove ICs
  data_mCherry <- data_mCherry[!grepl(paste(params$IC, collapse="|"), rownames(data_mCherry)),]
  # log transform and scale
  data_mCherry_log2_scaled[[i]] <- t(scale(t(log2(data_mCherry+0.01)),
                                           center=TRUE, scale=TRUE))
}
```

---
title: `r title_var`
---

## Summary
* **Goal:** `r params$goal_desc`.
* Sample description: `r params$sample_desc`


---

## Plate layout
```{r, results='asis'}
for(i in 1:length(params$xmlFiles)){
  val <- matrixify(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]], Bridge_wells[[i]])
  for (j in 1:length(well_types)){
    if (j == 3 && is.null(params$Bridge)){
      next
    }
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate/Sample Layout"), 
                   align="c", escape=FALSE, table.attr=table.attr) %>%
        kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE) %>%
        column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
        row_spec(1:8, extra_css = "border-bottom: 1px solid")
  )
}
```

---

## Read summary
```{r, results='asis'}
knitr::kable(read_summary, caption='', 
             align='r', format.args=list(big.mark = ","), 
             table.attr="id=\"read-summary\"") %>% 
  kable_styling(bootstrap_options=c("striped", "hover", "condensed"), full_width=TRUE)
```

---

### Internal controls (IC)
```{r, results='asis'}
if(length(ICs) == 1){
  IC_tables <- NULL
  for (i in 1:length(params$xmlFiles)){
    IC_tables <- rbind(IC_tables, runSummaries[[i]]$IC_table)
  }
  rownames(IC_tables) <- paste0("Plate", as.character(1:length(params$xmlFiles))) 
  cat(knitr::kable(IC_tables, 
                   caption="mCherry (IC) summary", 
                   align='r', 
                   format.args=list(big.mark = ","), 
                   table.attr="id=\"IC-summary\"") %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))  
} else {
  for(i in 1:length(params$xmlFiles)){
    table.attr <- paste0("id=\"IC-summary", i, "\"")
    cat(knitr::kable(runSummaries[[i]]$IC_table, 
                     caption=paste0("Plate ", as.character(i), ": IC summary"), 
                     align='r', 
                     format.args=list(big.mark = ","), 
                     table.attr=table.attr) %>% 
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```

---

### Inter-plate control (IPC)
```{r, results='asis'}
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"IPC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```
---

### Negative control (NC) 
```{r, results='asis'}
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"NC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

## Heatmaps
```{r, include=FALSE}
# describe heatmap scale
if (params$heatMapRel==TRUE) heatmap_description <- "Numbers shown are percent relative to plate median."
if (params$heatMapRel==FALSE) heatmap_description <- ""
```
`r heatmap_description`

```{r, out.width='100%', fig.asp=0.33333*ceiling((length(ICs)+1)/2)}
for(i in 1:length(params$xmlFiles)){
  val <- matrixify(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName)
  vals <- unlist(as.list(t(val)))
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsTotal <- 1
  digitsmCherry <- if(params$heatMapRel) 1 else 0
  logVals <- log2(colSums(runs[[i]]$Data, na.rm=TRUE))
  well_order <- wellorder(runs[[i]]$sample, params$rowAnnotName, params$colAnnotName)
  val <- vals
  val[which(!is.na(vals))] <- logVals[well_order]
  plateHeatmap(as.numeric(val), 
               title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), 
               cex=0.5, digits=digitsTotal,
               relative=params$heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    val <- vals
    val[which(!is.na(vals))] <- runs[[i]]$Data[ICs[j],][well_order]
    plateHeatmap(as.numeric(val), 
                 title=paste0("Plate ", as.character(i),": ",  ICs[j]), 
                 cex=0.5, digits=digitsmCherry, 
                 relative=params$heatMapRel, cex.axis=0.5)
  }
}
```

---

## Quality Control

### Plate QC Flags
```{r, results='asis'}
for( i in 1:length(runs)){
  ICs  <- which(grepl(paste(params$IC, collapse="|"),  runs[[i]]$targets$targetName))
  IPCs <- which(grepl(paste(params$IPC, collapse="|"), runs[[i]]$samples$sampleName))
  NCs  <- which(grepl(paste(params$NC, collapse="|"),  runs[[i]]$samples$sampleName))
  # Plate QC 
  qcPlate <- QCFlagPlate(runs[[i]]$Data, normData[[i]], ICs, NCs, IPCs)
  table.attr <- paste0("id=\"QCFlagPlate-summary", i, "\"")
  qcPlate$status[which(qcPlate$status == "F")] <- "Pass"
  qcPlate$status[which(qcPlate$status == "T")] <- "Fail"
  qcPlate$val[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$val[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$val[nrow(qcPlate)] <- format(as.numeric(qcPlate$val[nrow(qcPlate)]), big.mark=",")
  cat(knitr::kable(qcPlate, caption=paste0("Plate ", as.character(i), ": QC Flag Plate Summary"), 
                   align='r', format.args=list(big.mark = ",", digits=2), table.attr=table.attr) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

### Sample QC Flags
```{r, results='asis'}
for( i in 1:length(runs)){
  ICs  <- which(grepl(paste(params$IC, collapse="|"),  runs[[i]]$targets$targetName))
  IPCs <- which(grepl(paste(params$IPC, collapse="|"), runs[[i]]$samples$sampleName))
  NCs  <- which(grepl(paste(params$NC, collapse="|"),  runs[[i]]$samples$sampleName))
  
  table.attr <- paste0("id=\"QCFlagSample-summary", i, "\"")
  # Sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], ICs, NCs, IPCs, runs[[i]]$samples)
  qcSample$status[which(qcSample$status == "F")] <- "Pass"
  qcSample$status[which(qcSample$status == "T")] <- "Fail"
  inds <- which(qcSample$flagName=="TARGETS_ABOVE_LOD")
  qcSample$val[inds] <- paste0(format(as.numeric(qcSample$val[inds])*100, digits=2), "%")
  inds <- which(qcSample$flagName != "TARGETS_ABOVE_LOD")
  qcSample$val[inds] <- format(as.numeric(qcSample$val[inds]), big.mark=",")
  qcSample <- qcSample[order(qcSample$sampleName),]
  rownames(qcSample) <- NULL
  qcSample <- qcSample %>% group_by(sampleName) %>% mutate(sampleName=replace(sampleName, duplicated(sampleName), ''))
  cat(knitr::kable(qcSample, caption=paste0("Plate ", as.character(i), ": QC Flag Sample Summary"), 
                   align='r', format.args=list(big.mark = ",", digits=2), table.attr=table.attr) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

## Detectability
```{r, results='asis'}
# Detectability summary
kable_styling(knitr::kable(detectability_summary, caption='Detectability Summary', 
                           align='r', 
                           table.attr="id=\"detectability-summary\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

# Target detectability
kable_styling(knitr::kable(detectability_targets, caption='Target Detectability %', 
                           align='r', 
                           table.attr="id=\"detectability-indepth\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) 
```

---

## Intra-plate Normalization
%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV. 

### Intra-plate %CV table -- unnormalized
```{r}
knitr::kable(intraCV_unnorm_summary_table, caption='', align='r', table.attr="id=\"intra-plateCV-unnormalized-summary\"", 
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

### Intra-plate %CV table -- mCherry-normalized
```{r}
knitr::kable(intraCV_mCherry_summary_table, caption='', align='r', table.attr="id=\"intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

### Intra-plate %CV boxplots by plate
```{r, out.width='100%', fig.asp=0.5}
intraCV_unnorm2 <- intraCV_unnorm
colnames(intraCV_unnorm2) <- paste0(colnames(intraCV_mCherry), ' unnormalized')
intraCV_mCherry2 <- intraCV_mCherry
colnames(intraCV_mCherry2) <- paste0(colnames(intraCV_mCherry), ' mCherry-normalized')
intraCV_vals <- t(interleave(t(intraCV_unnorm2), t(intraCV_mCherry2), drop=FALSE))
col <- unlist(alamarColorPalette(ceiling(length(intraCV_vals[1,])/2), nReps=2))
par(mar=c(5, 7, 2, 1))
boxplot(intraCV_vals, las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(intraCV_vals), na.rm=TRUE)),
        main='Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

## Sample boxplots
```{r, out.width='100%', fig.asp=1}
sampleboxplot <- function( data, ordering, label, plate_sample_colors, boxplot_colors){
  boxplot(log2(data[,ordering]+0.01),
          las=1, yaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": ", label),
          outcex=0.5,
          col=plate_sample_colors, horizontal=TRUE, cex=0.5)
  for (j in 1:ncol(data)){
    color <- if(plate_sample_colors[j] == boxplot_colors[1]) "black" else plate_sample_colors[j]
    axis(2, at=j, labels=colnames(data)[ordering[j]], cex.axis=0.3, las=2, col.axis=color, tck=-0.01)
  }
  lines(cbind(log2(data['mCherry',ordering]+0.01), 1:ncol(data)), col='red', las=1)
  mtext('log2(count + 0.01)', side=1, line=2)
  legend('topleft', 'mCherry', col='red', lty=1, cex=0.4, bty='n')
  abline(v=c(-50:50*5), col='grey', lty=3)
  return(NULL)
}

for(i in 1:length(params$xmlFiles)){
  plate_sample_type <- rep("1_sample",ncol(runs[[i]]$Data))
  if(!is.null(params$Bridge)){
    plate_sample_type[grepl(paste0(Bridge_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '2_donor'
  }
  plate_sample_type[grepl(paste0(IPC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '3_IPC'
  plate_sample_type[grepl(paste0(NC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '4_NC'
  
  ordering2 <- wellorder(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName) 
  ordering <- NULL
  types <- sort(unique(plate_sample_type))
  for(j in 1:length(types)){
    inds <- which(plate_sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }
  
  plate_sample_colors <- boxplot_colors[as.numeric(as.factor(plate_sample_type))[ordering]]
  par(mfrow=c(1,2), mar=c(4,6,2,0))
  sampleboxplot(runs[[i]]$Data, ordering, "unnormalized", plate_sample_colors, boxplot_colors)
  sampleboxplot(mCherry_IPC$interNormData[[i]], ordering, "mCherry + IPC", plate_sample_colors, boxplot_colors)
}
```

---

## Sample correlation
```{r, out.width='100%', fig.asp=1, results='asis'}
wellcolors <- function(data, well_types, boxplot_colors){
  # all labels black by default
  colors <- rep("black", ncol(data))
  for (j in 1:length(well_types)){
    # if bridge wells undefined leave color black
    if (j == 3 && is.null(well_types[[j]])){
      next
    }
    # save indices matching the given well type
    indices <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    # color well label to match well type
    if(length(indices) > 0){
      colors[indices] <- boxplot_colors[j+1]
    }
  }
  return(colors)
}

for(i in 1:length(params$xmlFiles)){
  pdf(file=NULL)
  corrvals <- corrplot(cor(intraPlateNormData[[i]]$mCherry$normData), 
                       order='hclust') 
  dev.off()
  well_types <- list(IPC_wells[[i]], NC_wells[[i]], Bridge_wells[[i]])
  colors <- wellcolors(data=corrvals$corr, 
                       well_types=well_types, 
                       boxplot_colors=boxplot_colors)
  corrplot(corrvals$corr,
           tl.cex=0.4,
           mar=c(1,1,1,1),
           tl.col=colors,
           order="original",
           title=paste("Plate", i),
           is.corr=FALSE)
  cat("\n")
}
```

---

## Sample and target clustering 
```{r, out.width='100%', fig.asp=1, results='asis'}
# define colors
paletteLength <- 50
heatmapColors <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
# loop over plates and draw heatmaps
for(i in 1:length(params$xmlFiles)){
  # define label colors
  well_types <- list(IPC_wells[[i]], NC_wells[[i]], Bridge_wells[[i]])
  label_colors <- wellcolors(data=data_mCherry_log2_scaled[[i]], 
                             well_types=well_types, 
                             boxplot_colors=boxplot_colors)
  # define color scale breaks
  breaks <- c(seq(min(data_mCherry_log2_scaled[[i]]), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_log2_scaled[[i]])/paletteLength, 
                  max(data_mCherry_log2_scaled[[i]]), length.out=floor(paletteLength/2)))
  # transpose and add color variable
  data_mCherry_log2_scaled2 <- data.frame(t(data_mCherry_log2_scaled[[i]]))
  data_mCherry_log2_scaled2$label_colors <- label_colors
  # generate heatmap for plate i
  heatmap_i <- pheatmap(data_mCherry_log2_scaled2[,1:(ncol(data_mCherry_log2_scaled2) - 1)],
                main = paste("Plate", i), 
                fontsize=5,
                color=heatmapColors,
                breaks=breaks,
                show_colnames=FALSE, silent=TRUE)
  # put colors in order
  label_colors_ordered <- data_mCherry_log2_scaled2[order(match(rownames(data_mCherry_log2_scaled2), heatmap_i$gtable$grobs[[5]]$label)),]$label_colors
  # add label colors to plot
  heatmap_i$gtable$grobs[[5]]$gp=gpar(col=label_colors_ordered)
  grid::grid.newpage()
  grid::grid.draw(heatmap_i$gtable)
  cat("\n")
}
```

---

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate Normalization", 2)
cat("%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV.")
```

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate %CV", 3)
knitr::kable(interCV_summary_table, caption='', 
             align='r', 
             table.attr="id=\"inter-plateCV-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

```{r out.width='100%', fig.asp=0.5, eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate %CV boxplot", 3)
par(mar=c(5,12,1,1))
boxplot(interCV_results, las=1, xlab='inter-plate CV (%)',
        ylim=c(0, max(interCV_results, na.rm=TRUE)), 
        col=alamarColorPalette(5), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

```{r, out.width='100%', fig.asp=0.5, results='asis', eval=multipleFiles}
# pandoc.header("Sample PCA", 2)
# doPCA <- function(data, plateVar, normed=FALSE, scale=FALSE, center=FALSE, title="Unnormalized"){
#   pca <- if(normed) prcomp(t(data), scale=scale, center=center) else prcomp(log2(t(data)+0.01), scale=scale, center=center)
#   par(mar=c(4,4,2,5))
#   plot(pca$x[,1], pca$x[,2], 
#        col=(1:length(levels(factor(plateVar))))[as.integer(factor(plateVar))],
#        pch=(1:length(levels(factor(plateVar))))[as.integer(factor(plateVar))],
#        xlab=paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), '% variance)'), 
#        ylab=paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), '% variance)'), 
#        main=title, las=1, cex=0.5)
#   legend(par('usr')[2], par('usr')[4], levels(factor(plateVar)),
#          col=1:length(levels(factor(plateVar))), xpd=NA,
#          pch=1:length(levels(factor(plateVar))), cex=0.75, bty='n')
#   return(NULL)
# }
# 
# removeTargetsSamples <- function(data, NC, IPC, Bridge){
#   data <- data[-which(grepl("mCherry", rownames(data))),]
#   data <- data[,-which(grepl(paste(c(NC, IPC, Bridge), collapse="|"), colnames(data)))]
#   return(data)
# }
# 
# dataPCAunnormal <- dataPCAnormed <- dataPCAnormedIPC <- dataPCAnormedIN <-plateVar <- NULL
# for(i in 1:length(params$xmlFiles)){
#   dataPCAunnormal <- cbind(dataPCAunnormal, removeTargetsSamples(runs[[i]]$Data, params$NC, params$IPC, params$Bridge))
#   dataPCAnormed <- cbind(dataPCAnormed, removeTargetsSamples(data_mCherry_log2_scaled[[i]], params$NC, params$IPC, params$Bridge))
#   dataPCAnormedIPC <- cbind(dataPCAnormedIPC, removeTargetsSamples(mCherry_IPC$interNormData[[i]], params$NC, params$IPC, params$Bridge))
#   dataPCAnormedIN <- cbind(dataPCAnormedIN, removeTargetsSamples(mCherry_IN$interNormData[[i]], params$NC, params$IPC, params$Bridge))
#   plateVar <- c(plateVar, rep(paste0("Plate",i),length(removeTargetsSamples(data_mCherry_log2_scaled[[i]], params$NC, params$IPC, params$Bridge)[1,])))
# }

# par(mfrow=c(2,2))
# e <- doPCA(dataPCAunnormal, plateVar, normed=FALSE, scale=TRUE, center=TRUE, title="Unnormalized")
# e <- doPCA(dataPCAnormed, plateVar, normed=TRUE, scale=TRUE, center=TRUE, title="mCherry")
# e <- doPCA(dataPCAnormedIPC, plateVar, normed=TRUE, scale=TRUE, center=TRUE, title="mCherry + IPC")
# e <- doPCA(dataPCAnormedIN, plateVar, normed=TRUE, scale=TRUE, center=TRUE, title="mCherry + IN")
```

