---
params:
  IC: !r c("mCherry")
  IPC: !r c("IPC")
  NC: !r c("NC")
  SC: !r NULL
  Bridge: !r NULL
  dataDir: "/Users/jbeer/github/TAP-COVID/data"
  rowAnnotName: "AUTO_WELLROW"
  colAnnotName: "AUTO_WELLCOL"
  plateAnnotName: "AUTO_PLATE"
#  rowAnnotName: "Annot2"
#  colAnnotName: "Annot3"
#  plateAnnotName: "Annot1"
  heatMapRel: !r TRUE
  study_name: "Study Name"
  assayName: "NULISAseq 200-plex Inflammation Panel"
  sample_desc: "This is a sample description."
  goal_desc: "NULISAseq 200-plex Inflammation Panel"
#  xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml","20230109_TAP_covid_plate02_nononmatch_XML.xml")
  xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml")
  plateNames: !r c()
  type: "WebApp"
output:
  html_document:
    toc: yes
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
library(gdata)
library(dplyr)
```

```{r, include=FALSE}
# function for colorizing wells in heatmap
wellorder <- function(samples, rowAnnotName, colAnnotName){
  cmd <- paste0("samples$", colAnnotName)
  cols <- eval(parse(text=cmd))
  cols <- formatC(as.numeric(cols), width=2, flag=0)
  cmd <- paste0("samples$", rowAnnotName)
  inds <- sort(paste0(eval(parse(text=cmd)), cols), index.return=TRUE)
  return(inds$ix)
}

# function to convert data into matrix for plate layout and heatmap
matrixify <- function(runSamples, rowAnnotName, colAnnotName, plate=FALSE){
  val <- matrix(rep(NA, 96), nrow=8)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  for(j in LETTERS[1:8]){
    for(k in 1:12){
      sample_jk <- runSamples$sampleName[runSamples[rowAnnotName]==j & runSamples[colAnnotName]==k]
      if(length(sample_jk)!=0){
        val[rownames(val)==j, colnames(val)==k] <- sample_jk
      }
      if(plate && length(sample_jk) == 0){
        val[rownames(val)==j, colnames(val)==k] <- ""
      }
    }
  }
  return(val)
}
```

```{r, include=FALSE}
# define plateIDs
xmlFilePlateNames <- c()
if(length(params$plateNames) == 0){
  xmlFilePlateNames <- rep("", times=length(params$xmlFiles))
}
# set multiple file indicator
multipleFiles <- if(length(params$xmlFiles) > 1) TRUE else FALSE
# set SC indicator
indicatorSC <- if(is.null(params$SC)) FALSE else TRUE
# set Bridge indicator
indicatorBridge <- if(is.null(params$Bridge)) FALSE else TRUE
# define title
title_var <- paste(params$study_name, params$assayName, sep='<br>')
# define sample specific boxplot colors for use in plots
boxplot_colors <- unlist(lapply(alamarColorPalette(n=5, tint='light', nReps=5), function(x) x[4]))
# set data directory
if(is.null(params$dataDir)){
  xmlFilesPath <- params$xmlFiles
}else{
  knitr::opts_knit$set(root.dir=params$dataDir)
  # save xml file path
  xmlFilesPath <- paste0(params$dataDir, "/", params$xmlFiles)
}
# define variables to store results
runs <- vector('list', length(params$xmlFiles))
runSummaries <- vector('list', length(params$xmlFiles))
read_summary <- PlateNames <- NULL
for(i in 1:length(params$xmlFiles)){
  # read each run
  runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=xmlFilePlateNames[i], NC=params$NC, SC=params$SC, IC=params$IC, IPC=params$IPC, Bridge=params$Bridge)
  # summarize each plate
  runSummaries[[i]] <- plateSummary(runs[[i]])
  read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
  # create plate names
  PlateNames <- c(PlateNames, paste("Plate", i, sep=" "))
  if (xmlFilePlateNames[i] != ""){
    PlateNames[i] <- paste0(PlateNames[i], "(", xmlFilePlateNames[i], ")")
  }
}
names(runs) <- names(runSummaries) <- xmlFilePlateNames
colnames(read_summary) <- PlateNames
# transpose read summary
read_summary <- t(read_summary)
```

```{r, include=FALSE}
# do intra-plate normalization
intraPlateNormData <- vector("list", length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  intraPlateNormData[[i]] <- vector("list", length(ICs))
  for (j in 1:length(ICs)){
    intraPlateNormData[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                                                   method="IC",
                                                   IC=ICs[j])
  }
  names(intraPlateNormData[[i]]) <- runs[[i]]$targets$targetName[ICs]
}
names(intraPlateNormData) <- xmlFilePlateNames
```

```{r, include=FALSE}
# calculate LOD on the IC normalized data
# use 1st IC as the primary IC (should be mCherry)
plate_lod <- vector('list', length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  NCs <- runs[[i]]$samples$sampleName[which(runs[[i]]$samples$sampleType == "NC")]
  plate_lod[[i]] <- lod(data_matrix=intraPlateNormData[[i]][[1]]$normData, blanks=NCs, min_count=0)
}
```

```{r, include=FALSE}
# do inter-plate normalization 
# save mCherry-normalized data in a list
normData <- lapply(intraPlateNormData, function(x) x[[1]]$normData)

# save IPCs, NCs wells for each plate
IPC_wells <- NC_wells <- SC_wells <- Bridge_wells <- vector('list', length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  IPC_wells[[i]] <- runs[[i]]$samples$sampleName[which(runs[[i]]$samples$sampleType=="IPC")]
  NC_wells[[i]]  <- runs[[i]]$samples$sampleName[which(runs[[i]]$samples$sampleType=="NC")]
  if(indicatorSC){
    SC_wells[[i]] <- runs[[i]]$samples$sampleName[which(runs[[i]]$samples$sampleType=="SC")]
  }
  if(indicatorBridge){
    Bridge_wells[[i]]  <- runs[[i]]$samples$sampleName[which(runs[[i]]$samples$sampleType=="Bridge")]
  }
} 

# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')

# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                             IPC=FALSE, IN=TRUE,
                             IPC_wells=IPC_wells,
                             NC_wells=NC_wells)
```

```{r, include=FALSE}
# calculate intra-plate CVs using sample controls
intraCV_unnorm <- intraCV_mCherry <- NULL
for (i in 1:length(params$xmlFiles)){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  # define sample control vector
  sample_controls <- rep(NA, nrow(runs[[i]]$samples))
  SCval <- if (!is.null(params$SC)) "SC" else "IPC"
  sample_controls[which(runs[[i]]$samples$sampleType == SCval) ]<- "SC"
  # unnormalized intraCV
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                  samples=sample_controls,
                                  aboveLOD=plate_lod[[i]]$aboveLOD,
                                  exclude_targets=ICs)
  # combine plates into one matrix
  intraCV_unnorm <- cbind(intraCV_unnorm, plate_unnorm_intraCV) 
  # mCherry intraCV
  plate_mCherry_intraCV <- intraCV(data_matrix=intraPlateNormData[[i]]$mCherry$normData,
                                   samples=sample_controls,
                                   aboveLOD=plate_lod[[i]]$aboveLOD,
                                   exclude_targets=ICs)
  # combine plates into one matrix
  intraCV_mCherry <- cbind(intraCV_mCherry, plate_mCherry_intraCV)
}

colnames(intraCV_unnorm) <- colnames(intraCV_mCherry) <- PlateNames

# create intra-plate CV table -- unnormalized
intraCV_unnorm_summary_table <- cbind(colMeans(intraCV_unnorm, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, sd, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, median, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, min, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, max, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, function(x){
                                        sum(is.na(x))
                                      }))

rownames(intraCV_unnorm_summary_table) <- PlateNames
colnames(intraCV_unnorm_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')

# create intra-plate CV table -- mCherry
intraCV_mCherry_summary_table <- cbind(colMeans(intraCV_mCherry, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, sd, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, median, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, min, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, max, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, function(x){
                                         sum(is.na(x))
                                       }))

rownames(intraCV_mCherry_summary_table) <- PlateNames
colnames(intraCV_mCherry_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# calculate inter-plate CVs using sample controls
sampleControlList <- plateData <- aboveLOD <- exclude_targets <- plate_mCherry <- vector("list", length(params$xmlFiles))
for(i in 1:length(params$xmlFiles)){
  # define sample control vector
  sample_controls <- rep(NA, nrow(runs[[i]]$samples))
  SCval <- if (!is.null(params$SC)) "SC" else "IPC"
  sample_controls[which(runs[[i]]$samples$sampleType == SCval) ]<- "SC"
  sampleControlList[[i]] <- sample_controls
  plateData[[i]] <- runs[[i]]$Data
  plate_mCherry[[i]] <- intraPlateNormData[[i]]$mCherry$normData
  aboveLOD[[i]] <- plate_lod[[i]]$aboveLOD
  exclude_targets[[i]] <- which(runs[[i]]$targets$targetType == "Control")
}

# unnormalized interCV
interCV_unnorm <- interCV(data_list=plateData,
                          samples=sampleControlList,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry interCV
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=sampleControlList,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC interCV
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=sampleControlList,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN interCV
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=sampleControlList,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)

# combine results into one matrix
  interCV_results <- cbind(interCV_unnorm,
                           interCV_mCherry,
                           interCV_mCherry_IPC,
                           interCV_mCherry_IN)
  colnames(interCV_results) <- c('unnorm',
                                 'mCherry',
                                 'mCherry + IPC',
                                 'mCherry + IN')

# create inter-plate CV table
interCV_summary_table <- cbind(colMeans(interCV_results, na.rm=TRUE),
                               apply(interCV_results, 2, sd, na.rm=TRUE),
                               apply(interCV_results, 2, median, na.rm=TRUE),
                               apply(interCV_results, 2, min, na.rm=TRUE),
                               apply(interCV_results, 2, max, na.rm=TRUE),
                               apply(interCV_results, 2, function(x){
                                 sum(is.na(x))
                               }))

rownames(interCV_summary_table) <- c('unnorm',
                                       'mCherry',
                                       'mCherry + IPC',
                                       'mCherry + IN')

colnames(interCV_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# calculate detectability
detectability_summary <- detectability_targets <- NULL
for (i in 1:length(params$xmlFiles)){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  detect_samples <- colnames(intraPlateNormData[[i]]$mCherry$normData)
  # remove IPCs, NCs, and SCs
  detect_samples <- detect_samples[!grepl(paste(params$IPC, collapse="|"), detect_samples)]
  detect_samples <- detect_samples[!grepl(paste(params$NC, collapse="|"), detect_samples)]
  if(indicatorSC){
    detect_samples <- detect_samples[!grepl(paste(params$SC, collapse="|"), detect_samples)]
  }
  if(indicatorBridge){
    detect_samples <- detect_samples[!grepl(paste(params$Bridge, collapse="|"), detect_samples)]
  }

  plate_detect <- detectability(aboveLOD_matrix=plate_lod[[i]]$aboveLOD,
                                sample_subset=detect_samples,
                                exclude_targets=ICs)
  detectability <- cbind(format(round(mean(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         format(round(sd(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         formatC(median(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(min(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(max(plate_detect$detectability, na.rm=TRUE), width=2),
                         paste0(sum(plate_detect$detectability >= 50),
                                ' (',
                                format(round(sum(plate_detect$detectability > 50)/length(plate_detect$detectability) * 100, 1), nsmall=1),
                                '%)'))
  colnames(detectability) <- c('mean',
                               'sd',
                               'median',
                               'min',
                               'max',
                               '# of detectable targets (%)')
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_targets <- cbind(detectability_targets, plate_detect$detectability)
}

rownames(detectability_summary) <- colnames(detectability_targets) <- PlateNames
```

```{r, include=FALSE}
# log transform and scale data for clustered heatmap
data_mCherry_log2_scaled <- list()
for(i in 1:length(params$xmlFiles)){
  # remove negative controls
  data_mCherry <- intraPlateNormData[[i]]$mCherry$normData
  data_mCherry <- data_mCherry[,!grepl(paste(params$NC, collapse="|"), colnames(data_mCherry))]
  # remove ICs
  data_mCherry <- data_mCherry[!grepl(paste(params$IC, collapse="|"), rownames(data_mCherry)),]
  # log transform and scale
  data_mCherry_log2_scaled[[i]] <- t(scale(t(log2(data_mCherry+0.01)),
                                           center=TRUE, scale=TRUE))
}
```

---
title: `r title_var`
---
```{r, results='asis', eval=params$type!="WebApp"}
pandoc.header("Study summary", 2)
elements <- c(paste("Goal:", params$goal_desc), paste("Sample Description:", params$sample_desc))
pandoc.list(elements, style="bullet")
```


## Plate layout
```{r, results='asis'}
pandoc.p("Shows the layout of samples, controls (NC, IPC), and special wells if any (e.g. Bridge Samples, Donor Samples, etc.) on the 96-well assay plate" )
for(i in 1:length(params$xmlFiles)){
  val <- matrixify(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){      well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){  well_types <- append(well_types, list(Bridge_wells[[i]]))}

  for (j in 1:length(well_types)){
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate Layout"), 
                   align="c", escape=FALSE, table.attr=table.attr) %>%
        kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE) %>%
        column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
        row_spec(0:8, extra_css = "border-bottom: 1px solid") 
  )
}
```

---

## Read summary
```{r, results='asis'}
pandoc.p("Summary of the number and classification of reads for the assay run") 
pandoc.list(c("Parseable - Valid NGS read (assay signal or background)",
              "Parseable Match - Valid NGS read (assay signal)",
              "Parseable Non-match - Vaild NGS read (assay background)",
              "Unparseable - Sequencing background",
              "Total samples - Total number of samples on plate",
              "Total targets - Total number of assay targets",
              "Zero values - Number of targets * samples which had no assay signal"
              ))
knitr::kable(read_summary, caption='', 
             align='r', format.args=list(big.mark = ","), 
             table.attr="id=\"read-summary\"") %>% 
  kable_styling(bootstrap_options=c("striped", "hover", "condensed"), full_width=TRUE)
```

---

### Internal controls (IC)
```{r, results='asis'}
pandoc.p("Each sample of the assay is spiked with the same concentration of an internal control (IC). This is used both as part of a well-normalization procedure and as a method for assessing the uniformity of the assay run.") 
if(length(ICs) == 1){
  IC_tables <- NULL
  for (i in 1:length(params$xmlFiles)){
    IC_tables <- rbind(IC_tables, runSummaries[[i]]$IC_table)
  }
  rownames(IC_tables) <- paste0("Plate", as.character(1:length(params$xmlFiles))) 
  cat(knitr::kable(IC_tables, 
                   caption="mCherry (IC) summary", 
                   align='r', 
                   format.args=list(big.mark = ","), 
                   table.attr="id=\"IC-summary\"") %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))  
} else {
  for(i in 1:length(params$xmlFiles)){
    table.attr <- paste0("id=\"IC-summary", i, "\"")
    cat(knitr::kable(runSummaries[[i]]$IC_table, 
                     caption=paste0("Plate ", as.character(i), ": IC summary"), 
                     align='r', 
                     format.args=list(big.mark = ","), 
                     table.attr=table.attr) %>% 
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```

---

### Inter-plate controls (IPC)
```{r, results='asis'}
pandoc.p("IPC samples are control samples used to both normalize samples between experiments and to assess performance of the assay.")
pandoc.p("Note: %CV in this table does not exclude values below LOD. See [Intra-plate normalization](#intraPlateNorm) or [Inter-plate normalization](#interPlateNorm) sections for %CV (before and after normalization) that excludes values below LOD.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"IPC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

### Negative controls (NC) 
```{r, results='asis'}
pandoc.p("NC wells are reactions where no sample input is provided. These are used to assess Limit of Detection (LOD) for each target assay and to assess run quality.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"NC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

```{r eval=indicatorSC, results='asis'}
pandoc.header("Sample controls (SC)", 3)
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"SC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$SC_table, caption=paste0("Plate ", as.character(i), ": SC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

```{r eval=indicatorBridge, results='asis'}
pandoc.header("Bridge Samples (Bridge)", 3)
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"Bridge-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$Bridge_table, caption=paste0("Plate ", as.character(i), ": Bridge summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

## Heatmaps
```{r, out.width='100%', fig.asp=0.33333*ceiling((length(ICs)+1)/2), results='asis'}
heatmap_description <- if (params$heatMapRel==TRUE) "percent relative to plate median" else "absolute normalized read count"
pandoc.p(paste0("The heatmaps show the ", heatmap_description, " for both the total counts for each sample as well as specifically for the IC"))
for(i in 1:length(params$xmlFiles)){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  val <- matrixify(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName)
  vals <- unlist(as.list(t(val)))
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsmCherry <- if(params$heatMapRel) 1 else 0
  logVals <- log2(colSums(runs[[i]]$Data, na.rm=TRUE))
  well_order <- wellorder(runs[[i]]$sample, params$rowAnnotName, params$colAnnotName)
  val <- vals
  val[which(!is.na(vals))] <- logVals[well_order]
  plateHeatmap(as.numeric(val), 
               title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), 
               cex=0.5, digits=1,
               relative=params$heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    val <- vals
    val[which(!is.na(vals))] <- runs[[i]]$Data[ICs[j],][well_order]
    plateHeatmap(as.numeric(val), 
                 title=paste0("Plate ", as.character(i),": ",  params$IC[j]), 
                 cex=0.5, digits=digitsmCherry, 
                 relative=params$heatMapRel, cex.axis=0.5)
  }
}
```

---

## Quality control

### Plate QC

```{r, results='asis'}
pandoc.p("Plate-specific QC criteria:")
pandoc.list(c("ICRead_CV - Coefficient of Varation of Internal control signal across all samples",
              "IPCRead_CV - Coefficient of Variation of the total assay signal across all samples",
              "IPCTarget_CV - Median of Coefficient of Variation of all IPC targets",
              "Detectability - Target-wise detectability (target is considered detected if >50% samples have signal > LOD",
              "MinReads - Minimum number of reads (signal) for the experiment"
              ))

for( i in 1:length(runs)){
  qcPlate <- QCFlagPlate(runs[[i]]$Data, normData[[i]], runs[[i]]$targets, runs[[i]]$samples)
  table.attr <- paste0("id=\"QCFlagPlate-summary", i, "\"")
  qcPlate$status[which(qcPlate$status == "F")] <- "Pass"
  qcPlate$status[which(qcPlate$status == "T")] <- "Fail"
  qcPlate$QCthreshold[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$QCthreshold[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$QCthreshold[nrow(qcPlate)] <- format(as.numeric(qcPlate$QCthreshold[nrow(qcPlate)]), big.mark=",")
  qcPlate$val[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$val[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$val[nrow(qcPlate)] <- format(as.numeric(qcPlate$val[nrow(qcPlate)]), big.mark=",")
  cat(knitr::kable(qcPlate[,1:ncol(qcPlate)-1], 
                   caption=paste0("Plate ", as.character(i), ": Plate QC Flag Summary"), 
                   align='r', 
                   format.args=list(big.mark = ",", digits=2),
                   table.attr=table.attr,
                   col.names = c("Flag Name", "Normalization", "QC Status", "QC Value", "QC Threshold"
                                 )) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) %>%
        row_spec(which(qcPlate$status == "Fail"), bold=T, color="white", background="red"))
}
```

### Sample QC 
#### Sample QC summary table
```{r, out.width='100%', fig.asp=2, results='asis'}
pandoc.p("Sample-specific QC criteria:")
pandoc.list(c("Detectability - Target detectability for the a sample",
              "ICReads - Minimum number of IC reads for a sample",
              "NumReads - Minimum number of total reads",
              "IC_Median - Number of IC reads between -30% and +30% of plate median"
              ))

rmin <- rmax <- val <- list()
criteria <- QCSampleCriteria()
rowNameQC <- c()
QCSummary <- matrix(nrow=length(runs)+1, ncol=length(criteria$thresholds)+1)
for (i in 1:length(runs)){
  QCSummary[i, 1] <- ncol(runs[[i]]$Data)
  rowNameQC <- c(rowNameQC,  paste0("Plate ", as.character(i))) 
}

for (j in 1:length(criteria$thresholds)){
  for (i in 1:length(runs)){
    qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
    inds <- which(qcSample$flagName == names(criteria$thresholds)[j])
    val[j] <- if(names(criteria$thresholds)[j] == "Detectability") as.numeric(criteria$thresholds[j])*100 else criteria$thresholds[j]
    if(names(criteria$thresholds)[j] == "Detectability"){
      xval <- as.numeric(qcSample[inds, ]$val)*100
      rmax[j] <- 100.0
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=T) 
    }else if (names(criteria$thresholds)[j] == "IC_Median"){
      xval <- as.numeric(qcSample[inds, ]$val)*100
      minmaxVal <- unlist(strsplit(val[[j]], ","))
      rmin[j] <- min(as.numeric(minmaxVal[1])*100, as.numeric(xval), na.rm=T)
      rmax[j] <- max(as.numeric(minmaxVal[2])*100, as.numeric(xval), na.rm=T)
    }else{
      xval <- as.numeric(qcSample[inds, ]$val)
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=T)
      rmax[j] <- max(as.numeric(val[[j]]), as.numeric(xval), na.rm=T)
    }
    QCSummary[i, j+1] <- length(which(qcSample[inds,]$status == "T"))
  }
}
QCSummary[i+1, ] <- colSums(QCSummary, na.rm=T) 
rownames(QCSummary) <- c(rowNameQC, "Total")
colnames(QCSummary) <- c("# of Samples", names(criteria$thresholds))
knitr::kable(QCSummary, caption='', 
             align='r', 
             table.attr="id=\"QC-summary-table\"",
             format.args=list(big.mark = ",", digits=2, escape=FALSE)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

for( i in 1:length(runs)){
  well_order <- wellorder(runs[[i]]$sample, params$rowAnnotName, params$colAnnotName)
  
  # Sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  if(indicatorSC){
    inds <- which(grepl(paste(params$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(params$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }
  par(mfrow=c(ceiling(length(criteria$thresholds)/2), 2), mar=c(5,6,2,2))
  for(j in 1:length(names(criteria$thresholds))){
    inds <- which(qcSample$flagName == names(criteria$thresholds)[j])
    color <- rep("black", length(inds))
    xlab <- ""
    xval <- NULL
    if(names(criteria$thresholds)[j] == "Detectability"){
      xlab <- "Detectability %"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    }else if(names(criteria$thresholds)[j] == "IC_Median"){
      xlab <- "% of mCherry Median"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    }else{
      xlab <- "Number of Reads"
      xval <- qcSample[inds, ]$val
      zs <- which(xval == 0)
      if(length(zs) > 0){
        xval[zs] <- xval[zs]+1
      }
    }
    color[which(qcSample[inds,]$sampleType == "IPC")] <- boxplot_colors[2]
    color[which(qcSample[inds,]$sampleType == "NC")] <- boxplot_colors[3]
    if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "SC")] <- boxplot_colors[4]
    }
    if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "Bridge")] <- boxplot_colors[5]
    }
    
    log <- if(names(criteria$thresholds)[j] != "Detectability" && names(criteria$thresholds)[j] != "IC_Median") "x" else ""
    par(mar=c(5,6,2,2))
    dotchart(x=as.numeric(xval), xlab=xlab, 
             labels=qcSample[inds, ]$sampleName, las=1, 
             cex=0.45, xlim=c(rmin[[j]], rmax[[j]]), color=color, log=log)
    xvalFail <- xval
    xvalFail[which(qcSample[inds,]$status != "T")] <- NA
    xvalPass <- xval
    xvalPass[which(qcSample[inds,]$status != "F")] <- NA
    points(as.numeric(xvalPass),1:length(xvalPass), pch=19, col="green")
    points(as.numeric(xvalFail),1:length(xvalFail), pch=19, col="red")
    if(names(criteria$thresholds)[j] == "IC_Median"){
      minmaxVal <- unlist(strsplit(val[[j]], ","))
      abline(v=as.numeric(minmaxVal[[1]])*100, col='brown')
      abline(v=as.numeric(minmaxVal[[2]])*100, col='brown')
    }else{
      abline(v=val[[j]], col='brown')
    }
    legend('bottomright', legend=c('Pass', "Fail"), col=c('green', 'red'), pch=19, cex=0.4, bty='n', inset=c(0,1), xpd=T,horiz=T)
    title(main=paste0("Plate ", as.character(i), ": ", names(criteria$thresholds)[j]))
  } 
}
```

---

## Detectability
Target detectability is the percentage of samples that are above the limit of detection for that target. A target is considered "detectable" if it is above limit of detection in at least 50% of samples 
```{r, results='asis', out.width='100%', fig.asp=1.5}
# Detectability summary
kable_styling(knitr::kable(detectability_summary, caption='Detectability Summary', 
                           align='r', 
                           table.attr="id=\"detectability-summary\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

# Target detectability
kable_styling(knitr::kable(detectability_targets, caption='Target Detectability %', 
                           align='r', 
                           table.attr="id=\"detectability-indepth\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) 

# Target Boxplot
pandoc.header("Target Detectability Boxplot", 3)
pandoc.p("The Target Detectability Boxplot...")
par(mfrow=c(ceiling(length(params$xmlFiles)/2),2), mar=c(4,6,2,0))
for (i in 1:length(params$xmlFiles)){
  targetBoxplot(runs[[i]]$Data, 
                title=PlateNames[i], 
                subtractLOD=TRUE, 
                blanks=runs[[i]]$NC, 
                horizontal=TRUE, 
                cex.targets=0.25, 
                excludeTargets=runs[[i]]$IC, 
                excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC))
}
```

---

## Intra-plate normalization {#intraPlateNorm}
%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV. 

```{r, eval=params$type=="internal"}
pandoc.header("Intra-plate %CV table -- unnormalized", 3)
knitr::kable(intraCV_unnorm_summary_table, caption='', align='r', table.attr="id=\"intra-plateCV-unnormalized-summary\"", 
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

```{r, eval=params$type=="internal"}
pandoc.header("Intra-plate %CV table -- mCherry-normalized", 3)
knitr::kable(intraCV_mCherry_summary_table, caption='', align='r', table.attr="id=\"intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

### Intra-plate %CV boxplots by plate
```{r, out.width='100%', fig.asp=0.5}
intraCV_unnorm2 <- intraCV_unnorm
colnames(intraCV_unnorm2) <- paste0(colnames(intraCV_mCherry), ' unnormalized')
intraCV_mCherry2 <- intraCV_mCherry
colnames(intraCV_mCherry2) <- paste0(colnames(intraCV_mCherry), ' mCherry-normalized')
intraCV_vals <- t(interleave(t(intraCV_unnorm2), t(intraCV_mCherry2), drop=FALSE))
col <- unlist(alamarColorPalette(ceiling(length(intraCV_vals[1,])/2), nReps=2))
par(mar=c(5, 7, 2, 1))
boxplot(intraCV_vals, las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(intraCV_vals), na.rm=TRUE)),
        main='Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

## Sample boxplots
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Sample boxplots show ...")
sampleboxplot <- function( data, ordering, label, plate_sample_colors, boxplot_colors){
  boxplot(log2(data[,ordering]+0.01),
          las=1, yaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": ", label),
          outcex=0.5,
          col=plate_sample_colors, horizontal=TRUE, cex=0.5)
  for (j in 1:ncol(data)){
    color <- if(plate_sample_colors[j] == boxplot_colors[1]) "black" else plate_sample_colors[j]
    axis(2, at=j, labels=colnames(data)[ordering[j]], cex.axis=0.3, las=2, col.axis=color, tck=-0.01)
  }
  lines(cbind(log2(data['mCherry',ordering]+0.01), 1:ncol(data)), col='red', las=1)
  mtext('log2(count + 0.01)', side=1, line=2)
  legend('topleft', 'mCherry', col='red', lty=1, cex=0.4, bty='n')
  abline(v=c(-50:50*5), col='grey', lty=3)
  return(NULL)
}

for(i in 1:length(params$xmlFiles)){
  plate_sample_type <- rep("1_sample",ncol(runs[[i]]$Data))
  plate_sample_type[grepl(paste0(IPC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '3_IPC'
  plate_sample_type[grepl(paste0(NC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '4_NC'
  if(indicatorSC){
    plate_sample_type[grepl(paste0(SC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '5_SC'
  }
  if(indicatorBridge){
    plate_sample_type[grepl(paste0(Bridge_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '6_Bridge'
  }
  ordering2 <- wellorder(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName) 
  ordering <- NULL
  types <- sort(unique(plate_sample_type))
  for(j in 1:length(types)){
    inds <- which(plate_sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }
  
  plate_sample_colors <- boxplot_colors[as.numeric(as.factor(plate_sample_type))[ordering]]
  numPlots <- if(params$type == "internal") 2 else 1
  par(mfrow=c(1,numPlots), mar=c(4,6,2,0))
  if(params$type == "internal"){
    sampleboxplot(runs[[i]]$Data, ordering, "unnormalized", plate_sample_colors, boxplot_colors)
  }
  sampleboxplot(mCherry_IPC$interNormData[[i]], ordering, "mCherry + IPC", plate_sample_colors, boxplot_colors)
}
```

---

## Sample correlation
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Sample correlation plot shows the correlation between samples as measured by Pearson correlation on the expression of targets")
wellcolors <- function(data, well_types, boxplot_colors){
  # all labels black by default
  colors <- rep("black", ncol(data))
  for (j in 1:length(well_types)){
    # save indices matching the given well type
    indices <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    # color well label to match well type
    if(length(indices) > 0){
      colors[indices] <- boxplot_colors[j+1]
    }
  }
  return(colors)
}

for(i in 1:length(params$xmlFiles)){
  pdf(file=NULL)
  corrvals <- corrplot(cor(intraPlateNormData[[i]]$mCherry$normData), 
                       order='hclust') 
  dev.off()

  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  colors <- wellcolors(data=corrvals$corr, 
                       well_types=well_types, 
                       boxplot_colors=boxplot_colors)
  corrplot(corrvals$corr,
           tl.cex=0.4,
           mar=c(1,1,1,1),
           tl.col=colors,
           order="original",
           title=paste("Plate", i),
           is.corr=FALSE)
  cat("\n")
}
```

---

## Sample and target clustering 
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Hierarchical clustering of both samples and targets using a Euclidean distance metric, and complete linkage")
# define colors
paletteLength <- 50
heatmapColors <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
# loop over plates and draw heatmaps
for(i in 1:length(params$xmlFiles)){
  # define label colors
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  label_colors <- wellcolors(data=data_mCherry_log2_scaled[[i]], 
                             well_types=well_types, 
                             boxplot_colors=boxplot_colors)
  # define color scale breaks
  breaks <- c(seq(min(data_mCherry_log2_scaled[[i]]), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_log2_scaled[[i]])/paletteLength, 
                  max(data_mCherry_log2_scaled[[i]]), length.out=floor(paletteLength/2)))
  # transpose and add color variable
  data_mCherry_log2_scaled2 <- data.frame(t(data_mCherry_log2_scaled[[i]]))
  data_mCherry_log2_scaled2$label_colors <- label_colors
  # generate heatmap for plate i
  heatmap_i <- pheatmap(data_mCherry_log2_scaled2[,1:(ncol(data_mCherry_log2_scaled2) - 1)],
                main = paste("Plate", i), 
                fontsize=5,
                color=heatmapColors,
                breaks=breaks,
                show_colnames=FALSE, silent=TRUE)
  # put colors in order
  label_colors_ordered <- data_mCherry_log2_scaled2[order(match(rownames(data_mCherry_log2_scaled2), heatmap_i$gtable$grobs[[5]]$label)),]$label_colors
  # add label colors to plot
  heatmap_i$gtable$grobs[[5]]$gp=gpar(col=label_colors_ordered)
  grid::grid.newpage()
  grid::grid.draw(heatmap_i$gtable)
  cat("\n")
}
```

---

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate normalization {#interPlateNorm}", 2)
cat("%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV.")
```

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate %CV", 3)
if(params$type != "internal"){
  remove <- "mCherry + IN"
  interCV_summary_table2 <- interCV_summary_table[!(rownames(interCV_summary_table) %in% remove),]
  interCV_results2 <- interCV_results[, !(colnames(interCV_results) %in% remove)]
}else{
  interCV_summary_table2 <- interCV_summary_table
  interCV_results2 <- interCV_results
}
knitr::kable(interCV_summary_table2, caption='', 
             align='r', 
             table.attr="id=\"inter-plateCV-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

```{r out.width='100%', fig.asp=0.5, eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate %CV boxplot", 3)
par(mar=c(5,12,1,1))
boxplot(interCV_results2, las=1, xlab='inter-plate CV (%)',
        ylim=c(0, max(interCV_results2, na.rm=TRUE)), 
        col=alamarColorPalette(5), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

```{r, out.width='100%', fig.asp=(0.4)+as.numeric(multipleFiles)*0.4, results='asis', eval=params$type=="internal"}
pandoc.header("Sample PCA", 2)
PCAplot <- function(data, plateID, scale=TRUE, center=TRUE, title=NULL){
  pca <- prcomp(log2(t(data)+0.01), scale=scale, center=center)
  par(mar=c(4,4,2,5))
  plateID <- factor(plateID)
  colors <- alamarColorPalette(length(levels(plateID)))
  IPC_samples <- grep(paste(params$IPC, collapse="|"), colnames(data))
  point_shapes <- rep(1, ncol(data))
  point_shapes[IPC_samples] <- 8
  legendText <- c(levels(plateID), 'Sample', 'IPCs')
  if(indicatorSC){
    SC_samples <- grep(paste(params$SC, collapse="|"), colnames(data))
    point_shapes[SC_samples] <- 9
    legendText <- c(legendText, "SCs")
  }
  if(indicatorBridge){
    Bridge_samples <- grep(paste(params$Bridge, collapse="|"), colnames(data))
    point_shapes[Bridge_samples] <- 10
    legendText <- c(legendText, "Bridges")
  }
  plot(pca$x[,1], pca$x[,2],
       col=colors[as.integer(plateID)],
       pch=point_shapes,
       xlab=paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), 
                   '% variance)'),
       ylab=paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), 
                   '% variance)'),
       main=title, las=1, cex=0.5)
  legend(par('usr')[2], par('usr')[4], 
         legendText,
         col=c(colors, 'black', 'black', 'black', 'black'), xpd=NA,
         pch=c(1,1,1,8,9,10), cex=0.75, bty='n')
}

removeTargetsSamples <- function(data, NC){
  data <- data[-which(grepl("mCherry", rownames(data))),]
  data <- data[,-which(grepl(paste(NC, collapse="|"), colnames(data)))]
  return(data)
}

dataPCA_unnorm <- dataPCA_mCherry <- dataPCA_mCherryIPC <- dataPCA_mCherryIN <- plateID <- NULL
for(i in 1:length(params$xmlFiles)){
  dataPCA_unnorm <- cbind(dataPCA_unnorm, removeTargetsSamples(runs[[i]]$Data, params$NC))
  dataPCA_mCherry <- cbind(dataPCA_mCherry, removeTargetsSamples(intraPlateNormData[[i]][[1]]$normData, params$NC))
  dataPCA_mCherryIPC <- cbind(dataPCA_mCherryIPC, removeTargetsSamples(mCherry_IPC$interNormData[[i]], params$NC))
  dataPCA_mCherryIN <- cbind(dataPCA_mCherryIN, removeTargetsSamples(mCherry_IN$interNormData[[i]], params$NC))
  plateID <- c(plateID, rep(paste0("Plate",i), ncol(dataPCA_unnorm)))
}

nRowsPCA <- if(multipleFiles) 2 else 1
nCols <- 2
par(mfrow=c(nRowsPCA, nCols))
PCAplot(dataPCA_unnorm, plateID, scale=TRUE, center=TRUE, title="Unnormalized")
PCAplot(dataPCA_mCherry, plateID, scale=TRUE, center=TRUE, title="mCherry")
if(multipleFiles){
  PCAplot(dataPCA_mCherryIPC, plateID, scale=TRUE, center=TRUE, title="mCherry + IPC")
  if(params$type == "internal"){
    PCAplot(dataPCA_mCherryIN, plateID, scale=TRUE, center=TRUE, title="mCherry + IN")
  }
}
```
