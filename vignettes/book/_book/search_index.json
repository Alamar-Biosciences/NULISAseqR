[["index.html", "NULISAseqR User Guide Welcome What is NULISAseqR? Installation Getting Help", " NULISAseqR User Guide Welcome This guide will walk you through analysis of NULISAseq proteomic data using R. What is NULISAseqR? NULISAseqR is an R package designed specifically for working with NULISAseq proteomic data. It provides: Data Import: Read XML files from NULISAseq multiplex proteomic panels Quality Control: Automated QC reporting and metrics Visualization: Heatmaps, PCA plots, volcano plots, boxplots, etc. Statistical Analysis: Differential expression testing and longitudinal analysis Predictive Modeling: Linear models using protein expression to predict an outcome Installation New to R? If you haven’t installed R and RStudio yet, see the Installing R and RStudio guide in the Additional Resources page. Install NULISAseqR from GitHub: # Install devtools if needed install.packages(&quot;devtools&quot;) # Install NULISAseqR devtools::install_github(&#39;Alamar-Biosciences/NULISAseqR&#39;, ref = &#39;main&#39;) # Install other packages install.packages(&quot;tidyverse&quot;) Load the packages: library(NULISAseqR) library(tidyverse) Getting Help Function help: Type ?function_name in the R console GitHub Issues: Report bugs or request features © 2025 Alamar Biosciences Bioinformatics Team Generated with NULISAseqR version 1.4.0 Last updated: November 07, 2025 "],["understanding-nulisaseq-data.html", "Understanding NULISAseq Data What is NULISA™ Technology? Data Normalization NPQ vs Fold Change Working with NPQ Values Data Analysis FAQ", " Understanding NULISAseq Data Before diving into data analysis, it’s important to understand how NULISAseq technology works and how the data is generated and normalized. What is NULISA™ Technology? NULISA (NUcleic acid-Linked Immuno-Sandwich Assay) is a highly sensitive protein quantification platform that combines immunoassay specificity with next-generation sequencing readout. The NULISAseq platform uses a proprietary dual selection proximity ligation approach to obtain high sensitivity and high signal-to-noise ratio for multiplexed protein detection: Key Components: Verified antigen-specific antibody pairs - Two antibodies that bind different epitopes on the target protein Antibody-specific barcodes - Unique DNA sequences attached to each antibody Bridging oligos - Connect the barcodes only when both antibodies bind the same target Biotinylated oligos - Enable sequential capture on beads PolyA-tailed oligos - Allow for sequencing readout Technical Workflow The assay follows these steps: This dual selection removes assay background and drastically improves signal-to-noise ratio. Learn More About NULISA™ Technology For a comprehensive understanding of the NULISA™ platform, we recommend: NULISA™ Publication Feng, W., Beer, J.C., Hao, Q. et al. (2023). “NULISA: a proteomic liquid biopsy platform with attomolar sensitivity and high multiplexing.” Nature Communications 14, 7238. Read the full article NULISA™ Platform Overview Watch the NULISATM Platform Video for a visual explanation of the technology and workflow. Technical Documentation For detailed technical notes on assay design, normalization methods, and quality control: See Technical Documentation in the Additional Resources chapter. Available NULISAseq Panels Alamar Biosciences offers several curated panels for disease-specific research, including: Inflammation Panel: 250+ immune response markers including 120+ cytokines and chemokines CNS Disease Panel: 120+ neuro-specific and neuro inflammation-related proteins Mouse Panel: 120+ inflammation, neuro-degeneration and oncogenesis proteins specific to mouse model Custom assays: Develop your own biomarker assays with the NULISAqpcr Custom Assay Development Kit Explore Current Panels: https://alamarbio.com/nulisa-panels/ For detailed panel specifications, target lists, and custom assay options, visit the Alamar Biosciences website Data Normalization NULISAseq uses a multi-step normalization process to make protein measurements comparable across samples and plates. Raw Data: Sequencing Counts The output from the sequencer is read counts for each target protein in each sample: Each protein has a unique barcode More reads = more protein present Raw counts range from 0 to millions Step 1: Internal Control (IC) Normalization Purpose: Correct for sample-to-sample technical variation Method: Each sample includes internal control spike-ins Divide each target’s read count by the sample’s IC count Formula: \\[ \\text{IC} - \\text{normalized count} = \\text{Raw count} / \\text{IC count} \\] Step 2: Inter-Plate Control (IPC) Normalization Purpose: Correct for plate-to-plate variation Method: Calculate target-specific medians across 3 inter-plate controls (IPCs) Divide IC-normalized counts by these IPC target-specific medians Rescale by multiplying by 10⁴ Formula: \\[ \\text{IPC} - \\text{normalized count} = (\\text{IC} - \\text{normalized count} / \\text{IPC median}) × 10⁴ \\] Step 3: Log2 Transformation Purpose: Create NPQ (NULISA Protein Quantification) values in log2 scale Method: Add 1 to all values (avoid log(0)) Take log2 transformation Formula: \\[ \\text{NPQ} = log_2(\\text{IPC} - \\text{normalized count} + 1) \\] Special normalization for high-abundance targets Most targets in NULISAseq panels are measured at their lower limit of detection. However, certain targets have exceptionally high endogenous levels that would saturate standard detection: High-abundance targets: Inflammation Panel: CRP and KNG1 in human plasma and CSF CNS Panel: APOE and CRP in human plasma and CSF Mouse Panel: Crp in mouse plasma and serum Special tuning strategy: To accommodate both high-abundance and low-abundance targets in the same panel, these targets use a designed algorithm during normalization.This transformation is applied before the log₂ transformation step. Key Note: The listed LOD for these targets represents the upper limit of detection NPQ values are valid and comparable for downstream analysis Detectability is not a concern given the naturally high levels of these proteins For novel sample types beyond validated matrices, the algorithm may not apply if abundance levels differ significantly, and NPQ may not be reported Why Log Transform? Using NPQ (log2-transformed values) instead of raw counts has many advantages: ✅ Stabilizes variance - Makes data more homoscedastic ✅ Reduces skewness - Data becomes more normally distributed ✅ Linearizes relationships - Easier to model ✅ Improves interpretability - Differences = fold changes ✅ Compresses range - Large values don’t dominate ✅ Reveals clearer patterns - Easier to see biological signals NPQ vs Fold Change Understanding the Relationship Fold Change is calculated as: \\[ \\text{Fold Change} = 2^{(\\text{Difference in NPQ})} \\] Example: Sample ΔNPQ Fold Change 1 2.3 5 2 4.1 17 3 5.7 53 4 7.3 161 5 8.9 485 6 10.5 1457 Key Point: NPQ differences are linear and easier to interpret than exponential fold changes! Working with NPQ Values Calculating Fold Changes from NPQ If you need fold changes for interpretation: # Given NPQ values npq_disease &lt;- 7.0 npq_healthy &lt;- 4.0 # Calculate difference delta_npq &lt;- npq_disease - npq_healthy # 3.0 # Convert to fold change fold_change &lt;- 2^delta_npq # 2^3 = 8 Interpretation: Protein is 8 times higher in the disease group compared to healthy. Comparing Across Targets NPQ values can be compared across targets because: All targets go through same normalization Values are on same scale Useful for calculating protein ratios Example use case: Aβ42/Aβ40 ratio for Alzheimer’s diagnosis Sample Target NPQ Sample A (Healthy) Aβ42 9 Sample A (Healthy) Aβ40 6 Sample B (Alzheimer’s) Aβ42 5 Sample B (Alzheimer’s) Aβ40 7 Calculating Protein Ratios Since NPQ values are log₂-transformed, calculating ratios is straightforward: subtract the NPQ values. Formula for comparisons: \\[ log_2(A/B) = log_2(A) - log_2(B) \\] \\[ log_2(A/B) = \\text{NPQ}_A - \\text{NPQ}_B \\] Calculations: For Sample A (Healthy control): NPQ(Aβ42) = 9, NPQ(Aβ40) = 6 Log₂(Aβ42/Aβ40) = 9 - 6 = 3 Actual ratio = 2³ = 8 (Aβ42 is 8× more abundant than Aβ40) For Sample B (Alzheimer’s patient): NPQ(Aβ42) = 5, NPQ(Aβ40) = 7 Log₂(Aβ42/Aβ40) = 5 - 7 = -2 Actual ratio = 2⁻² = 0.25 (Aβ42 is only 0.25× the amount of Aβ40, or Aβ40 is 4× higher) Sample NPQ Aβ42 NPQ Aβ40 Log₂ Ratio Ratio Sample A (Healthy) 9 6 3 8.00 Sample B (Alzheimer’s) 5 7 -2 0.25 Interpretation: Healthy brain: Aβ42/Aβ40 ratio = 8.0 Alzheimer’s brain: Aβ42/Aβ40 ratio = 0.25 The Aβ42/Aβ40 ratio reflects the amyloid pathology, making this ratio a powerful biomarker for Alzheimer’s disease diagnosis and monitoring. Data Analysis FAQ 1. How is the limit of detection (LOD) defined for NULISAseq? Why do some targets have LOD of 0? LOD is calculated separately for each analyte / target using the negative control (NC) samples. For NULISAseq, the LOD is defined as follow: Formula: \\[ \\text{LOD} = mean(\\text{NC}) + 3 × sd(\\text{NC}) \\] LOD is calculated on the normalized count scale, and then log2-transformed to be on the NPQ scale. LOD = 0: Occurs when negative controls show no detectable signal at the current NGS depth. 2. Should I exclude samples below LOD? We don’t recommend excluding individual values below LOD or replacing NPQ values with LOD. Why not? Excluding or replacing values creates skewed, non-normal distributions Violates statistical assumptions for model assumptions for analysis Reduces statistical power Instead, we recommend using different detectability cutoff to exclude targets with low detectability 3. How do I calculate coefficient of variation (CV) for samples? IMPORTANT: Unlog NPQ values before calculating CV. NPQ values are in log₂ scale, but CV is only meaningful on the linear scale. Step-by-step process: Back-transform NPQ to linear scale: \\[ \\text{Linear value} = 2^{\\text{NPQ}} - 1 \\] Calculate mean and standard deviation on linear scale: \\[ \\text{Mean}_{\\text{linear}} = \\text{mean(linear values)} \\] \\[ \\text{SD}_{\\text{linear}} = \\text{sd(linear values)} \\] Calculate CV: \\[ \\text{CV} = \\frac{\\text{SD}_{\\text{linear}}}{\\text{Mean}_{\\text{linear}}} \\times 100\\% \\] Example in R: # For replicate samples of a single target npq_values &lt;- c(8.5, 8.7, 8.3) # NPQ values (log2 scale) # Back-transform to linear scale linear_values &lt;- 2^npq_values - 1 # Calculate CV mean_linear &lt;- mean(linear_values) sd_linear &lt;- sd(linear_values) cv_percent &lt;- (sd_linear / mean_linear) * 100 print(paste0(&quot;CV = &quot;, round(cv_percent, 2), &quot;%&quot;)) #&gt; [1] &quot;CV = 13.87%&quot; 4. Can I compare data across different runs? Yes! IPC normalization is designed to make data comparable across runs. Quality metrics supporting cross-run comparability include: Mean and median IPC CVs typically &lt;10% High inter-sample correlations (inter-run Pearson correlation ~ \\(r = 0.95\\)) In some cases intensity normalization or bridge samples (3-5 samples) can be used for further normalization. This enables longitudinal studies and meta-analyses. 5. How do you assess correlation between NPQ and absolute quantification data from other platforms? Transform datasets from other platforms to log2 scale first! Recommended approach: Convert absolute quantification values (e.g., pg/mL) to log2 scale Compare log2-transformed values against NPQ values Visualize with scatterplots before choosing correlation method Choosing the appropriate correlation method: ✅ Use Pearson correlation (r) when: Scatterplot shows approximately linear relationship No extreme outliers present Data appears normally distributed ✅ Use non-parametric methods (Spearman ρ or Kendall τ) when: Scatterplot shows nonlinear trend Extreme outliers present Very small sample size Data far from normal distribution Note: For non-parametric methods, the specific data transformation is less critical, but log2 transformation still helps with visualization and interpretability. Continue to: Chapter 1: Data Import "],["data-import.html", "Chapter 1 Data Import 1.1 The importNULISAseq() Function 1.2 Understanding the Data Structure 1.3 Working with Your Own Data 1.4 Loading Metadata 1.5 Merging Data with Metadata 1.6 Filtering Samples 1.7 Complete Import Workflow 1.8 Tips and Best Practices", " Chapter 1 Data Import This chapter covers importing NULISAseq data from XML files and understanding the data structure. 1.1 The importNULISAseq() Function NULISAseq data is typically stored in XML files, with one file per plate. The importNULISAseq() function reads these files and organizes the data into a structured format. # Path to example XML files included with the package data_dir &lt;- system.file(&quot;extdata&quot;, package = &quot;NULISAseqR&quot;) # Specify which XML files to import (usually multiple plates) xml_files &lt;- file.path( data_dir, c(&quot;INF_Panel_V1_detectability_study_plate01.xml&quot;, &quot;INF_Panel_V1_detectability_study_plate02.xml&quot;) ) # Import XML files data &lt;- importNULISAseq(files = xml_files) 1.2 Understanding the Data Structure The imported data object is a list containing multiple components: # View the top-level structure names(data) #&gt; [1] &quot;runs&quot; &quot;merged&quot; # The merged component contains combined data from all plates names(data$merged) #&gt; [1] &quot;plateID&quot; &quot;fileNames&quot; &quot;ExecutionDetails&quot; &quot;IC&quot; #&gt; [5] &quot;targets&quot; &quot;samples&quot; &quot;qcSample&quot; &quot;qcPlate&quot; #&gt; [9] &quot;detectability&quot; &quot;Data_raw&quot; &quot;aboveLOD&quot; &quot;Data_NPQ_long&quot; #&gt; [13] &quot;Data_NPQ&quot; 1.2.1 Key Components The most important components are: 1.2.1.1 Wide-Format Matrix: data$merged$Data_NPQ This is a matrix where: Rows = protein targets Columns = samples Values = NULISA Protein Quantification (NPQ), a normalized, log2-scale measure of relative protein abundance # Check dimensions of the wide-format matrix dim(data$merged$Data_NPQ) #&gt; [1] 206 192 # Number of proteins: nrow(data$merged$Data_NPQ) #&gt; [1] 206 # Number of samples: ncol(data$merged$Data_NPQ) #&gt; [1] 192 #&gt; Preview of NPQ matrix (first 10 proteins × 10 samples, rounded to 3 digits): 1.2.1.2 Long-Format Data Frame: data$merged$Data_NPQ_long This is a “tidy” format where: One row per protein-sample combination Easier for plotting with ggplot2 Easier for merging with metadata #&gt; Preview of NPQ long data frame (first 20 rows): # Check Long-format dimensions # Total rows nrow(data$merged$Data_NPQ_long) #&gt; [1] 39552 # Total columns ncol(data$merged$Data_NPQ_long) #&gt; [1] 16 # Show column information str(data$merged$Data_NPQ_long) #&gt; tibble [39,552 × 16] (S3: tbl_df/tbl/data.frame) #&gt; $ Panel : Factor w/ 1 level &quot;NULISAseq&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ PlateID : Factor w/ 2 levels &quot;Plate_01&quot;,&quot;Plate_02&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ SampleName : Factor w/ 192 levels &quot;SMI_A1_Donor01_Plate_01&quot;,..: 1 9 11 13 15 17 19 21 23 3 ... #&gt; $ SampleType : Factor w/ 4 levels &quot;IPC&quot;,&quot;NC&quot;,&quot;Sample&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ Target : Factor w/ 207 levels &quot;Activin AB&quot;,&quot;AGER&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ AlamarTargetID : logi [1:39552] NA NA NA NA NA NA ... #&gt; $ LOD : num [1:39552] 12.3 12.3 12.3 12.3 12.3 ... #&gt; $ UnnormalizedCount: int [1:39552] 139 168 130 149 166 236 134 138 175 153 ... #&gt; $ NPQ : num [1:39552] 12.4 12.4 12.1 12.5 12.5 ... #&gt; $ sampleBarcode : Factor w/ 96 levels &quot;285582&quot;,&quot;434032&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ wellRow : Factor w/ 8 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ wellCol : int [1:39552] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ matching : int [1:39552] 1375151 2527201 1363189 1590171 853532 1491973 1088088 1860179 4295345 1363789 ... #&gt; $ non-matching : int [1:39552] 809490 889801 896515 808401 764198 960013 749406 946096 909565 740015 ... #&gt; $ SAMPLE_MATRIX : Factor w/ 2 levels &quot;PLASMA&quot;,&quot;CONTROL&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ sampleID : Factor w/ 192 levels &quot;SMI_A1_Donor01_Plate_01&quot;,..: 1 9 11 13 15 17 19 21 23 3 ... 1.2.1.3 Samples Metadata Data Frame: data$merged$samples This is a “tidy” format where: One row per sample sampleName column corresponds to column names of wide data data$merged$Data_NPQ and SampleName column of long data data$merged$Data_NPQ_long #&gt; Preview of sample data frame (first 20 samples): # Show column information str(data$merged$samples) #&gt; tibble [192 × 11] (S3: tbl_df/tbl/data.frame) #&gt; $ plateID : Factor w/ 2 levels &quot;Plate_01&quot;,&quot;Plate_02&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ plateGUID : Factor w/ 1 level &quot;Plate_1&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ sampleType : Factor w/ 4 levels &quot;IPC&quot;,&quot;NC&quot;,&quot;Sample&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ sampleBarcode: Factor w/ 96 levels &quot;285582&quot;,&quot;434032&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ sampleName : chr [1:192] &quot;SMI_A1_Donor01_Plate_01&quot; &quot;SMI_A2_Donor02_Plate_01&quot; &quot;SMI_A3_Donor03_Plate_01&quot; &quot;SMI_A4_Donor04_Plate_01&quot; ... #&gt; $ wellRow : Factor w/ 8 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ wellCol : num [1:192] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ matching : num [1:192] 1375151 2527201 1363189 1590171 853532 ... #&gt; $ non-matching : num [1:192] 809490 889801 896515 808401 764198 ... #&gt; $ SAMPLE_MATRIX: Factor w/ 2 levels &quot;PLASMA&quot;,&quot;CONTROL&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ sampleID : chr [1:192] &quot;SMI_A1_Donor01_Plate_01&quot; &quot;SMI_A2_Donor02_Plate_01&quot; &quot;SMI_A3_Donor03_Plate_01&quot; &quot;SMI_A4_Donor04_Plate_01&quot; ... 1.2.1.4 Targets Metadata Data Frame: data$merged$targets This is a data frame where: One row per target targetName column corresponds to row names of wide data data$merged$Data_NPQ and Target column of long data data$merged$Data_NPQ_long #&gt; Preview of targets data frame (first 20 targets): # Show column information str(data$merged$targets) #&gt; &#39;data.frame&#39;: 414 obs. of 13 variables: #&gt; $ targetBarcode : chr &quot;7189027_7569675&quot; &quot;1625168_1625168&quot; &quot;1902917_1902917&quot; &quot;14763184_14763184&quot; ... #&gt; $ targetName : chr &quot;Activin AB&quot; &quot;AGER&quot; &quot;AGRP&quot; &quot;ANGPT1&quot; ... #&gt; $ Curve_Quant : chr &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; ... #&gt; $ targetType : chr &quot;target&quot; &quot;target&quot; &quot;target&quot; &quot;target&quot; ... #&gt; $ modifiers : logi NA NA NA NA NA NA ... #&gt; $ hide : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; $ noDetectability : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; $ AlamarTargetID : logi NA NA NA NA NA NA ... #&gt; $ targetDetectability: num 64.8 100 100 100 78.4 ... #&gt; $ targetLOD : num 5037.2 0 72.8 260.3 1745.6 ... #&gt; $ logged_LOD : num 12.3 0 6.21 8.03 10.77 ... #&gt; $ rev_logged_LOD : num 12.3 0 6.21 8.03 10.77 ... #&gt; $ plateID : Factor w/ 2 levels &quot;Plate_01&quot;,&quot;Plate_02&quot;: 1 1 1 1 1 1 1 1 1 1 ... 1.2.1.5 Need More Details? For complete function documentation and additional options of importNULISAseq(), use: ?importNULISAseq This will show: All available parameters Detailed descriptions Return value structure Usage examples 1.2.2 Summary Statistics Get a quick overview of your data: # NPQ value distribution summary(data$merged$Data_NPQ_long$NPQ) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.00 12.83 13.42 13.24 14.10 29.11 # Count missing values n_missing &lt;- sum(is.na(data$merged$Data_NPQ_long$NPQ)) n_total &lt;- nrow(data$merged$Data_NPQ_long) #&gt; #&gt; Missing values: 0 out of 39552 ( 0 %) #&gt; #&gt; Data summary: #&gt; Unique proteins: 206 #&gt; Unique samples: 192 #&gt; Unique plates: 2 1.3 Working with Your Own Data When working with your own XML files: # Option 1: Specify full paths my_xml_files &lt;- c( &quot;/path/to/plate01.xml&quot;, &quot;/path/to/plate02.xml&quot; ) my_data &lt;- importNULISAseq(files = my_xml_files) # Option 2: Import all XML files in a directory data_dir &lt;- &quot;/path/to/my/data/&quot; xml_files &lt;- list.files(data_dir, pattern = &quot;\\\\.xml$&quot;, full.names = TRUE) my_data &lt;- importNULISAseq(files = xml_files) 1.4 Loading Metadata Metadata provides critical information about your samples (disease status, demographics, experimental conditions, etc.). # Read metadata from CSV metadata &lt;- read_csv( system.file(&quot;extdata&quot;, &quot;Alamar_NULISAseq_Detectability_metadata.csv&quot;, package = &quot;NULISAseqR&quot;) ) # Prepare metadata with proper factor levels metadata &lt;- metadata %&gt;% mutate( # Set factor levels in meaningful order (reference group first) disease_type = factor( disease_type, levels = c(&quot;normal&quot;, &quot;inflam&quot;, &quot;cancer&quot;, &quot;kidney&quot;, &quot;metab&quot;, &quot;neuro&quot;) ), # Ensure numeric variables are properly typed age = as.numeric(age) ) 1.4.1 Metadata Structure Your metadata should contain: Sample identifiers: Must match SampleName column in the XML data data$merged$Data_NPQ_long or data$merged$samples Experimental variables: Disease type, treatment, etc. Covariates: Age, sex, batch, etc. Optional: Sample matrix type, collection date, etc. #&gt; Preview of metadata (first 20 targets): # Check variable types str(metadata) #&gt; tibble [167 × 7] (S3: tbl_df/tbl/data.frame) #&gt; $ PlateID : chr [1:167] &quot;Plate_01&quot; &quot;Plate_01&quot; &quot;Plate_01&quot; &quot;Plate_01&quot; ... #&gt; $ SampleID : chr [1:167] &quot;SMI_A1_Donor01&quot; &quot;SMI_A2_Donor02&quot; &quot;SMI_A3_Donor03&quot; &quot;SMI_A5_Donor05&quot; ... #&gt; $ SampleMatrix: chr [1:167] &quot;Plasma&quot; &quot;Plasma&quot; &quot;Plasma&quot; &quot;Plasma&quot; ... #&gt; $ sex : chr [1:167] &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; ... #&gt; $ age : num [1:167] 38 54 52 46 70 37 80 52 60 57 ... #&gt; $ disease_type: Factor w/ 6 levels &quot;normal&quot;,&quot;inflam&quot;,..: 1 3 1 1 3 1 2 1 1 5 ... #&gt; $ SampleName : chr [1:167] &quot;SMI_A1_Donor01_Plate_01&quot; &quot;SMI_A2_Donor02_Plate_01&quot; &quot;SMI_A3_Donor03_Plate_01&quot; &quot;SMI_A5_Donor05_Plate_01&quot; ... # Summary of key variables table(metadata$disease_type) Example output: disease_type normal inflam cancer kidney metab neuro 20 16 18 14 15 13 # Cross-tabulation of disease type by sex table(metadata$disease_type, metadata$sex) Example output: F M normal 9 11 inflam 8 8 cancer 10 8 kidney 7 7 metab 8 7 neuro 6 7 1.5 Merging Data with Metadata Combining expression data with metadata enables integrated analysis: # Merge using long-format data data_long &lt;- data$merged$Data_NPQ_long %&gt;% left_join(metadata, by = c(&quot;SampleName&quot;, &quot;PlateID&quot;)) #&gt; First 20 rows of merged data: # Verify the merge # Original NPQ data rows: nrow(data$merged$Data_NPQ_long) #&gt; [1] 39552 # Merged data rows nrow(data_long) #&gt; [1] 39552 cat(&quot; Match:&quot;, nrow(data_long) == nrow(data$merged$Data_NPQ_long), &quot;\\n\\n&quot;) #&gt; Match: TRUE # Show what metadata columns were added new_cols &lt;- setdiff(names(data_long), names(data$merged$Data_NPQ_long)) # Metadata columns added paste(new_cols, collapse = &quot;, &quot;) #&gt; [1] &quot;SampleID, SampleMatrix, sex, age, disease_type&quot; # Check for any unmatched samples unmatched_data &lt;- anti_join( data$merged$Data_NPQ_long, metadata, by = c(&quot;SampleName&quot;, &quot;PlateID&quot;) ) unmatched_meta &lt;- anti_join( metadata, data$merged$Data_NPQ_long, by = c(&quot;SampleName&quot;, &quot;PlateID&quot;) ) # Merge quality check # Samples in data but not in metadata: length(unique(unmatched_data$SampleName)) #&gt; [1] 25 # Samples in metadata but not in data: length(unique(unmatched_meta$SampleName)) #&gt; [1] 0 if (length(unique(unmatched_data$SampleName)) &gt; 0) { cat(&quot;\\n⚠ Warning: Some samples lack metadata:\\n&quot;) print(unique(unmatched_data$SampleName)) } #&gt; #&gt; ⚠ Warning: Some samples lack metadata: #&gt; [1] SMI_A4_Donor04_Plate_01 SMI_A10_Donor10_Plate_01 #&gt; [3] SMI_A12_IPC_rep01_Plate_01 SMI_B12_IPC_rep02_Plate_01 #&gt; [5] SMI_C6_Donor26_Plate_01 SMI_C12_SPC_rep03 #&gt; [7] SMI_D12_SC_rep04_Plate_01 SMI_E10_Donor50_Plate_01 #&gt; [9] SMI_E12_NTC_rep01_Plate_01 SMI_F12_NTC_rep02_Plate_01 #&gt; [11] SMI_G5_Donor65_Plate_01 SMI_G12_NTC_rep03_Plate_01 #&gt; [13] SMI_H6_Donor76_Plate_01 SMI_H12_NTC_rep04_Plate_01 #&gt; [15] SMI_A12_IPC_rep01_Plate_02 SMI_B1_Donor11_Plate_02 #&gt; [17] SMI_B12_IPC_rep02_Plate_02 SMI_C1_Donor21_Plate_02 #&gt; [19] SMI_C12_SC_rep03 SMI_D12_SC_rep04_Plate_02 #&gt; [21] SMI_E12_NTC_rep01_Plate_02 SMI_F10_Donor60_Plate_02 #&gt; [23] SMI_F12_NTC_rep02_Plate_02 SMI_G12_NTC_rep03_Plate_02 #&gt; [25] SMI_H12_NTC_rep04_Plate_02 #&gt; 192 Levels: SMI_A1_Donor01_Plate_01 ... SMI_H9_Donor79_Plate_02 1.6 Filtering Samples Often you’ll want to analyze a subset of samples: # Example: Filter for plasma samples only sample_list &lt;- metadata %&gt;% filter(SampleMatrix == &quot;Plasma&quot;) %&gt;% pull(SampleName) # Number of plasma samples length(sample_list) #&gt; [1] 151 # Subset the expression matrix data_plasma &lt;- data$merged$Data_NPQ[, sample_list] dim(data_plasma) #&gt; [1] 206 151 1.7 Complete Import Workflow Here’s a complete example putting it all together: # 1. Import XML data data_dir &lt;- system.file(&quot;extdata&quot;, package = &quot;NULISAseqR&quot;) xml_files &lt;- list.files(data_dir, pattern = &quot;\\\\.xml$&quot;, full.names = TRUE) data &lt;- importNULISAseq(files = xml_files) # 2. Load metadata metadata &lt;- read_csv( system.file(&quot;extdata&quot;, &quot;metadata.csv&quot;, package = &quot;NULISAseqR&quot;) ) %&gt;% mutate(disease_type = factor(disease_type, levels = c(&quot;normal&quot;, &quot;disease&quot;))) # 3. Merge data with metadata data_long &lt;- data$merged$Data_NPQ_long %&gt;% left_join(metadata, by = &quot;SampleName&quot;) # 4. Filter to samples of interest sample_list &lt;- metadata %&gt;% filter(SampleMatrix == &quot;Plasma&quot;) %&gt;% pull(SampleName) ## Ready for analysis! nrow(data$merged$Data_NPQ) length(sample_list) 1.8 Tips and Best Practices File Organization Keep XML files in a dedicated directory Use consistent naming conventions Document which files correspond to which experiments Metadata Management Store metadata in CSV format for easy editing Include all relevant variables from the start Use meaningful, consistent variable names Set factor levels explicitly (don’t rely on alphabetical order) Quality Checks Verify sample names match between XML and metadata Check for missing values Confirm data dimensions make sense Common Issues Mismatched names: Ensure sample names in XML match metadata exactly Factor levels: Always set reference level first for interpretable results Missing metadata: Filter out samples without metadata before analysis Continue to: Chapter 2: Quality Control "],["quality-control.html", "Chapter 2 Quality Control 2.1 Why Quality Control Matters 2.2 Automated QC Report 2.3 QC Report Structure 2.4 Summary of QC Thresholds 2.5 Manual QC Checks 2.6 Best Practices 2.7 Complete QC Workflow", " Chapter 2 Quality Control Quality control is essential before proceeding with statistical analysis. This chapter covers generating QC reports and interpreting quality control metrics at the plate, run, sample, and target levels. 2.1 Why Quality Control Matters Quality control helps identify: Technical issues with sample processing Outlier samples Problems with specific protein targets Batch effects Overall data quality and reliability Always perform QC before analysis! Problems caught early save time and ensure valid results. 2.2 Automated QC Report NULISAseqR includes a built-in QC report template that generates comprehensive quality metrics across multiple levels: plate/run, sample, and target. # Specify output directory out_dir &lt;- tempdir() # Or use your preferred directory ## See Chapter 1 for loading data # # data_dir &lt;- system.file(&quot;extdata&quot;, package = &quot;NULISAseqR&quot;) # # xml_files &lt;- file.path( # data_dir, # c(&quot;INF_Panel_V1_detectability_study_plate01.xml&quot;, # &quot;INF_Panel_V1_detectability_study_plate02.xml&quot;) # ) render_QC_report( output_filename = &quot;Detectability_Study_NULISAseq_QC_report.html&quot;, output_dir = out_dir, study_name = &quot;NULISAseq QC Report - Detectability Study&quot;, assayName = &quot;Inflammation Panel 250&quot;, dataDir = dataDir, xml_files = basename(xml_files), report_type = &quot;webApp&quot; ) # View the report browseURL(file.path(out_dir, &quot;Detectability_Study_NULISAseq_QC_report.html&quot;)) 2.3 QC Report Structure The automated QC report is organized into several key sections: 2.3.1 Plate Layout Visual representation of sample placement on 96-well plates showing: Sample positions and identifiers Control sample locations (NC, IPC, SC) Plate ID assignment and verification 2.3.2 Run Summary The report provides detailed summaries for overall run summary and each type of control samples: 2.3.2.1 Interal Controls (IC) An exogenous reporter protein added to each well for well to well normalization and assessing the uniformity of the assay run. 2.3.2.2 Inter-Plate Controls (IPC) Independent pooled plasma controls used for normalization between plates and precision assessment. 2.3.2.3 Sample Controls (SC) Pooled plasma source different from IPCs, used to assess run suitability and overall intra-plate and inter-plate CV. 2.3.2.4 Negative Controls (NC) Assay buffer used to determine Limit of Detection (LOD) for each target for each plate and assess overall assay performance. Quality Control Metrics The QC report evaluates quality at three hierarchical levels: Plate/Run QC Sample QC Target Detectability 2.3.3 Plate/Run QC Plate-level QC metrics assess the overall quality of each assay run. These are evaluated on both unnormalized (raw) and IPC-normalized data. Plate-level QC metrics assess the overall quality of each assay run. These are evaluated on both unnormalized (raw) and IPC-normalized data. Key Plate QC Criteria 1. IC CV (Internal Control Coefficient of Variation) Definition: CV of internal control Parseable Matching reads across all wells Threshold: Maximum 25% Purpose: Assesses technical variability within a plate Interpretation: ✓ CV &lt; 25%: Good technical reproducibility ✗ CV ≥ 25%: High technical variation, investigate plate processing 2. IPC CV (Inter-Plate Control CV) Definition: CV of Parseable Matching reads across all IPC samples Threshold: Maximum 25% Purpose: Evaluates consistency of control samples Interpretation: ✓ CV &lt; 25%: IPCs performing consistently ✗ CV ≥ 25%: IPC variability too high, may affect normalization 3. IPC Target CV Definition: Median CV of all IPC targets across replicates Threshold: Maximum 10% Purpose: Assesses reproducibility at the protein target level Interpretation: ✓ Median CV &lt; 10%: Excellent target-level precision ✗ Median CV ≥ 10%: Some targets showing poor reproducibility 4. Run Detectability Definition: Percentage of targets that are detectable (&gt; 50% of samples above LOD) Threshold: Minimum 90% Purpose: Overall assessment of assay sensitivity Interpretation: ✓ Detectability ≥ 90%: Most targets detecting well ✗ Detectability &lt; 90%: Poor overall detection, check sample quality or assay conditions 5. Reads (Total Parseable Matching Reads) Definition: Minimum number of reads required per plate Threshold: Minimum 100,000,000 reads Purpose: Ensures sufficient sequencing depth Interpretation: ✓ Reads ≥ 100M: Adequate sequencing coverage ✗ Reads &lt; 100M: Insufficient depth, may need re-sequencing 2.3.4 Sample QC Sample-level QC identifies individual samples that may have quality issues. Key Sample QC Criteria 1. Sample Detectability Definition: Percentage of targets with reads above LOD for each sample Thresholds (vary by sample type): Plasma: Minimum 90% Serum: Minimum 90% CSF: Minimum 70% Urine: Minimum 65% Cell culture: Minimum 30% NHP plasma: Minimum 55% NHP serum: Minimum 55% NHP CSF: Minimum 35% Dried blood spot: Minimum 75% Control: Minimum 90% Other: Minimum 0% Purpose: Identifies samples with low overall protein detection Interpretation: ✓ Detectability above threshold: Sample has adequate protein levels ✗ Detectability below threshold: Sample may be degraded, diluted, or have insufficient protein 2. IC Median (Internal Control Median) Definition: Sample IC reads relative to the plate median Threshold: Within ±40% of plate median Purpose: Identifies samples with abnormal internal control performance Interpretation: ✓ IC Median within ±40%: Sample processed normally ✗ IC Median outside ±40%: Potential pipetting error, reagent issue, or sample quality problem 3. IC Reads per Sample Definition: Minimum number of reads required per sample for internal control Threshold: Minimum 1000 reads Purpose: Ensures adequate internal control signal Interpretation: ✓ Reads ≥ 1000: Sample has adequate IC signal ✗ Reads &lt; 1000: Sample has insufficient IC signal, may affect normalization 4. Total Reads per Sample Definition: inimum number of reads required per sample Threshold: Minimum 500,000 reads Purpose: Ensures sufficient sequencing depth per sample Interpretation: ✓ Reads ≥ 500K: Sample has adequate sequencing coverage ✗ Reads &lt; 500K: Sample has low signal, may need re-sequencing The QC report includes several plots for sample assessment: Detectability Plot: Shows the percentage of targets detected for each sample (Figures 2.1 and 2.2) IC Median Plot: Displays internal control performance relative to plate median (Figures 2.1 and 2.2) Reads Distribution: Shows the distribution of total reads across samples (Figures 2.1 and 2.2) Sample Boxplots: Display normalized expression distributions for each sample (Figures 2.3 and 2.4) These visualizations help identify: Samples with low protein detection Samples with abnormal internal control performance Outlier samples requiring further investigation Overall quality and consistency within and between plates Sample QC Plots: Figure 2.1: Sample QC plots for Plate 1 Figure 2.2: Sample QC plots for Plate 2 Sample Boxplots After Normalization show the distribution of protein expression across samples after normalization with internal controls: Figure 2.3: Sample boxplots for Plate 1 after normalization Figure 2.4: Sample boxplots for Plate 2 after normalization Interpreting Sample Boxplots: After IC normalization, sample boxplots should show similar median values and distributions. Outlier samples with shifted or compressed distributions may indicate quality issues. 2.3.5 Target QC Target-level QC assesses the performance of individual protein markers. Key Target QC Metrics 1. Target Detectability Definition: Percentage of samples in which a target is detected (above LOD) Recommendation: Targets with &lt; 50% detectability should be carefully evaluated Purpose: Identifies poorly performing or low-abundance targets 2. Limit of Detection (LOD) Definition: Minimum signal level that can be reliably distinguished from background Calculation: Calculated from negative control (NC) samples, mean + 3 standard deviations of normalized counts of NCs Usage: Values below LOD should be excluded from CV calculations Consider filtering targets with high proportion of values below LOD Visualized in target detectability boxplots relative to LOD LOD of specific targets: Most LODs for the targets in the panel are the lower limit of detection. There are some exception: High-abundance targets: Inflammation Panel: CRP and KNG1 in Human plasma and CSF samples CNS Panel: APOE and CRP in Human plasma and CSF samples Mouse Panel: Crp in Mouse plasma and serum samples These targets have very high endogenous levels in the samples. In order to accommodate these targets into our panel together with other lower abundance targets, we use special tuning strategies and algorithms to perform sample measurements. As a result, the listed LOD values for these targets are the upper limit of detection. Detectability is not a concern given the high level of these targets and the NPQ values can still be used for secondary data analysis. For novel sample types other than listed sample matrices, however, the designed algorithm may not be applicable depending on the abundance levels of the analyte, and the NPQ will not be reported for other sample types. 2.3.6 Coefficient of Variation (CV) CV analysis assesses precision within and between plates: 2.3.6.1 Intra-Plate CV Measures variability within a single plate using control samples: Key features: CV calculated for SC and IPC samples within each plate Separate analysis for unnormalized and IC-normalized data Excludes values below LOD 2.3.6.2 Inter-Plate CV Measures variability across multiple plates, assessing batch effects: The inter-plate CV plot demonstrates: Effectiveness of normalization strategies Reduction in CV after IC normalization Additional benefit of IPC normalization 2.3.7 Plate Effect Assessment Plate effects occur when systematic technical variation between assay plates affect the measured protein abundance, potentially confounding biological signals. The plate effect assessment uses statistical methods to quantify how much variability in each target’s measurements can be attributed to each plate, helping identify targets that may require plate-based normalization or careful interpretation in downstream analyses. 2.3.7.1 Plate Effect QC Summary The plate-level assessment evaluates whether each plate shows systematic bias across multiple targets: Interpreting plate-level results: Pass: Plate shows acceptable consistency with other plates Warning: Plate may have systematic technical issues affecting multiple targets Plates with warnings should be investigated for pre-analytical or technical issues 2.3.7.2 Plate Effect ICC Analysis The Intra-Class Correlation (ICC) quantifies the proportion of total variance attributable to plate effects for each target: The ICC is calculated using a linear mixed-effects model with plate ID as a random effect: \\[ICC = \\frac{\\sigma^2_{plate}}{\\sigma^2_{plate} + \\sigma^2_{residual}} \\times 100\\] Interpreting ICC values: ICC &gt; 10% (highlighted in red): Substantial plate effect that may require normalization or statistical adjustment ICC &lt; 10%: Plate effects are minimal and unlikely to confound biological interpretation Targets with high ICC should be interpreted cautiously in downstream analyses 2.3.7.3 Plate Effects Summary The summary table reports: n % sig targets: Percentage of targets showing significant plate effects (combining statistical significance with practical significance across multiple plates) sig targets: Specific targets with plate effect warnings n % low IPC reads: Targets with insufficient internal control signal n % low sample reads: Targets with low sample signal, which may be more susceptible to technical variation Common causes of plate effects: Batch-to-batch reagent variation Temporal drift in instrument performance Environmental conditions during sample processing Sample-to-plate assignment that correlates with biological variables When plate effects are detected, consider including plate as a covariate in statistical models or using batch correction methods before downstream analysis. 2.4 Summary of QC Thresholds Table 2.1: Summary of NULISAseq QC thresholds and their purposes Level Metric Threshold Purpose Plate/Run IC CV ≤ 25% Technical reproducibility Plate/Run IPC CV ≤ 25% Control consistency Plate/Run IPC Target CV ≤ 10% Target-level precision Plate/Run Run Detectability ≥ 90% Overall sensitivity Plate/Run Total Reads ≥ 100M Sequencing depth Sample Detectability (plasma/serum) ≥ 90% Sample protein levels Sample Detectability (CSF) ≥ 70% Sample protein levels Sample IC Median ±40% of plate median Processing consistency Target Detectability &gt; 50% samples Target performance Target Intra-plate CV &lt; 10% (ideal) Within-plate precision Target Inter-plate CV &lt; 15% (after norm) Cross-plate consistency Note: Thresholds may be adjusted based on specific study requirements and sample types. Always document any deviations from standard thresholds. 2.5 Manual QC Checks In addition to the automated report, performing manual QC checks provides deeper insights into your data quality and helps you make informed decisions about filtering strategies. 2.5.1 Check for Missing Data Missing data for high-abundance targets: Certain targets use specialized normalization algorithms optimized for specific sample types. NPQ values for these targets may be missing in non-validated sample matrices: Inflammation Panel: CRP and KNG1 are only reported for human plasma and CSF samples CNS Panel: APOE and CRP are only reported for human plasma and CSF samples Mouse Panel: Crp is only reported for mouse plasma and serum samples These proteins have exceptionally high endogenous levels that require matrix-specific tuning. If you’re analyzing novel sample types (e.g., tissue lysates, saliva, urine), the normalization algorithm may not be applicable, and NPQ values will not be generated for these specific targets. # Count missing values missing_by_sample &lt;- colSums(is.na(data$merged$Data_NPQ)) missing_by_protein &lt;- rowSums(is.na(data$merged$Data_NPQ)) # Samples with high missingness high_missing_samples &lt;- names(missing_by_sample[missing_by_sample &gt; 0.1 * nrow(data$merged$Data_NPQ)]) cat(&quot;Samples with &gt;10% missing:&quot;, length(high_missing_samples), &quot;\\n&quot;) # Proteins with high missingness high_missing_proteins &lt;- names(missing_by_protein[missing_by_protein &gt; 0.1 * ncol(data$merged$Data_NPQ)]) cat(&quot;Proteins with &gt;10% missing:&quot;, length(high_missing_proteins), &quot;\\n&quot;) 2.5.2 Low Detectability Targets Why filter by detectability? Low-detectability targets present several analytical challenges: Non-normal distributions: In typical sample types, targets with &lt; 50% detectability often have bimodal or highly skewed distributions due to a mixture of detected values and LOD measurements Statistical power: Proteins detected in only a minority of samples provide limited power for detecting biological differences Increased false positives: Imputation methods for missing data can introduce artifacts when missingness is too high Biological interpretation: Proteins rarely detected may be below biologically relevant concentrations or unstable in the sample type Recommended detectability thresholds: For standard sample matrices (plasma, serum, CSF), we recommend: ≥ 50% detectability: Minimum threshold for robust statistical analysis Ensures data approximate normal distributions after log-transformation Provides adequate power for differential expression analysis Reduces artifacts from missing data imputation For exploratory analyses or novel sample types: All targets (0% threshold): Acceptable for initial data exploration or when you’re specifically interested in low-abundance proteins &gt; 0% detectability: Removes only targets with zero detection, useful for maximizing coverage in discovery studies Sample-type specific: Urine (≥ 65%), cell culture (≥ 30%), dried blood spots (≥ 75%) — see Section Sample Detectability for full list # Remove targets below 50% detectability cutoff target_passed_detect &lt;- data$merged$detectability %&gt;% filter(`plasma (n = 176)` &gt; 50) %&gt;% pull(Target) data_filtered &lt;- data$merged$Data_NPQ_long %&gt;% filter(Target %in% target_passed_detect) cat(&quot;Removed&quot;, nrow(data$merged$Data_NPQ) - length(target_passed_detect), &quot;proteins\\n&quot;) 2.5.3 Calculate Targets Detectability by Subgroups In studies with diverse sample types or conditions, consider calculating detectability within relevant subgroups: # Example: Calculate detectability by disease status detectability_by_disease &lt;- data_long %&gt;% filter(SampleType == &quot;Sample&quot;, !is.na(disease_type)) %&gt;% mutate(above_LOD = if_else(Target %in% c(&quot;CRP&quot;, &quot;KNG1&quot;), # High-abundance targets !is.na(NPQ), # For CRP/KNG1: TRUE if NPQ is not NA NPQ &gt; LOD) # For others: TRUE if NPQ &gt; LOD ) %&gt;% group_by(disease_type) %&gt;% mutate(matrix_treatment_count = n_distinct(SampleName)) %&gt;% ungroup() %&gt;% group_by(Target, disease_type, matrix_treatment_count) %&gt;% summarize( detectability = round(sum(above_LOD, na.rm = TRUE) / n() * 100, 1), .groups = &quot;drop&quot; ) %&gt;% mutate( Disease_Type = paste0(disease_type, &quot; (n = &quot;, matrix_treatment_count, &quot;)&quot;) ) %&gt;% # Convert to wide format select(Target, Disease_Type, detectability) %&gt;% pivot_wider( names_from = Disease_Type, values_from = detectability, values_fill = NA ) Interpreting the table: Each column represents a different subgroup with its sample size. Values show the detectability of each disease type subgroup (percentage of samples within that subgroup where each target was detected above its LOD). 2.5.4 Batch Effect Correction If batch effects are present, consider: Intensity Normalization Using bridge samples for normalization 2.6 Best Practices Documentation Save QC reports with date stamps for traceability Document all filtering decisions: Which samples/targets were removed and why Keep notes on QC thresholds: Record any deviations from standard thresholds Track re-runs: If plates are re-processed, document reasons and outcomes Consistency Apply same QC criteria across studies for comparability Pre-define QC thresholds before analysis to avoid bias Document SOP: Standard operating procedure for QC decisions Collaboration Consult wet lab team: Especially for borderline samples or unusual patterns Review control samples: IPC and SC performance can indicate systematic issues Discuss batch effects: Coordinate on plate layout and run order to minimize batch effects When in Doubt Be conservative: More stringent QC is better than too lenient Use biological replicates: For validation of questionable samples Seek expert input: Consult with Alamar team 2.7 Complete QC Workflow # 1. Generate automated QC report render_QC_report( output_filename = &quot;Detectability_Study_NULISAseq_QC_report.html&quot;, output_dir = out_dir, study_name = &quot;NULISAseq QC Report - Detectability Study&quot;, assayName = &quot;Inflammation Panel 250&quot;, dataDir = dataDir, xml_files = basename(xml_files), report_type = &quot;webApp&quot; ) # 2. Filter low-quality samples sample_qc_warning &lt;- data$merged$qcSample %&gt;% filter(status == &quot;TRUE&quot;) ## examine sample boxplot distributions after normalization to identify samples with issues ## examine further with heatmap and pca in next Chapter # 3. Filter low-detection proteins target_passed_detect &lt;- data$merged$detectability %&gt;% filter(`plasma (n = 176)` &gt; 50) %&gt;% pull(Target) data_filtered &lt;- data$merged$Data_NPQ_long %&gt;% filter(Target %in% target_passed_detect) # 4. Create filtered dataset data_filtered_wide &lt;- data$merged$Data_NPQ[target_passed_detect,] # 5. (Optional) Update metadata to match metadata_qc &lt;- metadata %&gt;% filter(SampleName %in% sample_qc_warning$SampleName) cat(&quot;\\nQC Summary:\\n&quot;) cat(&quot;Original: &quot;, nrow(data$merged$Data_NPQ), &quot;targets,&quot;, ncol(data$merged$Data_NPQ), &quot;samples\\n&quot;) cat(&quot;After QC:&quot;, nrow(data_filtered_wide), &quot;targets,&quot;, ncol(data_filtered_wide), &quot;samples\\n&quot;) Continue to: Chapter 3: Visualization "],["visualization.html", "Chapter 3 Visualization 3.1 Why Visualize? 3.2 Heatmaps 3.3 Principal Component Analysis (PCA) 3.4 Custom Visualizations with ggplot2 3.5 Saving Plots 3.6 Visualization Best Practices 3.7 Complete Visualization Workflow", " Chapter 3 Visualization Visualizing proteomic data helps identify patterns, outliers, and biological signals. This chapter covers the main visualization methods in NULISAseqR. 3.1 Why Visualize? Data visualization helps you: Identify sample clusters and outliers Assess data quality visually Detect batch effects Explore biological patterns Communicate findings effectively 3.2 Heatmaps Heatmaps show protein expression patterns across samples with hierarchical clustering. The generate_heatmap() function: Scales data by protein (z-scores): centers and standardizes each protein’s values Clusters similar samples and proteins together Annotates samples with metadata (disease type, sex, age, etc.) Uses ComplexHeatmap with automatic RColorBrewer color palettes See complete function documentation and additional options, use ?generate_heatmap(). 3.2.1 Basic Heatmap heatmap1 &lt;- generate_heatmap( data = data$merged$Data_NPQ, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, row_fontsize = 5 ) 3.2.2 Heatmap with Annotations Add sample annotations to highlight key variables: heatmap2 &lt;- generate_heatmap( data = data$merged$Data_NPQ, plot_title = &quot;NULISAseq Detectability Study Heatmap&quot;, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, annotate_sample_by = c(&quot;disease_type&quot;, &quot;sex&quot;, &quot;age&quot;), row_fontsize = 5 ) 3.2.3 Understanding the Heatmap The heatmap shows: Rows: Protein targets Columns: Samples Colors: Expression levels (typically red = high, blue = low) Dendrograms: Hierarchical clustering Top: Sample relationships Left: Protein relationships Annotation bars: Sample characteristics 3.2.4 Interpreting Clusters Look for: Sample clusters by biology: Samples with similar disease states clustering together Protein clusters: Co-expressed protein groups Outlier samples: Samples far from their expected group Batch effects: Clustering by plate/batch rather than biology 3.3 Principal Component Analysis (PCA) PCA reduces high-dimensional data to its main components of variation. The generate_pca() function: Scales data by protein (z-scores): centers and standardizes each protein’s values Performs PCA using PCAtools to identify major sources of variation Creates biplot showing sample relationships in PC space Annotates samples with metadata colors and shapes Uses automatic RColorBrewer color palettes or custom colors See complete function documentation and additional options, use ?generate_pca(). 3.3.1 PCA with Multiple Visual Encodings Color by one variable, shape by another: pca2 &lt;- generate_pca( data = data$merged$Data_NPQ, plot_title = &quot;NULISAseq Detectability Study PCA&quot;, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, annotate_sample_by = &quot;disease_type&quot;, # Color shape_by = &quot;sex&quot; # Shape ) 3.3.2 Understanding PCA Plots Axes PC1 (x-axis): Captures the most variation in the data PC2 (y-axis): Captures the second most variation % variance: Shows how much variation each PC explains Interpretation Tight clusters: Samples with similar expression profiles Separation: Groups with distinct expression patterns Outliers: Samples far from the main cluster Batch effects: If clustering by technical variables (plate, batch), indicates unwanted variation What to Look For Good signs: ✓ Samples cluster by biological group ✓ PC1/PC2 explain substantial variance (&gt;20% combined) ✓ Clear separation between conditions Warning signs: ✗ Clustering by technical variables (batch, plate) ✗ Outliers far from their group ✗ No visible separation despite known biology 3.4 Custom Visualizations with ggplot2 For exploratory analysis beyond heatmaps and PCA, create custom plots with ggplot2. # setting ggplot theme # custom ggplot theme custom_theme &lt;- theme_bw() + theme( panel.background = element_rect(fill=&#39;white&#39;), plot.background = element_rect(fill=&#39;transparent&#39;, color = NA), legend.background = element_rect(fill=&#39;transparent&#39;), legend.key = element_rect(fill = &quot;transparent&quot;, color = NA) ) theme_set(custom_theme) showtext::showtext_auto() ## able to output beta symbol and other special character in pdf 3.4.1 NPQ Distribution - Histogram Check the overall distribution of NPQ values across all samples and proteins: Check the distribution of NPQ values across all samples for each protein: 3.4.2 NPQ Distribution by Group - Density Plot Compare NPQ distributions between groups to check for systematic differences: 3.4.3 Single Protein Across Groups Examine how a single protein varies across conditions: # Plot a specific protein across groups protein_of_interest &lt;- &quot;IL6&quot; data_long %&gt;% filter(Target == protein_of_interest, SampleName %in% sample_list) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_jitter(width = 0.2, alpha = 0.7, size = 1) + geom_boxplot(alpha = 0.3, outlier.shape = NA) + labs(title = paste(protein_of_interest, &quot;Expression&quot;), x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme(legend.position = &quot;none&quot;) 3.4.4 Multiple Proteins Across Groups Compare several proteins simultaneously using facets: # Select top 6 proteins by variance protein_variance &lt;- apply(data$merged$Data_NPQ[, sample_list], 1, var, na.rm = TRUE) top_proteins &lt;- names(sort(protein_variance, decreasing = TRUE)[1:6]) # Plot multiple proteins data_long %&gt;% filter(Target %in% top_proteins, SampleName %in% sample_list) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_boxplot(alpha = 0.7, outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.3, size = 1) + facet_wrap(~Target, scales = &quot;free_y&quot;, ncol = 3) + labs(title = &quot;Top Variable Proteins Across Disease Groups&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 1), strip.text = element_text(size = 16, face = &quot;bold&quot;)) 3.4.5 Protein-Protein Correlation # Select two proteins to compare protein1 &lt;- &quot;IL6&quot; protein2 &lt;- &quot;TNF&quot; plot_data &lt;- data_long %&gt;% filter(Target %in% c(protein1, protein2), SampleName %in% sample_list) %&gt;% select(SampleName, Target, NPQ, disease_type) %&gt;% pivot_wider(names_from = Target, values_from = NPQ) ggplot(plot_data, aes(x = .data[[protein1]], y = .data[[protein2]], color = disease_type)) + geom_point(size = 1, alpha = 0.7) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + labs(title = paste(protein1, &quot;vs&quot;, protein2), x = paste(protein1, &quot;NPQ&quot;), y = paste(protein2, &quot;NPQ&quot;), color = &quot;Disease Type&quot;) 3.5 Saving Plots Both generate_heatmap() and generate_pca() have built-in options to save plots directly. Save Heatmap # Automatically saves to file generate_heatmap( data = data$merged$Data_NPQ, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, annotate_sample_by = c(&quot;disease_type&quot;, &quot;sex&quot;), output_dir = &quot;figures&quot;, # Where to save plot_name = &quot;heatmap.pdf&quot;, # Filename (PDF, PNG, JPG, SVG) plot_title = &quot;Expression Heatmap&quot;, plot_width = 10, # Width in inches plot_height = 8 # Height in inches ) Supported formats: PDF, PNG, JPG, SVG (determined by file extension) Save PCA # Automatically saves to file generate_pca( data = data$merged$Data_NPQ, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, annotate_sample_by = &quot;disease_type&quot;, output_dir = &quot;figures&quot;, # Where to save plot_name = &quot;pca.png&quot;, # Filename (PDF, PNG, JPG, SVG) plot_title = &quot;PCA Plot&quot;, plot_width = 8, # Width in inches plot_height = 6 # Height in inches ) Supported formats: PDF, PNG, JPG, SVG (determined by file extension) Save ggplot Objects # Create plot p &lt;- data_long %&gt;% filter(SampleName %in% sample_list) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_boxplot() # Save with ggsave ggsave(&quot;figures/boxplot.pdf&quot;, p, width = 8, height = 6) ggsave(&quot;figures/boxplot.png&quot;, p, width = 8, height = 6, dpi = 300) 3.6 Visualization Best Practices Before Plotting Remove low-quality samples/proteins or outliers Decide on sample subset (if analyzing only certain samples) Choose appropriate color schemes (consider color-blind friendly palettes) Design Principles Use clear, descriptive titles Label axes properly with units Include legends when needed Choose appropriate plot types for your data Interpretation Always view plots in context of experimental design Look for biological signals first, then technical artifacts Compare results across multiple visualization methods Document interesting patterns for follow-up Common Issues ✗ Plotting too many groups (hard to distinguish) ✗ Poor color choices (e.g., red/green for color-blind viewers) ✗ Overplotting (too many points overlapping) ✗ Missing axis labels or legends 3.7 Complete Visualization Workflow # Set up output directory out_dir &lt;- &quot;figures&quot; dir.create(out_dir, showWarnings = FALSE) # Filter to samples of interest sample_list &lt;- metadata %&gt;% filter(SampleMatrix == &quot;Plasma&quot;) %&gt;% pull(SampleName) # 1. Generate heatmap with annotations generate_heatmap( data = data$merged$Data_NPQ, output_dir = out_dir, plot_name = &quot;expression_heatmap.pdf&quot;, plot_title = &quot;Protein Expression Heatmap&quot;, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, annotate_sample_by = c(&quot;disease_type&quot;, &quot;sex&quot;, &quot;age&quot;), plot_width = 12, plot_height = 10 ) # 2. Generate PCA plot generate_pca( data = data$merged$Data_NPQ, output_dir = out_dir, plot_name = &quot;pca_plot.pdf&quot;, plot_title = &quot;PCA of Protein Expression&quot;, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = sample_list, annotate_sample_by = &quot;disease_type&quot;, shape_by = &quot;sex&quot;, plot_width = 8, plot_height = 6 ) # 3. NPQ distribution histogram p_hist &lt;- data_long %&gt;% filter(SampleName %in% sample_list) %&gt;% ggplot(aes(x = NPQ)) + geom_histogram(bins = 50, fill = &quot;steelblue&quot;, alpha = 0.7) + labs(title = &quot;Distribution of NPQ Values&quot;, x = &quot;NPQ&quot;, y = &quot;Count&quot;) ggsave(file.path(out_dir, &quot;npq_histogram.pdf&quot;), p_hist, width = 7, height = 5) # 4. NPQ density by disease type p_density &lt;- data_long %&gt;% filter(SampleName %in% sample_list) %&gt;% ggplot(aes(x = NPQ, fill = disease_type)) + geom_density(alpha = 0.5) + labs(title = &quot;NPQ Distribution by Disease Type&quot;, x = &quot;NPQ&quot;, y = &quot;Density&quot;, fill = &quot;Disease Type&quot;) ggsave(file.path(out_dir, &quot;npq_density.pdf&quot;), p_density, width = 8, height = 5) # 5. Single protein boxplot protein_of_interest &lt;- &quot;IL6&quot; p_single &lt;- data_long %&gt;% filter(Target == protein_of_interest, SampleName %in% sample_list) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_boxplot(alpha = 0.7, outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.6, size = 2) + labs(title = paste(protein_of_interest, &quot;Expression Across Groups&quot;), x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 1)) ggsave(file.path(out_dir, paste0(protein_of_interest, &quot;_boxplot.pdf&quot;)), p_single, width = 7, height = 5) # 6. Multiple proteins facet plot protein_variance &lt;- apply(data$merged$Data_NPQ[, sample_list], 1, var, na.rm = TRUE) top_proteins &lt;- names(sort(protein_variance, decreasing = TRUE)[1:6]) p_multi &lt;- data_long %&gt;% filter(Target %in% top_proteins, SampleName %in% sample_list) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_boxplot(alpha = 0.7, outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.3, size = 1) + facet_wrap(~Target, scales = &quot;free_y&quot;, ncol = 3) + labs(title = &quot;Top Variable Proteins Across Disease Groups&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 1), strip.text = element_text(size = 12, face = &quot;bold&quot;)) ggsave(file.path(out_dir, &quot;top_proteins_facet.pdf&quot;), p_multi, width = 10, height = 8) # 7. Protein correlation plot protein1 &lt;- &quot;IL6&quot; protein2 &lt;- &quot;TNF&quot; plot_data &lt;- data_long %&gt;% filter(Target %in% c(protein1, protein2), SampleName %in% sample_list) %&gt;% select(SampleName, Target, NPQ, disease_type) %&gt;% pivot_wider(names_from = Target, values_from = NPQ) %&gt;% na.omit() p_corr &lt;- ggplot(plot_data, aes(x = .data[[protein1]], y = .data[[protein2]], color = disease_type)) + geom_point(size = 3, alpha = 0.7) + geom_smooth(method = &quot;lm&quot;, se = TRUE, color = &quot;black&quot;, linetype = &quot;dashed&quot;, linewidth = 0.5) + labs(title = paste(protein1, &quot;vs&quot;, protein2), x = paste(protein1, &quot;NPQ&quot;), y = paste(protein2, &quot;NPQ&quot;), color = &quot;Disease Type&quot;) ggsave(file.path(out_dir, &quot;protein_correlation.pdf&quot;), p_corr, width = 7, height = 6) cat(&quot;\\n✓ All visualizations saved to:&quot;, out_dir, &quot;\\n&quot;) cat(&quot;\\nGenerated files:\\n&quot;) cat(&quot; - expression_heatmap.pdf\\n&quot;) cat(&quot; - pca_plot.pdf\\n&quot;) cat(&quot; - npq_histogram.pdf\\n&quot;) cat(&quot; - npq_density.pdf\\n&quot;) cat(&quot; - IL6_boxplot.pdf\\n&quot;) cat(&quot; - top_proteins_facet.pdf\\n&quot;) cat(&quot; - protein_correlation.pdf\\n&quot;) Continue to: Chapter 4: Differential Expression Analysis "],["differential-expression-analysis.html", "Chapter 4 Differential Expression Analysis 4.1 Overview 4.2 Basic Differential Expression 4.3 Model Results 4.4 Finding Significant Proteins 4.5 Volcano Plots 4.6 Visualization of Significant Targets 4.7 Multiple Comparisons 4.8 Model Considerations 4.9 Interpreting Results 4.10 Exporting Results 4.11 Complete Differential Expression Workflow 4.12 Best Practices 4.13 Common Issues", " Chapter 4 Differential Expression Analysis This chapter focuses on differential expression analysis for cross-sectional studies, identifying proteins that differ significantly between groups using linear models. 4.1 Overview Differential expression analysis answers the question: “Which protein abundance levels are significantly associated with a specific condition or phenotype?” The lmNULISAseq() function: Fits a linear model for each protein Tests associations between protein levels and your primary variables of interest (e.g., Disease vs. Control) Adjusts for covariates, ensuring that differences are attributed by the effect of interest Corrects for multiple testing (Benjamini-Hochberg (BH) FDR, Bonferroni correction) See complete function documentation and additional options, use ?lmNULISAseq(). 4.2 Basic Differential Expression 4.2.1 Group Comparison The most basic analysis compares two groups: # Compare disease vs normal (adjusting for sex and age) lmTest &lt;- lmNULISAseq( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, modelFormula = &quot;disease_type + sex + age&quot; ) 4.2.2 Understanding the Model The formula \"disease_type + sex + age\" means: disease_type: Variable of interest (which groups to compare) sex + age: Covariates to adjust for (remove confounding effects) The model fits: Protein Expression ~ disease_type + sex + age 4.3 Model Results The function returns a list with: # View structure names(lmTest) #&gt; [1] &quot;modelStats&quot; #&gt; Preview of `lmTest$modelStats` Results Table (rounded to 3 digits): 4.3.1 Key Columns in Results For each comparison (e.g., “disease_typeinflam” vs reference “normal”): disease_typeinflam_coef: Effect size (log fold-change) disease_typeinflam_pval: Raw p-value disease_typeinflam_pval_FDR: FDR-adjusted p-value disease_typeinflam_pval_bonf: Bonferroni-adjusted p-value target: Target name 4.4 Finding Significant Proteins Focusing on the comparison between Inflammation vs Normal, adjusting for age and sex. We will identify proteins that are significantly differentially expressed with FDR-adjusted p value &lt; 0.05. 4.4.1 Filter by FDR Threshold # Define significance threshold fdr_threshold &lt;- 0.05 fc_threshold &lt;- 0.5 # Fold-change threshold (log scale) # Find significant proteins for Inflammation vs Normal sig_inflam &lt;- lmTest$modelStats %&gt;% filter( disease_typeinflam_pval_FDR &lt; fdr_threshold, abs(disease_typeinflam_coef) &gt; fc_threshold ) %&gt;% arrange(disease_typeinflam_pval_FDR) #&gt; Significant proteins (Inflammation vs Normal): 94 4.4.2 Upregulated vs Downregulated We can further identify significantly differentially expressed proteins that are either unregulated or down regulated in the inflammation group comparing to normal group. # Upregulated in inflammation upregulated &lt;- sig_inflam %&gt;% filter(disease_typeinflam_coef &gt; 0) %&gt;% arrange(desc(disease_typeinflam_coef)) # Downregulated in inflammation downregulated &lt;- sig_inflam %&gt;% filter(disease_typeinflam_coef &lt; 0) %&gt;% arrange(disease_typeinflam_coef) cat(&quot;Upregulated:&quot;, nrow(upregulated), &quot;\\n&quot;) #&gt; Upregulated: 94 cat(&quot;Downregulated:&quot;, nrow(downregulated), &quot;\\n&quot;) #&gt; Downregulated: 0 4.5 Volcano Plots Volcano plots visualize differential expression results effectively. See complete function documentation and additional options, use ?volcanoPlot(). 4.5.1 Inflammation vs Normal volcanoPlot( coefs = lmTest$modelStats$disease_typeinflam_coef, p_vals = lmTest$modelStats$disease_typeinflam_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Inflammation vs Normal&quot; ) 4.5.2 Understanding Volcano Plots X-axis: Effect size (log fold-change) Y-axis: Statistical significance (-log10 p-value) Significant targets: Points in upper left/right corners Upregulated targets: Right side/ Red (positive fold-change) Downregulated targets: Left side/ Blue (negative fold-change) 4.5.3 Cancer vs Normal volcanoPlot( coefs = lmTest$modelStats$disease_typecancer_coef, p_vals = lmTest$modelStats$disease_typecancer_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Cancer vs Normal&quot; ) 4.5.4 Saving Volcano Plots # Automatically saves to file volcanoPlot( coefs = lmTest$modelStats$disease_typeinflam_coef, p_vals = lmTest$modelStats$disease_typeinflam_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Cancer vs Normal&quot;, plot_name = &quot;figures/FDR_volcano_plot_inflam_vs_normal.pdf&quot;, # Filename (PDF, PNG, JPG, SVG) data_dir = &quot;figures&quot;, # Where to save plot_width = 5, # Width in inches plot_height = 5 # Height in inches ) volcanoPlot( coefs = lmTest$modelStats$disease_typecancer_coef, p_vals = lmTest$modelStats$disease_typecancer_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Cancer vs Normal&quot;, plot_name = &quot;figures/FDR_volcano_plot_cancer_vs_normal.pdf&quot;, # Filename (PDF, PNG, JPG, SVG) data_dir = &quot;figures&quot;, # Where to save plot_width = 5, # Width in inches plot_height = 5 # Height in inches ) 4.6 Visualization of Significant Targets Visualize the proteins that show significant differences between Inflammation and Normal samples. 4.6.1 Inflammation vs Normal Heatmap The heatmap shows expression patterns of upregulated proteins across Inflammation and Normal samples. Samples with similar expression profiles cluster together with unsupervised clustering. inflam_samples &lt;- metadata %&gt;% filter(disease_type %in% c(&quot;normal&quot;, &quot;inflam&quot;)) %&gt;% pull(SampleName) heatmap_inflam &lt;- generate_heatmap( data = data$merged$Data_NPQ, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = inflam_samples, target_subset = upregulated$target, row_fontsize = 7, col_fontsize = 7, annotate_sample_by = c(&quot;disease_type&quot;, &quot;sex&quot;, &quot;age&quot;) ) PCA PCA shows how well the significant proteins separate Inflammation from Normal samples. Each point represents one sample. pca_inflam &lt;- generate_pca( data = data$merged$Data_NPQ, plot_title = &quot;PCA: Inflammation vs Normal \\nSignificant DE Targets&quot;, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = inflam_samples, target_subset = upregulated$target, annotate_sample_by = &quot;disease_type&quot;, shape_by = &quot;sex&quot; ) Boxplot: Upregulated Targets Boxplots show the expression distribution of each upregulated protein in Inflammation versus Normal samples. Higher mean NPQ in Inflammation samples confirm upregulation. data_long %&gt;% filter(Target %in% upregulated$target, SampleName %in% inflam_samples) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Upregulated Significant Differential Expression Targets - Inflammation vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;, fill = &quot;Disease Type&quot;) + theme( plot.title = element_text(size = 16, face = &quot;bold&quot;), plot.subtitle = element_text(size = 13), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), strip.text = element_text(size = 11), legend.title = element_text(size = 13), legend.text = element_text(size = 12) ) 4.7 Multiple Comparisons When you have multiple disease types, you get results for each comparison: # All comparisons vs &quot;normal&quot; (reference level) comparisons &lt;- c(&quot;inflam&quot;, &quot;cancer&quot;, &quot;kidney&quot;, &quot;metab&quot;, &quot;neuro&quot;) for (comp in comparisons) { coef_col &lt;- paste0(&quot;disease_type&quot;, comp, &quot;_coef&quot;) pval_col &lt;- paste0(&quot;disease_type&quot;, comp, &quot;_pval_FDR&quot;) if (coef_col %in% colnames(lmTest$modelStats)) { n_sig &lt;- sum(lmTest$modelStats[[pval_col]] &lt; 0.05, na.rm = TRUE) cat(comp, &quot;vs normal:&quot;, n_sig, &quot;significant proteins\\n&quot;) } } 4.8 Model Considerations 4.8.1 Reference Level The first level of your factor is the reference: # Check reference level levels(metadata$disease_type) # First level is reference # Change reference level if needed metadata$disease_type &lt;- relevel(metadata$disease_type, ref = &quot;cancer&quot;) 4.8.2 Including Covariates Always adjust for relevant covariates: # Include covariates that might confound results lmTest &lt;- lmNULISAseq( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, modelFormula = &quot;disease_type + sex + age + batch&quot; # Added batch ) Common covariates: Technical: Batch, plate, run date Biological: Age, sex, BMI Clinical: Disease stage, treatment status 4.8.3 Model Formula Options # Simple comparison (no covariates) modelFormula = &quot;disease_type&quot; # With covariates modelFormula = &quot;disease_type + sex + age&quot; # With interactions modelFormula = &quot;disease_type * sex + age&quot; # Tests if effect differs by sex # Continuous predictor modelFormula = &quot;age + sex&quot; # Tests correlation with age 4.9 Interpreting Results 4.9.1 Effect Size (Coefficient) Positive coefficient: Protein is higher in test group vs reference Negative coefficient: Protein is lower in test group vs reference Magnitude: Larger value = bigger difference between groups 4.9.2 P-values Raw p-value: Probability of observing effect by chance FDR-adjusted p-value: Accounts for multiple testing by Benjamini-Hochberg (BH) FDR FDR-adjusted p-value: Accounts for multiple testing by Bonferroni correction 4.9.3 Significance Thresholds Common thresholds: FDR &lt; 0.05: Standard significance level FDR &lt; 0.01: More stringent Fold-change &gt; 1.5x: Biological relevance (often combined with FDR) 4.10 Exporting Results 4.10.1 Save Results Table # Save all results write_csv(lmTest$modelStats, &quot;results/differential_expression_results.csv&quot;) # Save only significant proteins sig_results &lt;- lmTest$modelStats %&gt;% filter(disease_typeinflam_pval_FDR &lt; 0.05) write_csv(sig_results, &quot;results/significant_proteins_inflam.csv&quot;) 4.10.2 Create Summary Table # Count significant proteins per comparison summary_table &lt;- data.frame( Comparison = character(), Significant_Proteins = integer(), Upregulated = integer(), Downregulated = integer() ) for (comp in comparisons) { coef_col &lt;- paste0(&quot;disease_type&quot;, comp, &quot;_coef&quot;) pval_col &lt;- paste0(&quot;disease_type&quot;, comp, &quot;_pval_FDR&quot;) if (coef_col %in% colnames(lmTest$modelStats)) { sig &lt;- lmTest$modelStats %&gt;% filter(.data[[pval_col]] &lt; 0.05) summary_table &lt;- rbind(summary_table, data.frame( Comparison = paste(comp, &quot;vs normal&quot;), Significant_Proteins = nrow(sig), Upregulated = sum(sig[[coef_col]] &gt; 0), Downregulated = sum(sig[[coef_col]] &lt; 0) )) } } print(summary_table) write_csv(summary_table, &quot;results/summary_table.csv&quot;) 4.11 Complete Differential Expression Workflow # 1. Run differential expression lmTest &lt;- lmNULISAseq( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, modelFormula = &quot;disease_type + sex + age&quot; ) # 2. Filter significant results sig_inflam &lt;- lmTest$modelStats %&gt;% filter( disease_typeinflam_pval_FDR &lt; 0.05, abs(disease_typeinflam_coef) &gt; 0.5 ) %&gt;% arrange(disease_typeinflam_pval_FDR) sig_cancer &lt;- lmTest$modelStats %&gt;% filter( disease_typecancer_pval_FDR &lt; 0.05, abs(disease_typecancer_coef) &gt; 0.5 ) %&gt;% arrange(disease_typecancer_pval_FDR) # 3. Create volcano plots and save as PDF volcanoPlot( coefs = lmTest$modelStats$disease_typeinflam_coef, p_vals = lmTest$modelStats$disease_typeinflam_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Cancer vs Normal&quot;, plot_name = &quot;FDR_volcano_plot_inflam_vs_normal.pdf&quot;, data_dir = &quot;figures&quot;, plot_width = 5, plot_height = 5 ) volcanoPlot( coefs = lmTest$modelStats$disease_typecancer_coef, p_vals = lmTest$modelStats$disease_typecancer_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Cancer vs Normal&quot;, plot_name = &quot;FDR_volcano_plot_cancer_vs_normal.pdf&quot;, data_dir = &quot;figures&quot;, plot_width = 5, plot_height = 5 ) # 4. Create heatmap and PCA of significant targets and save as PDF ## Get inflammation and normal sample name inflam_samples &lt;- metadata %&gt;% filter(disease_type %in% c(&quot;normal&quot;, &quot;inflam&quot;)) %&gt;% pull(SampleName) ## Generate heatmap with annotations heatmap_inflam &lt;- generate_heatmap( data = data$merged$Data_NPQ, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = inflam_samples, target_subset = upregulated$target, annotate_sample_by = c(&quot;disease_type&quot;, &quot;sex&quot;, &quot;age&quot;), output_dir = &quot;figures&quot;, plot_name = &quot;FDR_heatmap_inflam_vs_normal.pdf&quot;, plot_width = 8, plot_height = 6 ) ## Generate PCA plot pca_inflam &lt;- generate_pca( data = data$merged$Data_NPQ, plot_title = &quot;PCA: Inflammation vs Normal \\nSignificant DE Targets&quot;, sampleInfo = metadata, sampleName_var = &quot;SampleName&quot;, sample_subset = inflam_samples, target_subset = upregulated$target, annotate_sample_by = &quot;disease_type&quot;, shape_by = &quot;sex&quot;, output_dir = &quot;figures&quot;, plot_name = &quot;FDR_pca_plot_inflam_vs_normal.pdf&quot;, plot_width = 5, plot_height = 4 ) # 5. Create boxplot of significant targets and save as PDF boxplot &lt;- data_long %&gt;% filter(Target %in% upregulated$target, SampleName %in% inflam_samples) %&gt;% ggplot(aes(x = disease_type, y = NPQ, fill = disease_type)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Upregulated Significant Differential Expression Targets - Inflammation vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;, legend = &quot;Disease Type&quot;) + theme(strip.text = element_text(size = 8.5), axis.text.x = element_text(angle = 45, hjust = 1)) print(boxplot) ggsave(filename = &quot;FDR_boxplot_inflam_vs_normal.pdf&quot;, plot = boxplot, device = &quot;pef&quot;, path = &quot;figures&quot;, width = 12, height = 9) # 6. Export results write_csv(lmTest$modelStats, &quot;results/all_de_results.csv&quot;) write_csv(sig_inflam, &quot;results/sig_inflam_proteins.csv&quot;) write_csv(sig_cancer, &quot;results/sig_cancer_proteins.csv&quot;) # 7. Print summary cat(&quot;\\nDifferential Expression Summary:\\n&quot;) cat(&quot;Inflammation vs Normal:&quot;, nrow(sig_inflam), &quot;significant proteins\\n&quot;) cat(&quot;Cancer vs Normal:&quot;, nrow(sig_cancer), &quot;significant proteins\\n&quot;) 4.12 Best Practices Model Design Include relevant covariates to adjust for confounding Use appropriate reference levels Consider batch effects Interpretation Using FDR-adjusted p-values for significance, accounting for multiple testing Consider both statistical significance AND effect size Validate key findings with independent methods Reporting Document model formula used Report both FDR thresholds and fold-change cutoffs Include sample sizes per group 4.13 Common Issues Problem: No significant proteins Check if groups are truly different (PCA) Sample size might be too small Effect sizes might be small Try less stringent FDR threshold or with unadjusted p values (exploratory only) Problem: Everything is significant Check for batch effects Verify model is appropriate Consider more stringent thresholds Problem: Results don’t match biology Check factor levels and reference group Verify metadata is correct Consider additional covariates Continue to: Chapter 5: Longitudinal Analysis "],["longitudinal-analysis.html", "Chapter 5 Longitudinal Analysis 5.1 Overview", " Chapter 5 Longitudinal Analysis This chapter focuses on longitudinal studies, identifying proteins whose trajectories, levels, or changes over time differ significantly between groups using linear mixed-effects models. 5.1 Overview Longitudinal analysis answers the question: “Which proteins change significantly over time, and do these changes differ by condition or group?” Because longitudinal data involves repeated measurements on the same subjects, the observations are not independent. Linear mixed-effects models (LME) account for this dependency by including random effects (e.g., subject-specific intercepts or slopes), making them the appropriate tool for this analysis. The lmerNULISAseq() function extends the linear modeling approach to handle repeated measures: Fits a linear mixed-effects model for each protein, incorporating both fixed and random effects Tests associations with your variables of interest, such as the time-by-group interaction, to identify proteins with different temporal patterns Adjusts for covariates, ensuring that differences are attributed to the primary variables Accounts for the correlation structure within subjects due to repeated measurements Corrects for multiple testing (e.g., Benjamini-Hochberg (BH) FDR, Bonferroni correction) See complete function documentation and additional options, use ?lmerNULISAseq(). Continue to: Chapter 6: Predictive Modeling "],["predictive-modeling.html", "Chapter 6 Predictive Modeling 6.1 Overview 6.2 Continuous Outcomes 6.3 Binary Outcomes 6.4 Comparing Approaches 6.5 Advanced: Model Comparisons 6.6 Model Validation 6.7 Exporting Results 6.8 Complete Predictive Modeling Workflow 6.9 Best Practices", " Chapter 6 Predictive Modeling This chapter covers using protein expression as predictors to model outcomes, including both continuous and binary responses. 6.1 Overview While differential expression asks “What proteins differ between groups?”, predictive modeling asks “Which proteins predict an outcome?” NULISAseqR provides two functions: lmNULISAseq_predict(): For continuous outcomes (linear regression) glmNULISAseq_predict(): For binary outcomes (logistic regression) 6.2 Continuous Outcomes Use lmNULISAseq_predict() when your outcome is continuous (e.g., disease severity score, biomarker level, clinical measurement). 6.2.1 Example: Predicting a Clinical Score # Add a continuous outcome to metadata (e.g., disease severity score) # In real analysis, this would be actual clinical data metadata$score &lt;- runif(n = nrow(metadata), min = 1, max = 100) # Fit models with each protein predicting the score lmpt &lt;- lmNULISAseq_predict( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, response_var = &quot;score&quot;, modelFormula = &quot;age&quot; # Adjust for age as covariate ) 6.2.2 Understanding the Model For each protein, the model is: score ~ protein_expression + age This tests: “Does this protein predict the score, after accounting for age?” 6.2.3 Examining Results # View structure names(lmpt) # View results table head(lmpt$modelStats) 6.2.4 Key Columns target: Protein name target_coef: Effect size (how much score changes per unit protein) target_pval: Raw p-value target_pval_FDR: FDR-adjusted p-value r_squared: Model R² (proportion of variance explained) 6.2.5 Finding Predictive Proteins # Find proteins that significantly predict the score predictive_proteins &lt;- lmpt$modelStats %&gt;% filter(target_pval_FDR &lt; 0.05) %&gt;% arrange(target_pval_FDR) %&gt;% select(target, target_coef, target_pval_FDR, r_squared) cat(&quot;Proteins predicting score:&quot;, nrow(predictive_proteins), &quot;\\n&quot;) head(predictive_proteins, 10) 6.2.6 Interpreting Coefficients Positive coefficient: Higher protein expression → higher score Negative coefficient: Higher protein expression → lower score Magnitude: Size of effect (units of score per unit protein expression) 6.2.7 Visualizing Predictions # Plot top predictive protein top_protein &lt;- predictive_proteins$target[1] plot_data &lt;- data_long %&gt;% filter(target == top_protein, SampleName %in% sample_list) %&gt;% left_join(metadata %&gt;% select(SampleName, score), by = &quot;SampleName&quot;) ggplot(plot_data, aes(x = NPQ, y = score)) + geom_point(alpha = 0.6, size = 3) + geom_smooth(method = &quot;lm&quot;, se = TRUE, color = &quot;blue&quot;) + theme_minimal() + labs(title = paste(top_protein, &quot;vs Clinical Score&quot;), x = paste(top_protein, &quot;Expression (NPQ)&quot;), y = &quot;Clinical Score&quot;) 6.3 Binary Outcomes Use glmNULISAseq_predict() when your outcome is binary (e.g., disease vs healthy, responder vs non-responder). 6.3.1 Example: Predicting Disease Status # Add a binary outcome to metadata # In real analysis, this would be actual outcome data metadata$outcome &lt;- rbinom(n = nrow(metadata), size = 1, prob = 0.5) # Fit logistic regression models glmt &lt;- glmNULISAseq_predict( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, response_var = &quot;outcome&quot;, modelFormula = &quot;disease_type + sex + age&quot; ) 6.3.2 Understanding the Model For each protein, the model is: log(odds of outcome) ~ protein_expression + disease_type + sex + age This tests: “Does this protein predict the outcome, after accounting for disease type, sex, and age?” 6.3.3 Examining Results # View results table head(glmt$modelStats) 6.3.4 Key Columns target: Protein name target_coef: Log odds ratio target_OR: Odds ratio (exponentiated coefficient) target_pval: Raw p-value (Wald test) target_pval_FDR: FDR-adjusted p-value AIC: Model fit statistic (lower is better) 6.3.5 Finding Predictive Proteins # Find proteins that significantly predict the outcome predictive_binary &lt;- glmt$modelStats %&gt;% filter(target_pval_FDR &lt; 0.05) %&gt;% arrange(target_pval_FDR) %&gt;% select(target, target_coef, target_OR, target_pval_FDR, AIC) cat(&quot;Proteins predicting outcome:&quot;, nrow(predictive_binary), &quot;\\n&quot;) head(predictive_binary, 10) 6.3.6 Interpreting Odds Ratios OR = 1: No association OR &gt; 1: Higher protein expression → higher odds of outcome = 1 OR &lt; 1: Higher protein expression → lower odds of outcome = 1 Example: OR = 2 means doubling protein expression doubles the odds of the outcome 6.3.7 Visualizing Binary Predictions # Plot top predictive protein top_protein_binary &lt;- predictive_binary$target[1] plot_data &lt;- data_long %&gt;% filter(target == top_protein_binary, SampleName %in% sample_list) %&gt;% left_join(metadata %&gt;% select(SampleName, outcome), by = &quot;SampleName&quot;) %&gt;% mutate(outcome = factor(outcome, levels = c(0, 1), labels = c(&quot;Negative&quot;, &quot;Positive&quot;))) ggplot(plot_data, aes(x = outcome, y = NPQ, fill = outcome)) + geom_boxplot(alpha = 0.7) + geom_jitter(width = 0.2, alpha = 0.5) + theme_minimal() + labs(title = paste(top_protein_binary, &quot;Expression by Outcome&quot;), x = &quot;Outcome&quot;, y = paste(top_protein_binary, &quot;Expression (NPQ)&quot;)) + theme(legend.position = &quot;none&quot;) 6.4 Comparing Approaches 6.4.1 When to Use Each Function Differential Expression (lmNULISAseq) Goal: Find proteins that differ between groups Proteins are outcomes, groups are predictors Example: “Which proteins differ in cancer vs normal?” Continuous Prediction (lmNULISAseq_predict) Goal: Identify proteins that predict a continuous outcome Proteins are predictors, continuous variable is outcome Example: “Which proteins predict disease severity score?” Binary Prediction (glmNULISAseq_predict) Goal: Identify proteins that predict a binary outcome Proteins are predictors, binary variable is outcome Example: “Which proteins predict treatment response (yes/no)?” 6.5 Advanced: Model Comparisons 6.5.1 Compare Model Performance # For continuous outcomes: Compare R² values top_10_continuous &lt;- lmpt$modelStats %&gt;% arrange(desc(r_squared)) %&gt;% head(10) %&gt;% select(target, r_squared, target_pval_FDR) print(top_10_continuous) # For binary outcomes: Compare AIC values (lower is better) top_10_binary &lt;- glmt$modelStats %&gt;% arrange(AIC) %&gt;% head(10) %&gt;% select(target, AIC, target_OR, target_pval_FDR) print(top_10_binary) 6.5.2 Multi-protein Models For building models with multiple proteins: # Select top predictive proteins top_proteins &lt;- predictive_proteins$target[1:5] # Create wide format with selected proteins model_data &lt;- data_long %&gt;% filter(target %in% top_proteins, SampleName %in% sample_list) %&gt;% select(SampleName, target, NPQ) %&gt;% pivot_wider(names_from = target, values_from = NPQ) %&gt;% left_join(metadata %&gt;% select(SampleName, score, age), by = &quot;SampleName&quot;) # Fit multi-protein model multi_model &lt;- lm(score ~ ., data = model_data %&gt;% select(-SampleName)) summary(multi_model) 6.6 Model Validation 6.6.1 Cross-Validation For robust predictions, use cross-validation: library(caret) # Prepare data for top protein top_protein &lt;- predictive_proteins$target[1] cv_data &lt;- data$merged$Data_NPQ_long %&gt;% filter(target == top_protein, SampleName %in% sample_list) %&gt;% select(SampleName, NPQ) %&gt;% left_join(metadata %&gt;% select(SampleName, score, age), by = &quot;SampleName&quot;) %&gt;% na.omit() # 10-fold cross-validation train_control &lt;- trainControl(method = &quot;cv&quot;, number = 10) model_cv &lt;- train( score ~ NPQ + age, data = cv_data, method = &quot;lm&quot;, trControl = train_control ) print(model_cv) 6.6.2 Test Set Validation # Split data into train/test set.seed(123) train_idx &lt;- sample(1:nrow(cv_data), size = 0.7 * nrow(cv_data)) train_data &lt;- cv_data[train_idx, ] test_data &lt;- cv_data[-train_idx, ] # Train model train_model &lt;- lm(score ~ NPQ + age, data = train_data) # Test predictions predictions &lt;- predict(train_model, newdata = test_data) cor(predictions, test_data$score)^2 # R² on test set 6.7 Exporting Results # Save continuous outcome results write_csv(lmpt$modelStats, &quot;results/continuous_prediction_results.csv&quot;) write_csv(predictive_proteins, &quot;results/significant_predictors_continuous.csv&quot;) # Save binary outcome results write_csv(glmt$modelStats, &quot;results/binary_prediction_results.csv&quot;) write_csv(predictive_binary, &quot;results/significant_predictors_binary.csv&quot;) 6.8 Complete Predictive Modeling Workflow # 1. Continuous outcome prediction lmpt &lt;- lmNULISAseq_predict( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, response_var = &quot;score&quot;, modelFormula = &quot;age&quot; ) # 2. Find significant predictors sig_continuous &lt;- lmpt$modelStats %&gt;% filter(target_pval_FDR &lt; 0.05) %&gt;% arrange(target_pval_FDR) # 3. Binary outcome prediction glmt &lt;- glmNULISAseq_predict( data = data$merged$Data_NPQ[, sample_list], sampleInfo = metadata %&gt;% filter(SampleName %in% sample_list), sampleName_var = &quot;SampleName&quot;, response_var = &quot;outcome&quot;, modelFormula = &quot;disease_type + sex + age&quot; ) # 4. Find significant predictors sig_binary &lt;- glmt$modelStats %&gt;% filter(target_pval_FDR &lt; 0.05) %&gt;% arrange(target_pval_FDR) # 5. Export results write_csv(sig_continuous, &quot;results/predictors_continuous.csv&quot;) write_csv(sig_binary, &quot;results/predictors_binary.csv&quot;) # 6. Summary cat(&quot;\\nPredictive Modeling Summary:\\n&quot;) cat(&quot;Continuous outcome predictors:&quot;, nrow(sig_continuous), &quot;\\n&quot;) cat(&quot;Binary outcome predictors:&quot;, nrow(sig_binary), &quot;\\n&quot;) 6.9 Best Practices Model Design Include relevant covariates Consider non-linear relationships Check for interactions if biologically relevant Validation Use cross-validation for small datasets Reserve test set for larger datasets Validate key findings independently Interpretation Consider both statistical significance and effect size Assess model fit (R², AIC) Check model assumptions Reporting Document model formulas Report validation metrics Acknowledge limitations Continue to: Chapter 7: Complete Workflow: Identifying Proteomic Signatures in SLE and RA "],["complete-workflow-1.html", "Chapter 7 Complete Workflow: Identifying Proteomic Signatures in Lupus and Rheumatoid Arthritis 7.1 Overview 7.2 Data Preparation 7.3 Apply Detectability Threshold 7.4 Global Data Visualization 7.5 Statistical Testing 7.6 Systemic Lupus Erythematosus (SLE) Analysis 7.7 Rheumatoid Arthritis (RA) Analysis 7.8 Comparing Disease Signatures 7.9 Next Steps 7.10 Complete Workflow Example Code", " Chapter 7 Complete Workflow: Identifying Proteomic Signatures in Lupus and Rheumatoid Arthritis 7.1 Overview Differential expression analysis is a critical component of proteomic studies, enabling researchers to identify proteins that are significantly expressex between experimental conditions. In this chapter, we demonstrate a complete differential expression workflow using the NULISAseq Inflammation Panel to compare inflammatory diseases against healthy controls. We’ll analyze a dataset containing samples from patients with: Systemic Lupus Erythematosus (SLE): An autoimmune disease where the immune system attacks its own tissues, causing widespread inflammation and tissue damage Rheumatoid Arthritis (RA): A chronic inflammatory disorder primarily affecting joints, but potentially involving other organ systems Normal controls: Healthy individuals without inflammatory disease This workflow will cover data import, target detectability filtering, visualization of target expression, statistical testing, and interpretation of disease-specific protein signatures. 7.2 Data Preparation 7.2.1 Load Required Libraries library(NULISAseqR) library(tidyverse) 7.2.2 Import Data We begin by importing the NULISAseq data file: data_dir &lt;- system.file(&quot;extdata&quot;, package = &quot;NULISAseqR&quot;) data &lt;- importNULISAseq(files = file.path(data_dir, &quot;Inflammation_250_RQ_demo_2025-05-20-Lab-A.xml&quot;)) #&gt; Using single IC to normalize data. 7.2.3 Prepare Sample Metadata Next, we extract and prepare the sample metadata, filtering for experimental samples and setting the reference level for the Disease variable: metadata &lt;- data$merged$samples %&gt;% filter(sampleType == &quot;Sample&quot;) %&gt;% mutate(Disease = relevel(Disease, ref = &quot;normal&quot;)) # Display sample distribution table(metadata$Disease) #&gt; #&gt; normal lupusSle rheumatoidArthritis #&gt; 19 12 12 The relevel() function is important here as it sets “normal” as the reference group for all subsequent statistical comparisons. This means our differential expression results will show changes in diseased samples relative to healthy controls. 7.3 Apply Detectability Threshold To ensure robust statistical analysis, we filter proteins based on the detectability across samples. We use a 50% detectability threshold for plasma samples, meaning a target must be detected in at least 50% of samples to be included: detectability_threshold &lt;- 0.5 targets_passed &lt;- data$merged$detectability %&gt;% filter(`plasma (n = 43)` &gt; 50) %&gt;% pull(Target) # Identify excluded targets excluded_targets &lt;- setdiff(rownames(data$merged$Data_NPQ), targets_passed) cat(&quot;Number of targets excluded:&quot;, length(excluded_targets), &quot;\\n&quot;) #&gt; Number of targets excluded: 5 cat(&quot;Targets excluded:&quot;, paste(excluded_targets, collapse = &quot;, &quot;), &quot;\\n&quot;) #&gt; Targets excluded: CNTF, CTSS, IFNW1, IL11, IL32 7.4 Global Data Visualization Before performing differential expression analysis, we examine the overall structure of the data using unsupervised visualization methods. 7.4.1 Prepare Metadata for Visualization First, we clean up the metadata labels for better plot readability: metadata_rename &lt;- metadata %&gt;% mutate(Disease = case_when( Disease == &quot;lupusSle&quot; ~ &quot;SLE&quot;, Disease == &quot;rheumatoidArthritis&quot; ~ &quot;RA&quot;, TRUE ~ &quot;Normal&quot; ), `Sample Matrix` = tolower(SAMPLE_MATRIX) ) 7.4.2 Hierarchical Clustering Heatmap The heatmap provides a global view of protein expression patterns across all samples and identifies natural groupings: h &lt;- generate_heatmap(data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = metadata_rename$sampleName, target_subset = targets_passed, annotate_sample_by = c(&quot;Disease&quot;, &quot;Sample Matrix&quot;, &quot;Lab&quot;)) Interpretation: The heatmap shows hierarchical clustering of both samples (columns) and proteins (rows). Look for: Clustering of samples by disease type (indicated by the annotation bars) Groups of proteins with similar expression patterns 7.4.3 Principal Component Analysis PCA shows the clustering of samples by groups in reduced dimensional space, highlighting variance in the dataset: p &lt;- generate_pca(data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = metadata_rename$sampleName, target_subset = targets_passed, annotate_sample_by = &quot;Disease&quot;) Interpretation: In the PCA plot: Each point represents a sample Distance between points reflects similarity in overall protein expression Good separation between disease groups suggests distinct proteomic signatures PC1 and PC2 percentages indicate how much variation each component explains 7.5 Statistical Testing We perform linear modeling to identify proteins that are significantly different between disease groups and controls: lmTest &lt;- lmNULISAseq(data = data$merged$Data_NPQ[targets_passed, metadata$sampleName], sampleInfo = metadata, sampleName_var = &quot;sampleName&quot;, modelFormula = &quot;Disease&quot;) The lmNULISAseq() function fits a linear model for each protein, testing for differential expression while controlling for multiple comparisons using FDR adjustment. 7.6 Systemic Lupus Erythematosus (SLE) Analysis 7.6.1 Background Systemic Lupus Erythematosus is characterized by chronic inflammation affecting multiple organ systems. The immune dysregulation in SLE involves abnormal B and T cell activation, autoantibody production, and inflammatory cytokine release. The proteomic signature of SLE typically shows: Elevated inflammatory cytokines and chemokines Increased acute phase proteins Markers of immune activation Proteins involved in tissue damage and repair 7.6.2 Volcano Plot The volcano plot visualizes both the magnitude (fold change) and statistical significance of protein changes: volcanoPlot(coefs = lmTest$modelStats$DiseaselupusSle_coef, p_vals = lmTest$modelStats$DiseaselupusSle_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Systemic Lupus Erythematosus (SLE) vs Normal&quot;) Interpretation: X-axis (coefficient): Log2 fold change; positive values indicate upregulation in SLE Y-axis (-log10 p-value): Statistical significance; higher values = more significant Colored points: Proteins passing the FDR &lt; 0.05 threshold Upper left/right corners: Most significantly changed proteins 7.6.3 Visualizations Now we examine only the samples and proteins relevant to the SLE comparison: # Select SLE and normal samples sle_samples &lt;- metadata %&gt;% filter(Disease %in% c(&quot;normal&quot;, &quot;lupusSle&quot;)) %&gt;% pull(sampleName) # Identify significantly differential proteins sig_targets_sle &lt;- lmTest$modelStats %&gt;% filter(DiseaselupusSle_pval_FDR &lt; 0.05) %&gt;% pull(target) cat(&quot;Number of significant targets in SLE:&quot;, length(sig_targets_sle), &quot;\\n&quot;) #&gt; Number of significant targets in SLE: 102 7.6.3.1 SLE-Specific Heatmap h_sle &lt;- generate_heatmap(data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = sle_samples, target_subset = sig_targets_sle, annotate_sample_by = c(&quot;Disease&quot;, &quot;Sample Matrix&quot;, &quot;Lab&quot;)) This heatmap focuses exclusively on proteins significantly altered in SLE, making disease-specific patterns more apparent. 7.6.3.2 SLE-Specific PCA p_sle &lt;- generate_pca(data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = sle_samples, target_subset = sig_targets_sle, annotate_sample_by = &quot;Disease&quot;) Using only significantly differential proteins often enhances separation between groups in PCA. 7.6.4 Directional Analysis We separate upregulated and downregulated proteins to understand the nature of proteomic changes: # Upregulated proteins (higher in SLE) sig_targets_sle_up &lt;- lmTest$modelStats %&gt;% filter(DiseaselupusSle_pval_FDR &lt; 0.05, DiseaselupusSle_coef &gt; 0) %&gt;% pull(target) # Downregulated proteins (lower in SLE) sig_targets_sle_down &lt;- lmTest$modelStats %&gt;% filter(DiseaselupusSle_pval_FDR &lt; 0.05, DiseaselupusSle_coef &lt; 0) %&gt;% pull(target) cat(&quot;Upregulated targets:&quot;, length(sig_targets_sle_up), &quot;\\n&quot;) #&gt; Upregulated targets: 100 cat(&quot;Downregulated targets:&quot;, length(sig_targets_sle_down), &quot;\\n&quot;) #&gt; Downregulated targets: 2 Prepare Long Format Data We clean up the covariate names in the long data frame for better boxplot readability: data_long &lt;- data$merged$Data_NPQ_long %&gt;% mutate( `Disease Type` = case_when( Disease == &quot;lupusSle&quot; ~ &quot;SLE&quot;, Disease == &quot;rheumatoidArthritis&quot; ~ &quot;RA&quot;, TRUE ~ &quot;Normal&quot; )) 7.6.4.1 Upregulated Proteins in SLE data_long %&gt;% filter(Target %in% sig_targets_sle_up, SampleName %in% sle_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Upregulated Significant Differential Expression Targets - SLE vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;) + theme( plot.title = element_text(size = 16, face = &quot;bold&quot;), plot.subtitle = element_text(size = 13), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), strip.text = element_text(size = 11), legend.title = element_text(size = 13), legend.text = element_text(size = 12) ) Interpretation: Elevated proteins in SLE may represent: Pro-inflammatory cytokines driving disease pathology Acute phase reactants responding to chronic inflammation Markers of immune cell activation Proteins released from damaged tissues 7.6.4.2 Downregulated Proteins in SLE data_long %&gt;% filter(Target %in% sig_targets_sle_down, SampleName %in% sle_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Downregulated Significant Differential Expression Targets - SLE vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;) + theme(strip.text = element_text(size = 13)) Interpretation: Decreased proteins in SLE might indicate: Consumption of regulatory proteins trying to control inflammation Impaired synthesis due to disease-related metabolic changes Negative acute phase reactants Protective factors depleted in chronic disease 7.7 Rheumatoid Arthritis (RA) Analysis 7.7.1 Background Rheumatoid Arthritis is a chronic inflammatory disorder that primarily affects synovial joints but can have systemic manifestations. The pathophysiology involves: Autoimmune targeting of joint tissues Synovial inflammation and proliferation Cartilage and bone destruction Systemic inflammation The proteomic profile of RA often shows markers of: Joint inflammation and damage Systemic inflammatory response Matrix degradation Immune activation 7.7.2 Volcano Plot volcanoPlot(coefs = lmTest$modelStats$DiseaserheumatoidArthritis_coef, p_vals = lmTest$modelStats$DiseaserheumatoidArthritis_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Rheumatoid Arthritis (RA) vs Normal&quot;) Compare this volcano plot to the SLE plot above. Are there: Proteins significantly changed in both conditions (shared inflammatory pathways)? Disease-specific signatures unique to RA or SLE? Similar magnitude of changes between the two diseases? 7.7.3 Visualizations # Select RA and normal samples ra_samples &lt;- metadata %&gt;% filter(Disease %in% c(&quot;normal&quot;, &quot;rheumatoidArthritis&quot;)) %&gt;% pull(sampleName) # Identify significantly differential proteins sig_targets_ra &lt;- lmTest$modelStats %&gt;% filter(DiseaserheumatoidArthritis_pval_FDR &lt; 0.05) %&gt;% pull(target) cat(&quot;Number of significant targets in RA:&quot;, length(sig_targets_ra), &quot;\\n&quot;) #&gt; Number of significant targets in RA: 96 7.7.3.1 RA-Specific Heatmap h_ra &lt;- generate_heatmap(data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = ra_samples, target_subset = sig_targets_ra, annotate_sample_by = c(&quot;Disease&quot;, &quot;Sample Matrix&quot;, &quot;Lab&quot;), row_fontsize = 6, col_fontsize = 6) 7.7.3.2 RA-Specific PCA p_ra &lt;- generate_pca(data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = ra_samples, target_subset = sig_targets_ra, annotate_sample_by = &quot;Disease&quot;) 7.7.4 Directional Analysis # Upregulated proteins (higher in RA) sig_targets_ra_up &lt;- lmTest$modelStats %&gt;% filter(DiseaserheumatoidArthritis_pval_FDR &lt; 0.05, DiseaserheumatoidArthritis_coef &gt; 0) %&gt;% pull(target) # Downregulated proteins (lower in RA) sig_targets_ra_down &lt;- lmTest$modelStats %&gt;% filter(DiseaserheumatoidArthritis_pval_FDR &lt; 0.05, DiseaserheumatoidArthritis_coef &lt; 0) %&gt;% pull(target) cat(&quot;Upregulated targets:&quot;, length(sig_targets_ra_up), &quot;\\n&quot;) #&gt; Upregulated targets: 95 cat(&quot;Downregulated targets:&quot;, length(sig_targets_ra_down), &quot;\\n&quot;) #&gt; Downregulated targets: 1 7.7.4.1 Upregulated Proteins in RA data_long %&gt;% filter(Target %in% sig_targets_ra_up, SampleName %in% ra_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Upregulated Significant Differential Expression Targets - RA vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;) + theme( plot.title = element_text(size = 16, face = &quot;bold&quot;), plot.subtitle = element_text(size = 13), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), strip.text = element_text(size = 11), legend.title = element_text(size = 13), legend.text = element_text(size = 12) ) Interpretation: Elevated proteins in RA may include: Matrix metalloproteinases and other degradative enzymes Inflammatory cytokines (particularly TNF-α pathway members) Proteins involved in bone remodeling Acute phase proteins 7.7.4.2 Downregulated Proteins in RA data_long %&gt;% filter(Target %in% sig_targets_ra_down, SampleName %in% ra_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Downregulated Significant Differential Expression \\n Targets - RA vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;) + theme(strip.text = element_text(size = 13)) 7.8 Comparing Disease Signatures 7.8.1 Overlap Analysis To understand shared versus disease-specific biology, we can examine the overlap of significant proteins: # Proteins significant in both diseases shared_targets &lt;- intersect(sig_targets_sle, sig_targets_ra) # Disease-specific proteins sle_specific &lt;- setdiff(sig_targets_sle, sig_targets_ra) ra_specific &lt;- setdiff(sig_targets_ra, sig_targets_sle) cat(&quot;Shared significant targets:&quot;, length(shared_targets), &quot;\\n&quot;) #&gt; Shared significant targets: 73 cat(&quot;SLE-specific targets:&quot;, length(sle_specific), &quot;\\n&quot;) #&gt; SLE-specific targets: 29 cat(&quot;RA-specific targets:&quot;, length(ra_specific), &quot;\\n&quot;) #&gt; RA-specific targets: 23 # Display shared targets if any if(length(shared_targets) &gt; 0) { cat(&quot;\\nShared targets between SLE and RA:\\n&quot;) cat(paste(shared_targets, collapse = &quot;, &quot;), &quot;\\n&quot;) } #&gt; #&gt; Shared targets between SLE and RA: #&gt; AREG, CCL1, CCL13, CCL2, CCL21, CCL22, CCL26, CCL27, CCL7, CD27, CD274, CD4, CD40, CD46, CD80, CD83, CSF1, CSF1R, CSF3R, CTLA4, CXCL11, CXCL13, CXCL6, FASLG, FURIN, GZMA, GZMB, HGF, IL10RB, IL12B, IL15RA, IL16, IL17RA, IL18, IL18BP, IL18R1, IL1B, IL1RN, IL2RA, KLRK1, LCN2, LGALS9, LIF, LILRB2, MMP8, MMP9, MPO, NAMPT, NCR1, OSM, OSMR, PDCD1, PDGFB, PTX3, S100A12, THBS2, TNFRSF11A, TNFRSF13C, TNFRSF14, TNFRSF18, TNFRSF1A, TNFRSF21, TNFRSF4, TNFRSF8, TNFRSF9, TNFSF10, TNFSF13, TNFSF18, TNFSF4, TNFSF8, TREM1, TREM2, TSLP Biological Interpretation: Shared targets represent common inflammatory pathways activated in both autoimmune conditions Disease-specific targets may reflect unique pathophysiological mechanisms Directional concordance: Check if shared proteins change in the same direction in both diseases 7.8.2 Summary Statistics Table summary_stats &lt;- data.frame( Condition = c(&quot;SLE vs Normal&quot;, &quot;RA vs Normal&quot;), Total_Significant = c(length(sig_targets_sle), length(sig_targets_ra)), Upregulated = c(length(sig_targets_sle_up), length(sig_targets_ra_up)), Downregulated = c(length(sig_targets_sle_down), length(sig_targets_ra_down)) ) knitr::kable(summary_stats, caption = &quot;Summary of Differential Expression Results&quot;) Table 7.1: Summary of Differential Expression Results Condition Total_Significant Upregulated Downregulated SLE vs Normal 102 100 2 RA vs Normal 96 95 1 7.9 Next Steps After identifying differentially expressed proteins, typical follow-up analyses include: Pathway enrichment analysis: Identify biological pathways over-represented in significant proteins Protein network analysis: Understand functional relationships between differential proteins Biomarker evaluation: Assess individual proteins or combinations for diagnostic potential Correlation with clinical variables: Link protein changes to disease severity or outcomes Validation studies: Confirm findings in independent cohorts or using orthogonal methods 7.10 Complete Workflow Example Code # ============================================================================ # COMPLETE DIFFERENTIAL EXPRESSION WORKFLOW: SLE and RA Analysis # ============================================================================ # 1. Load libraries and import data library(NULISAseqR) library(tidyverse) data_dir &lt;- system.file(&quot;extdata&quot;, package = &quot;NULISAseqR&quot;) data &lt;- importNULISAseq(files = file.path(data_dir,&quot;Inflammation_250_RQ_demo_2025-05-20-Lab-A.xml&quot;)) # 2. Prepare metadata metadata &lt;- data$merged$samples %&gt;% filter(sampleType == &quot;Sample&quot;) %&gt;% mutate(Disease = relevel(Disease, ref = &quot;normal&quot;)) metadata_rename &lt;- metadata %&gt;% mutate(Disease = case_when( Disease == &quot;lupusSle&quot; ~ &quot;SLE&quot;, Disease == &quot;rheumatoidArthritis&quot; ~ &quot;RA&quot;, TRUE ~ &quot;Normal&quot; ), `Sample Matrix` = tolower(SAMPLE_MATRIX)) # 3. Target detectability filtering detectability_threshold &lt;- 0.5 targets_passed &lt;- data$merged$detectability %&gt;% filter(`plasma (n = 43)` &gt; 50) %&gt;% pull(Target) cat(&quot;Number of targets passing QC:&quot;, length(targets_passed), &quot;\\n&quot;) # 4. Run differential expression analysis lmTest &lt;- lmNULISAseq( data = data$merged$Data_NPQ[targets_passed, metadata$sampleName], sampleInfo = metadata, sampleName_var = &quot;sampleName&quot;, modelFormula = &quot;Disease&quot; ) # ============================================================================ # SLE ANALYSIS # ============================================================================ # 5a. Filter significant SLE results sig_targets_sle &lt;- lmTest$modelStats %&gt;% filter(DiseaselupusSle_pval_FDR &lt; 0.05) %&gt;% pull(target) sig_targets_sle_up &lt;- lmTest$modelStats %&gt;% filter(DiseaselupusSle_pval_FDR &lt; 0.05, DiseaselupusSle_coef &gt; 0) %&gt;% pull(target) sig_targets_sle_down &lt;- lmTest$modelStats %&gt;% filter(DiseaselupusSle_pval_FDR &lt; 0.05, DiseaselupusSle_coef &lt; 0) %&gt;% pull(target) # 6a. Get SLE and normal samples sle_samples &lt;- metadata %&gt;% filter(Disease %in% c(&quot;normal&quot;, &quot;lupusSle&quot;)) %&gt;% pull(sampleName) # 7a. Create SLE volcano plot and save as PDF volcanoPlot( coefs = lmTest$modelStats$DiseaselupusSle_coef, p_vals = lmTest$modelStats$DiseaselupusSle_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Systemic Lupus Erythematosus (SLE) vs Normal&quot;, plot_name = &quot;volcano_plot_sle_vs_normal.pdf&quot;, data_dir = &quot;figures&quot;, plot_width = 6, plot_height = 5 ) # 8a. Create SLE heatmap and save as PDF h_sle &lt;- generate_heatmap( data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = sle_samples, target_subset = sig_targets_sle, annotate_sample_by = c(&quot;Disease&quot;, &quot;Sample Matrix&quot;, &quot;Lab&quot;), output_dir = &quot;figures&quot;, plot_name = &quot;heatmap_sle_vs_normal.pdf&quot;, plot_width = 8, plot_height = 6 ) # 9a. Create SLE PCA and save as PDF p_sle &lt;- generate_pca( data = data$merged$Data_NPQ, plot_title = &quot;PCA: SLE vs Normal\\nSignificant DE Targets&quot;, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = sle_samples, target_subset = sig_targets_sle, annotate_sample_by = &quot;Disease&quot;, output_dir = &quot;figures&quot;, plot_name = &quot;pca_plot_sle_vs_normal.pdf&quot;, plot_width = 5, plot_height = 4 ) # 10a. Prepare long format data for boxplots data_long &lt;- data$merged$Data_NPQ_long %&gt;% mutate( `Disease Type` = case_when( Disease == &quot;lupusSle&quot; ~ &quot;SLE&quot;, Disease == &quot;rheumatoidArthritis&quot; ~ &quot;RA&quot;, TRUE ~ &quot;Normal&quot; )) # 11a. Create upregulated SLE boxplots and save as PDF boxplot_sle_up &lt;- data_long %&gt;% filter(Target %in% sig_targets_sle_up, SampleName %in% sle_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Upregulated Significant DE Targets - SLE vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme_minimal() + theme(strip.text = element_text(size = 11), axis.text.x = element_text(angle = 45, hjust = 1)) ggsave( filename = &quot;boxplot_sle_upregulated.pdf&quot;, plot = boxplot_sle_up, device = &quot;pdf&quot;, path = &quot;figures&quot;, width = 12, height = 10 ) # 12a. Create downregulated SLE boxplots and save as PDF boxplot_sle_down &lt;- data_long %&gt;% filter(Target %in% sig_targets_sle_down, SampleName %in% sle_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Downregulated Significant DE Targets - SLE vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme_minimal() + theme(strip.text = element_text(size = 11)) ggsave( filename = &quot;boxplot_sle_downregulated.pdf&quot;, plot = boxplot_sle_down, device = &quot;pdf&quot;, path = &quot;figures&quot;, width = 4, height = 3 ) # ============================================================================ # RA ANALYSIS # ============================================================================ # 5b. Filter significant RA results sig_targets_ra &lt;- lmTest$modelStats %&gt;% filter(DiseaserheumatoidArthritis_pval_FDR &lt; 0.05) %&gt;% pull(target) sig_targets_ra_up &lt;- lmTest$modelStats %&gt;% filter(DiseaserheumatoidArthritis_pval_FDR &lt; 0.05, DiseaserheumatoidArthritis_coef &gt; 0) %&gt;% pull(target) sig_targets_ra_down &lt;- lmTest$modelStats %&gt;% filter(DiseaserheumatoidArthritis_pval_FDR &lt; 0.05, DiseaserheumatoidArthritis_coef &lt; 0) %&gt;% pull(target) # 6b. Get RA and normal samples ra_samples &lt;- metadata %&gt;% filter(Disease %in% c(&quot;normal&quot;, &quot;rheumatoidArthritis&quot;)) %&gt;% pull(sampleName) # 7b. Create RA volcano plot and save as PDF volcanoPlot( coefs = lmTest$modelStats$DiseaserheumatoidArthritis_coef, p_vals = lmTest$modelStats$DiseaserheumatoidArthritis_pval_FDR, target_labels = lmTest$modelStats$target, title = &quot;Rheumatoid Arthritis (RA) vs Normal&quot;, plot_name = &quot;volcano_plot_ra_vs_normal.pdf&quot;, data_dir = &quot;figures&quot;, plot_width = 6, plot_height = 5 ) # 8b. Create RA heatmap and save as PDF h_ra &lt;- generate_heatmap( data = data$merged$Data_NPQ, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = ra_samples, target_subset = sig_targets_ra, annotate_sample_by = c(&quot;Disease&quot;, &quot;Sample Matrix&quot;, &quot;Lab&quot;), output_dir = &quot;figures&quot;, plot_name = &quot;heatmap_ra_vs_normal.pdf&quot;, plot_width = 8, plot_height = 6 ) # 9b. Create RA PCA and save as PDF p_ra &lt;- generate_pca( data = data$merged$Data_NPQ, plot_title = &quot;PCA: RA vs Normal\\nSignificant DE Targets&quot;, sampleInfo = metadata_rename, sampleName_var = &quot;sampleName&quot;, sample_subset = ra_samples, target_subset = sig_targets_ra, annotate_sample_by = &quot;Disease&quot;, output_dir = &quot;figures&quot;, plot_name = &quot;pca_plot_ra_vs_normal.pdf&quot;, plot_width = 5, plot_height = 4 ) # 10b. Create upregulated RA boxplots and save as PDF boxplot_ra_up &lt;- data_long %&gt;% filter(Target %in% sig_targets_ra_up, SampleName %in% ra_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Upregulated Significant DE Targets - RA vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme_minimal() + theme(strip.text = element_text(size = 11)) ggsave( filename = &quot;boxplot_ra_upregulated.pdf&quot;, plot = boxplot_ra_up, device = &quot;pdf&quot;, path = &quot;figures&quot;, width = 12, height = 10 ) # 11b. Create downregulated RA boxplots and save as PDF boxplot_ra_down &lt;- data_long %&gt;% filter(Target %in% sig_targets_ra_down, SampleName %in% ra_samples) %&gt;% ggplot(aes(x = `Disease Type`, y = NPQ, fill = `Disease Type`)) + geom_boxplot() + facet_wrap(~ Target, scales = &quot;free_y&quot;) + labs(title = &quot;Downregulated Significant DE Targets - RA vs Normal&quot;, subtitle = &quot;with FDR-adjusted p &lt; 0.05&quot;, x = &quot;Disease Type&quot;, y = &quot;NPQ&quot;) + theme_minimal() + theme(strip.text = element_text(size = 11), axis.text.x = element_text(angle = 45, hjust = 1)) ggsave( filename = &quot;boxplot_ra_downregulated.pdf&quot;, plot = boxplot_ra_down, device = &quot;pdf&quot;, path = &quot;figures&quot;, width = 4, height = 3 ) # ============================================================================ # COMPARATIVE ANALYSIS AND EXPORT # ============================================================================ # 13. Analyze overlap between diseases shared_targets &lt;- intersect(sig_targets_sle, sig_targets_ra) sle_specific &lt;- setdiff(sig_targets_sle, sig_targets_ra) ra_specific &lt;- setdiff(sig_targets_ra, sig_targets_sle) # 14. Export all results to CSV write_csv(lmTest$modelStats, &quot;results/all_de_results.csv&quot;) # Export SLE results write_csv( lmTest$modelStats %&gt;% filter(target %in% sig_targets_sle), &quot;results/sig_sle_proteins.csv&quot; ) # Export RA results write_csv( lmTest$modelStats %&gt;% filter(target %in% sig_targets_ra), &quot;results/sig_ra_proteins.csv&quot; ) # Export overlap results write_csv( data.frame(target = shared_targets), &quot;results/shared_sle_ra_proteins.csv&quot; ) # 15. Print comprehensive summary cat(&quot;\\n========================================\\n&quot;) cat(&quot;DIFFERENTIAL EXPRESSION SUMMARY\\n&quot;) cat(&quot;========================================\\n\\n&quot;) cat(&quot;Quality Control:\\n&quot;) cat(&quot; Targets passing detectability threshold:&quot;, length(targets_passed), &quot;\\n\\n&quot;) cat(&quot;SLE vs Normal:\\n&quot;) cat(&quot; Total significant proteins:&quot;, length(sig_targets_sle), &quot;\\n&quot;) cat(&quot; Upregulated:&quot;, length(sig_targets_sle_up), &quot;\\n&quot;) cat(&quot; Downregulated:&quot;, length(sig_targets_sle_down), &quot;\\n\\n&quot;) cat(&quot;RA vs Normal:\\n&quot;) cat(&quot; Total significant proteins:&quot;, length(sig_targets_ra), &quot;\\n&quot;) cat(&quot; Upregulated:&quot;, length(sig_targets_ra_up), &quot;\\n&quot;) cat(&quot; Downregulated:&quot;, length(sig_targets_ra_down), &quot;\\n\\n&quot;) cat(&quot;Disease Comparison:\\n&quot;) cat(&quot; Shared significant targets:&quot;, length(shared_targets), &quot;\\n&quot;) cat(&quot; SLE-specific targets:&quot;, length(sle_specific), &quot;\\n&quot;) cat(&quot; RA-specific targets:&quot;, length(ra_specific), &quot;\\n\\n&quot;) cat(&quot;Output files created in:\\n&quot;) cat(&quot; - figures/ (all plots as PDFs)\\n&quot;) cat(&quot; - results/ (all statistical results as CSVs)\\n&quot;) cat(&quot;========================================\\n&quot;) "],["additional-resources.html", "Additional Resources NULISAseq Resources NULISA Analysis Software (NAS) Technical Documentation R Programming Resources Data Visualization Resources Citing This Book and Packages", " Additional Resources This chapter provides curated resources to help you get the most out of NULISAseq data analysis, including package documentation, R programming tutorials, visualization tools, and technical references. NULISAseq Resources Package Documentation The NULISAseqR package includes comprehensive documentation accessible directly from R: # Overall package documentation ?NULISAseqR # Function-specific help ?importNULISAseq # Data import ?lmNULISAseq # Linear modeling ?lmerNULISAseq # Linear mixed effect modeling ?lmNULISAseq_pred # Predictive modeling with lm ?glmNULISAseq # Generalized linear modeling ?generate_heatmap # Heatmap visualization ?generate_pca # PCA visualization ?volcanoPlot # Volcano plot visualization ?render_QC_report # QC report generation GitHub Repository NULISAseqR on GitHub: https://github.com/Alamar-Biosciences/NULISAseqR The GitHub repository includes: Latest package source code Example datasets and workflows Issue tracker for bug reports and feature requests Support and Issues Report bugs: GitHub Issues Request features: Open an issue on GitHub with the “enhancement” label Ask questions: Use GitHub Discussions or contact Alamar Biosciences support NULISA Analysis Software (NAS) NULISA Analysis Software (NAS) is Alamar Biosciences’ proprietary web-based platform for processing and analyzing NULISAseq data. NAS provides an intuitive interface for: Automated data processing: XML data file to normalized protein quantification or absolute quantification Quality control: Comprehensive QC metrics and visualization Interactive analysis: Real-time exploration of protein expression data Report generation: Automated QC and analysis reports Data export: Download processed data in various format NAS streamlines the initial data processing workflow, allowing researchers to quickly assess data quality and obtain normalized protein quantities (NPQ) before performing statistical analysis. Web Platform: NULISA Analysis Software (NAS) NAS Overview Video: NULISA Analysis Software (NAS) Training Access Required: Contact Alamar Biosciences support team to request an account Support: For NAS technical support or questions, contact the Alamar Biosciences support team at support@alamarbio.com Technical Documentation NULISAseq Technology Technical Notes https://alamarbio.com/support-center/search/?type=tech-notes&amp;category=data-analysis Information Sheet - NULISAseqTM Lot and Batch Definitions Definitions of lot and batch structures, validation data, and experimental design considerations for NULISAseq assays Tech Note - Performing relative quantitation of high-plex NULISAseq data NULISA data normalization, NPQ calculations, and statistical approaches used for relative quantification in multiplex NULISAseqTM assays Tech Note - NULISATM multiplex normalization &amp; quality control NPQ calculation steps, plate-level quality control metrics and additional normalization strategies for NULISAseqTM multiplex assays Tech Note - Capturing 12 logs dynamic range using NULISAseq Describes the assay tuning method incorporated by Alamar into NULISAseqTM panels to achieve broad dynamic range Tech Note - Determining the Absolute Concentration of High-Plex NULISAseq Protein Targets Calibration methodology, sample processing steps, and validation results for absolute quantification analysis using the NULISAseqTM Inflammation Panel AQ R Programming Resources Installing R and RStudio Required Software: R (the language): Download from CRAN Windows: Direct link macOS: Direct link Linux: Instructions RStudio (the IDE): Download from Posit Installation Order: Install R first, then RStudio. R and RStudio Resources and Tutorials R for Data Science by Hadley Wickham and Garrett Grolemund https://r4ds.had.co.nz/ Comprehensive introduction to the tidyverse Data import, wrangling, visualization, and modeling Free online book with exercises Hands-On Programming with R by Garrett Grolemund https://rstudio-education.github.io/hopr/ Beginner-friendly introduction to R programming Learn by building R projects Covers R basics, data structures, and functions RStudio Education https://education.rstudio.com/ Curated learning resources Cheat sheets for R packages Interactive tutorials Quick Reference Guides R Cheat Sheets https://www.rstudio.com/resources/cheatsheets/ Base R Data transformation (dplyr) Data visualization (ggplot2) R Markdown And many more Tidyverse Resources The tidyverse is essential for data manipulation and analysis in this book: Tidyverse Website https://www.tidyverse.org/ Package documentation Learning resources Blog with tips and updates dplyr Documentation https://dplyr.tidyverse.org/ Data manipulation verbs Working with grouped data Joining datasets tidyr Documentation https://tidyr.tidyverse.org/ Reshaping data (pivot_longer, pivot_wider) Handling missing values Nesting and unnesting data Data Visualization Resources ggplot2 ggplot2 is the primary visualization package used throughout this book. ggplot2 Official Documentation https://ggplot2.tidyverse.org/ Complete reference for all geoms and functions Articles on faceting, scales, themes, and extensions ggplot2: Elegant Graphics for Data Analysis by Hadley Wickham https://ggplot2-book.org/ Comprehensive guide to ggplot2 Theory and practice of the grammar of graphics Advanced customization techniques R Graphics Cookbook by Winston Chang https://r-graphics.org/ Recipe-style solutions for common plotting tasks Quick reference for plot types and customizations ggplot2 Extensions Gallery https://exts.ggplot2.tidyverse.org/ Showcase of ggplot2 extension packages Specialized plot types and themes ComplexHeatmap ComplexHeatmap is a powerful package for creating sophisticated heatmaps, extensively used in proteomics visualization. ComplexHeatmap Complete Reference https://jokergoo.github.io/ComplexHeatmap-reference/book/ Comprehensive guide to all features Examples for every visualization type Advanced customization options ComplexHeatmap Bioconductor Page https://bioconductor.org/packages/ComplexHeatmap/ Installation instructions Official documentation Vignettes and examples PCAtools PCAtools provides enhanced PCA visualization and analysis capabilities. PCAtools NULISAseq-specific features Alamar Biosciences fork of PCAtools by Kevin Blighe and Aaron Lun. Version compatible with NULISAseq-specific features and workflows. https://github.com/Alamar-Biosciences/PCAtools # Install version devtools::install_github(&quot;Alamar-Biosciences/PCAtools&quot;) Original package: https://github.com/kevinblighe/PCAtools PCAtools Bioconductor Page https://bioconductor.org/packages/PCAtools/ Comprehensive PCA analysis functions Scree plots, biplots, and loading plots Statistical tests for optimal PC selection Citing This Book and Packages Citing This Book Alamar Biosciences Bioinformatics Team. (2025). NULISAseq Data Analysis Guide. Alamar Biosciences. Available at: https://vignettes.nulisaseqr.alamarbio.com Citing R and Packages # Cite R citation() # Cite specific packages citation(&quot;NULISAseqR&quot;) citation(&quot;ggplot2&quot;) citation(&quot;ComplexHeatmap&quot;) citation(&quot;PCAtools&quot;) # Generate citation list for all loaded packages knitr::write_bib( c(.packages(), &quot;bookdown&quot;, &quot;knitr&quot;, &quot;rmarkdown&quot;), file = &quot;packages.bib&quot; ) Key Citations NULISAseq Platform and Tools NULISAseqR Package: Alamar Biosciences. (2025). NULISAseqR: Analysis Tools for NULISAseq Proteomic Data. R package. https://github.com/Alamar-Biosciences/NULISAseqR R Statistical Software: R Core Team (2024). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. https://www.R-project.org/ Alamar Biosicences: Alamar Biosciences. (2025). NULISA Platform and Proteomic Solutions. https://alamarbio.com/ Nature Communication aritcle on NULISAseq Technology: Feng, W., Beer, J.C., Hao, Q. et al. NULISA: a proteomic liquid biopsy platform with attomolar sensitivity and high multiplexing. Nat Commun 14, 7238 (2023). https://doi.org/10.1038/s41467-023-42834-x NULISATM Platform Video: Alamar Biosciences (2023). The NULISA™ Platform by Alamar Biosciences. YouTube. https://www.youtube.com/watch?v=24nVyCoJv4w NULISA Analysis Software Training Video: Alamar Biosciences (2023). The NULISA Analysis Software (NAS) Training by Alamar Biosciences. YouTube. https://www.youtube.com/watch?v=sS8oB8suRBk R and Packages R Statistical Software: R Core Team (2024). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. https://www.R-project.org/ tidyverse: Wickham H, Averick M, Bryan J, Chang W, McGowan LD, François R, Grolemund G, Hayes A, Henry L, Hester J, Kuhn M, Pedersen TL, Miller E, Bache SM, Müller K, Ooms J, Robinson D, Seidel DP, Spinu V, Takahashi K, Vaughan D, Wilke C, Woo K, Yutani H (2019). “Welcome to the tidyverse.” Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686 bookdown: Xie, Y. (2016). bookdown: Authoring Books and Technical Documents with R Markdown. Chapman and Hall/CRC. ISBN 978-1138700109. https://bookdown.org/yihui/bookdown/ ggplot2: Wickham, H. (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. ComplexHeatmap: Gu, Z., Eils, R., Schlesner, M. (2016). “Complex heatmaps reveal patterns and correlations in multidimensional genomic data.” Bioinformatics 32(18), 2847-2849. PCAtools: Blighe, K., Lun, A. (2022). PCAtools: Everything Principal Components Analysis. https://github.com/kevinblighe/PCAtools Happy analyzing! 🚀 We hope this book and these resources help you gain meaningful insights from your NULISAseq data. If you have questions or feedback, please reach out through the GitHub repository or contact Alamar Biosciences support at support@alamarbio.com. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
