---
params:
  ## internal control name(s) e.g. "mCherry", "NIC_1", "NIC_3" 
  # first IC will be used for LOD calculations (should typically be mCherry)
  IC: !r c("mCherry")
  ## string that denotes inter-plate controls
  # IPC: !r c("IPC")
  IPC: !r c("IPC_rep01", "IPC_rep02")
  ## string that denotes negative controls
  NC: !r c("NC")
  ## string that denotes sample controls
  # SC: !r c("SC")
  SC: !r c("IPC_rep03", "IPC_rep04")
  ## string that denotes bridge samples
  Bridge: !r NULL
  ## directory where xml files are located
  dataDir: "/Users/jbeer/github/TAP-Bonn-COVID/data"
  ## variables in XML that indicate row, column, and plate ID
  # rowAnnotName: "AUTO_WELLROW"
  # colAnnotName: "AUTO_WELLCOL"
  # plateAnnotName: "AUTO_PLATE"
  rowAnnotName: "Annot2"
  colAnnotName: "Annot3"
  plateAnnotName: "Annot1"
  ## should heatmaps show % median units?
  heatMapRel: !r TRUE
  study_name: "Study Name"
  assayName: "NULISAseq 200-plex Inflammation Panel"
  sample_desc: "This is a sample description."
  goal_desc: "NULISAseq 200-plex Inflammation Panel"
  xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml","20230109_TAP_covid_plate02_nononmatch_XML.xml")
  # xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml")
  ## manually set plate ID, otherwise plate ID will be 
  ## "Plate 1", "Plate 2", ... according to order of filenames 
  plateNames: !r c()
  ## type of report
  ## options:
  ## internal
  ## WebApp
  reportType: "internal"
output:
  html_document:
    toc: yes
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
library(gdata)
library(dplyr)
```

```{r, include=FALSE}
# function for colorizing wells in heatmap
wellorder <- function(samples, rowAnnotName, colAnnotName){
  cmd <- paste0("samples$", colAnnotName)
  cols <- eval(parse(text=cmd))
  cols <- formatC(as.numeric(cols), width=2, flag=0)
  cmd <- paste0("samples$", rowAnnotName)
  inds <- sort(paste0(eval(parse(text=cmd)), cols), index.return=TRUE)
  return(inds$ix)
}

# function to convert data into matrix for plate layout and heatmap
matrixify <- function(runSamples, rowAnnotName, colAnnotName, plate=FALSE){
  val <- matrix(rep(NA, 96), nrow=8)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  for(j in LETTERS[1:8]){
    for(k in 1:12){
      sample_jk <- runSamples$sampleName[runSamples[rowAnnotName]==j & runSamples[colAnnotName]==k]
      if(length(sample_jk)!=0){
        val[rownames(val)==j, colnames(val)==k] <- sample_jk
      }
      if(plate && length(sample_jk) == 0){
        val[rownames(val)==j, colnames(val)==k] <- ""
      }
    }
  }
  return(val)
}
```

```{r, include=FALSE}
# define title
title_var <- paste(params$study_name, params$assayName, sep='<br>')
# define sample specific boxplot colors for use in plots
boxplot_colors <- unlist(lapply(alamarColorPalette(n=5, tint='light', nReps=5), function(x) x[4]))
# set data directory
if(is.null(params$dataDir)){
  xmlFilesPath <- params$xmlFiles
} else {
  knitr::opts_knit$set(root.dir=params$dataDir)
  # save xml file path
  xmlFilesPath <- paste0(params$dataDir, "/", params$xmlFiles)
}
# define variables to store results
runs <- vector('list', length(params$xmlFiles))
runSummaries <- vector('list', length(params$xmlFiles))
read_summary <- NULL
# define plateIDs / plate names
if(length(params$plateNames) == 0){
  PlateNames <- paste0('Plate ', 1:length(params$xmlFiles))
} else {
  PlateNames <- params$plateNames
}
# read in XML files
for(i in 1:length(params$xmlFiles)){
  runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=PlateNames[i], 
                             NC=params$NC, SC=params$SC, IC=params$IC, 
                             IPC=params$IPC, Bridge=params$Bridge)
  # summarize each plate
  runSummaries[[i]] <- plateSummary(runs[[i]])
  read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
}
names(runs) <- names(runSummaries) <- PlateNames
colnames(read_summary) <- PlateNames
# transpose read summary
read_summary <- t(read_summary)
# set multiple file indicator
multipleFiles <- if(length(params$xmlFiles) > 1) TRUE else FALSE
# set SC indicator
indicatorSC <- if(is.null(params$SC) | sum(sapply(runs, function(x) length(x$SC)))==0) FALSE else TRUE
# set Bridge indicator
indicatorBridge <- if(is.null(params$Bridge) | sum(sapply(runs, function(x) length(x$Bridge)))==0) FALSE else TRUE
```

```{r, include=FALSE}
# do intra-plate normalization
intraPlateNormData <- vector("list", length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  intraPlateNormData[[i]] <- vector("list", length(params$IC))
  for (j in 1:length(params$IC)){
    intraPlateNormData[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                                                   method="IC",
                                                   IC=runs[[i]]$IC[j])
  }
  names(intraPlateNormData[[i]]) <- params$IC[j]
}
names(intraPlateNormData) <- PlateNames
```

```{r, include=FALSE}
# calculate LOD on the IC normalized data
# use 1st IC as the primary IC (should be mCherry)
plate_lod <- vector('list', length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  plate_lod[[i]] <- lod(data_matrix=intraPlateNormData[[i]][[1]]$normData, 
                        blanks=runs[[i]]$NC, 
                        min_count=0)
}
```

```{r, include=FALSE}
# do inter-plate normalization 
# save mCherry-normalized data in a list
normData <- lapply(intraPlateNormData, function(x) x[[1]]$normData)

# save IPC, NC, etc wells for each plate
IPC_wells <- lapply(runs, function(x) x$IPC)
NC_wells <- lapply(runs, function(x) x$NC)
SC_wells <- lapply(runs, function(x) x$SC)
Bridge_wells <- lapply(runs, function(x) x$Bridge)

# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')

# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                             IPC=FALSE, IN=TRUE,
                             IPC_wells=IPC_wells,
                             NC_wells=NC_wells)

if(indicatorBridge==TRUE){
  mCherry_Bridge <- interPlateNorm(data_list=normData,
                                   IPC=FALSE, IN=TRUE,
                                   IN_samples=Bridge_wells)
}
```

```{r, include=FALSE}
# calculate intra-plate CVs on unnormalized and mCherry normalized data
# using IPCs and SCs (sample controls) if present
IPC_intraCV_unnorm <- IPC_intraCV_mCherry <- NULL
if(indicatorSC==TRUE){
  SC_intraCV_unnorm <- SC_intraCV_mCherry <- NULL
}
# loop through plates and calculate CVs
for (i in 1:length(params$xmlFiles)){
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(runs[[i]]$samples))
  IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$SC] <- 'SC'
  }
  # unnormalized intraCV
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                  samples=IPC_SC_samples,
                                  aboveLOD=plate_lod[[i]]$aboveLOD,
                                  exclude_targets=runs[[i]]$IC)
  # combine plates into one matrix
  IPC_intraCV_unnorm <- cbind(IPC_intraCV_unnorm, plate_unnorm_intraCV[,'IPC']) 
  if(indicatorSC==TRUE){
    SC_intraCV_unnorm <- cbind(SC_intraCV_unnorm, plate_unnorm_intraCV[,'SC'])
  }
  # mCherry intraCV
  plate_mCherry_intraCV <- intraCV(data_matrix=intraPlateNormData[[i]]$mCherry$normData,
                                   samples=IPC_SC_samples,
                                   aboveLOD=plate_lod[[i]]$aboveLOD,
                                   exclude_targets=runs[[i]]$IC)
  # combine plates into one matrix
  IPC_intraCV_mCherry <- cbind(IPC_intraCV_mCherry, plate_mCherry_intraCV[,'IPC'])
  if(indicatorSC==TRUE){
    SC_intraCV_mCherry <- cbind(SC_intraCV_mCherry, plate_mCherry_intraCV[,'SC'])
  }
}

colnames(IPC_intraCV_unnorm) <- colnames(IPC_intraCV_mCherry) <- PlateNames
if(indicatorSC==TRUE){
  colnames(SC_intraCV_unnorm) <- colnames(SC_intraCV_mCherry) <- PlateNames
}

# function to summarize columns of a matrix
column_summary_stats <- function(x, rowNames=colnames(x)){
  output <- cbind(colMeans(x, na.rm=TRUE),
                  apply(x, 2, sd, na.rm=TRUE),
                  apply(x, 2, median, na.rm=TRUE),
                  apply(x, 2, min, na.rm=TRUE),
                  apply(x, 2, max, na.rm=TRUE),
                  apply(x, 2, function(y){
                    sum(is.na(y))
                  }))
  colnames(output) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
  rownames(output) <- rowNames
  return(output)
}

# create CV summary tables
IPC_intraCV_unnorm_summary_table <- column_summary_stats(IPC_intraCV_unnorm)
IPC_intraCV_mCherry_summary_table <- column_summary_stats(IPC_intraCV_mCherry)
if(indicatorSC==TRUE){
  SC_intraCV_unnorm_summary_table <- column_summary_stats(SC_intraCV_unnorm)
  SC_intraCV_mCherry_summary_table <- column_summary_stats(SC_intraCV_mCherry)
}

```

```{r, include=FALSE}
# calculate inter-plate CVs on unnormalized, mCherry normalized,
# and inter-plate normalized data
# using IPCs and SCs (sample controls) if present

# get input data lists
IPC_SC_samples_list <- lapply(runs, function(x) {
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(x$samples))
  IPC_SC_samples[colnames(x$Data) %in% x$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(x$Data) %in% x$SC] <- 'SC'
  }
  return(IPC_SC_samples)
})
plateData <- lapply(runs, function(x) x$Data)
plate_mCherry <- lapply(intraPlateNormData, function(x) x$mCherry$normData)
aboveLOD <- lapply(plate_lod, function(x) x$aboveLOD)
exclude_targets <- lapply(runs, function(x) x$IC)

# unnormalized interCV
interCV_unnorm <- interCV(data_list=plateData,
                          samples=IPC_SC_samples_list,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry interCV
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=IPC_SC_samples_list,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC interCV
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=IPC_SC_samples_list,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN interCV
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=IPC_SC_samples_list,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)


if(indicatorBridge==FALSE){
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_mCherry[,'IPC'],
                               interCV_mCherry_IPC[,'IPC'],
                               interCV_mCherry_IN[,'IPC'])
  
  colnames(IPC_interCV_results) <- c('unnorm',
                                     'mCherry',
                                     'mCherry + IPC',
                                     'mCherry + IN')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_mCherry[,'SC'],
                                interCV_mCherry_IPC[,'SC'],
                                interCV_mCherry_IN[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'mCherry',
                                      'mCherry + IPC',
                                      'mCherry + IN')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results)
  }
}


if(indicatorBridge==TRUE){
  # mCherry + Bridge
  interCV_mCherry_Bridge <- interCV(data_list=mCherry_Bridge$interNormData,
                                    samples=IPC_SC_samples_list,
                                    aboveLOD=aboveLOD,
                                    exclude_targets=exclude_targets,
                                    useMean=FALSE)
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_mCherry[,'IPC'],
                               interCV_mCherry_IPC[,'IPC'],
                               interCV_mCherry_IN[,'IPC'],
                               interCV_mCherry_Bridge[,'IPC'])
  
  colnames(interCV_results) <- c('unnorm',
                                 'mCherry',
                                 'mCherry + IPC',
                                 'mCherry + IN',
                                 'mCherry + Bridge')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_mCherry[,'SC'],
                                interCV_mCherry_IPC[,'SC'],
                                interCV_mCherry_IN[,'SC'],
                                interCV_mCherry_Bridge[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'mCherry',
                                      'mCherry + IPC',
                                      'mCherry + IN',
                                      'mCherry + Bridge')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results)
  }
}


```

```{r, include=FALSE}
# calculate detectability on regular samples only
# NOTE: we may also want to add detectability_summary for IPCs, SCs, and Bridge samples
detectability_summary <- detectability_targets <- NULL
for (i in 1:length(params$xmlFiles)){
  plate_detect <- detectability(aboveLOD_matrix=plate_lod[[i]]$aboveLOD,
                                sample_subset=runs[[i]]$SampleNames,
                                exclude_targets=runs[[i]]$IC)
  detectability <- cbind(length(runs[[i]]$SampleNames),
                         format(round(mean(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         format(round(sd(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         formatC(median(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(min(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(max(plate_detect$detectability, na.rm=TRUE), width=2),
                         paste0(sum(plate_detect$detectability >= 50),
                                ' (',
                                format(round(sum(plate_detect$detectability > 50)/length(plate_detect$detectability) * 100, 1), nsmall=1),
                                '%)'))
  colnames(detectability) <- c('# samples', 
                               'mean',
                               'sd',
                               'median',
                               'min',
                               'max',
                               '# of detectable targets (%)')
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_targets <- cbind(detectability_targets, plate_detect$detectability)
}

rownames(detectability_summary) <- colnames(detectability_targets) <- PlateNames

# if more than one plate, summarize across plates using weighted average
if(ncol(detectability_targets > 1)){
  plate_sample_size <- sapply(runs, function(x) length(x$SampleNames))
  plate_weights <- plate_sample_size / sum(plate_sample_size)
  detectability_targets <- cbind(detectability_targets,
                                 Overall=apply(detectability_targets, 1, function(x){
                                   sum(x*plate_weights)
                                 }))
  detectability_overall <- cbind(sum(plate_sample_size),
                                 format(round(mean(detectability_targets[,'Overall'], na.rm=TRUE), 1), nsmall=1),
                                 format(round(sd(detectability_targets[,'Overall'], na.rm=TRUE), 1), nsmall=1),
                                 formatC(median(detectability_targets[,'Overall'], na.rm=TRUE), width=2),
                                 formatC(min(detectability_targets[,'Overall'], na.rm=TRUE), width=2),
                                 formatC(max(detectability_targets[,'Overall'], na.rm=TRUE), width=2),
                                 paste0(sum(detectability_targets[,'Overall'] >= 50),
                                        ' (',
                                        format(round(sum(detectability_targets[,'Overall'] > 50)/length(detectability_targets[,'Overall']) * 100, 1), nsmall=1),
                                        '%)'))
  colnames(detectability_overall) <- c('# samples', 
                                       'mean',
                                       'sd',
                                       'median',
                                       'min',
                                       'max',
                                       '# of detectable targets (%)')
  rownames(detectability_overall) <- 'Overall'
  detectability_summary <- rbind(detectability_summary, detectability_overall)
  
}


```

```{r, include=FALSE}
# log transform and scale data for clustered heatmap
data_mCherry_log2_scaled <- list()
for(i in 1:length(params$xmlFiles)){
  # remove negative controls
  data_mCherry <- intraPlateNormData[[i]]$mCherry$normData
  data_mCherry <- data_mCherry[,!grepl(paste(params$NC, collapse="|"), colnames(data_mCherry))]
  # remove ICs
  data_mCherry <- data_mCherry[!grepl(paste(params$IC, collapse="|"), rownames(data_mCherry)),]
  # log transform and scale targets (need to transpose matrix to scale and transpose back)
  data_mCherry_log2_scaled[[i]] <- t(scale(t(log2(data_mCherry+0.01)),
                                           center=TRUE, scale=TRUE))
}
```

---
title: `r title_var`
---
```{r, results='asis', eval=params$reportType!="WebApp"}
pandoc.header("Study summary", 2)
elements <- c(paste("Goal:", params$goal_desc), paste("Sample Description:", params$sample_desc))
pandoc.list(elements, style="bullet")
```


## Plate layout
```{r, results='asis'}
pandoc.p("Shows the layout of samples, controls (NC, IPC), and special wells if any (e.g. sample controls (SC), bridge samples) on the 96 well assay plate" )
for(i in 1:length(params$xmlFiles)){
  val <- matrixify(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){      well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){  well_types <- append(well_types, list(Bridge_wells[[i]]))}
  
  for (j in 1:length(well_types)){
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space for text wrapping
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate Layout"), 
                   align="c", escape=FALSE, table.attr=table.attr) %>%
        kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE) %>%
        column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
        row_spec(0:8, extra_css = "border-bottom: 1px solid") 
  )
}
```

---

## Read summary
```{r, results='asis'}
pandoc.p("Summary of the number and classification of reads for the assay run") 
pandoc.list(c("Parseable - Valid next generation sequencing (NGS) read (assay signal or background)",
              "Parseable Match - Valid NGS read (assay signal)",
              "Parseable Non-match - Vaild NGS read (assay background)",
              "Unparseable - Sequencing background",
              "Total samples - Total number of samples on plate (including controls)",
              "Total targets - Total number of assay targets (including internal controls)",
              "Zero values - Number of targets * samples which had no assay signal"
))
knitr::kable(read_summary, caption='', 
             align='r', format.args=list(big.mark = ","), 
             table.attr="id=\"read-summary\"") %>% 
  kable_styling(bootstrap_options=c("striped", "hover", "condensed"), full_width=TRUE)
```

---

### Internal controls (IC)
```{r, results='asis'}
pandoc.p("Each sample of the assay is spiked with the same concentration of an internal control (IC). This is used both as part of a well normalization procedure and as a method for assessing the uniformity of the assay run.") 
if(length(params$IC) == 1){
  IC_tables <- NULL
  for (i in 1:length(params$xmlFiles)){
    IC_tables <- rbind(IC_tables, runSummaries[[i]]$IC_table)
  }
  rownames(IC_tables) <- paste0("Plate", as.character(1:length(params$xmlFiles))) 
  cat(knitr::kable(IC_tables, 
                   caption="mCherry (IC) summary", 
                   align='r', 
                   format.args=list(big.mark = ","), 
                   table.attr="id=\"IC-summary\"") %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))  
} else {
  for(i in 1:length(params$xmlFiles)){
    table.attr <- paste0("id=\"IC-summary", i, "\"")
    cat(knitr::kable(runSummaries[[i]]$IC_table, 
                     caption=paste0("Plate ", as.character(i), ": IC summary"), 
                     align='r', 
                     format.args=list(big.mark = ","), 
                     table.attr=table.attr) %>% 
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```

---

### Inter-plate controls (IPC)
```{r, results='asis'}
pandoc.p("IPC samples are pooled plasma controls used both to normalize samples between experiments and to assess performance (e.g., precision) of the assay.")
pandoc.p("Note: %CV in this table does not exclude values below LOD. See [Intra-plate normalization](#intraPlateNorm) or [Inter-plate normalization](#interPlateNorm) sections for %CV (before and after normalization) that excludes values below LOD.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"IPC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

### Negative controls (NC) 
```{r, results='asis'}
pandoc.p("NC wells are reactions where no sample input is provided (i.e., buffer only). These are used to assess Limit of Detection (LOD) for each target assay and to assess run quality (e.g., background levels).")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"NC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

```{r eval=indicatorSC, results='asis'}
pandoc.header("Sample controls (SC)", 3)
pandoc.p("SC samples are pooled plasma controls from an independent pooled plasma source that is different from IPCs. They could be a pooled sample derived from all study samples, for example. They should be from the same source across all plates that will be analysed together. SCs are used for calculating intra- and inter-plate coefficient of variation (CV). They are necessary for obtaining an unbiased measure of inter-plate CV when IPC normalization is used.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"SC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$SC_table, caption=paste0("Plate ", as.character(i), ": SC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

```{r eval=indicatorBridge, results='asis'}
pandoc.header("Bridge samples (Bridge)", 3)
pandoc.p("Bridge samples can be used for inter-plate normalization. Bridge sample normalization uses the bridge sample subset to estimate plate- and target-specific medians, and then uses these medians to normalize all samples in a manner similar to intensity normalization.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"Bridge-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$Bridge_table, caption=paste0("Plate ", as.character(i), ": Bridge summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

## Heatmaps
```{r, out.width='100%', fig.asp=0.33333*ceiling((length(params$IC)+1)/2), results='asis'}
heatmap_description <- if (params$heatMapRel==TRUE) "percent relative to plate median" else "absolute normalized read count"
pandoc.p(paste0("Heatmaps show the ", heatmap_description, " for log2(total counts) and the specified internal control."))
for(i in 1:length(params$xmlFiles)){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  val <- matrixify(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName)
  vals <- unlist(as.list(t(val)))
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsmCherry <- if(params$heatMapRel) 1 else 0
  logVals <- log2(colSums(runs[[i]]$Data, na.rm=TRUE))
  well_order <- wellorder(runs[[i]]$sample, params$rowAnnotName, params$colAnnotName)
  val <- vals
  val[which(!is.na(vals))] <- logVals[well_order]
  plateHeatmap(as.numeric(val), 
               title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), 
               cex=0.5, digits=1,
               relative=params$heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    val <- vals
    val[which(!is.na(vals))] <- runs[[i]]$Data[ICs[j],][well_order]
    plateHeatmap(as.numeric(val), 
                 title=paste0("Plate ", as.character(i),": ",  params$IC[j]), 
                 cex=0.5, digits=digitsmCherry, 
                 relative=params$heatMapRel, cex.axis=0.5)
  }
}
```

---

## Quality control

### Plate QC

```{r, results='asis'}
pandoc.p("Plate-specific QC criteria:")
pandoc.list(c(paste0("ICRead_CV - Coefficient of Variation of internal control signal across all samples (maximum = ", QCPlateCriteria()$thresholds['ICRead_CV']*100,"%)"),
              paste0("IPCRead_CV - Coefficient of Variation of the total assay signal across all IPCs (maximum = ", QCPlateCriteria()$thresholds['IPCRead_CV']*100,"%)"),
              paste0("IPCTarget_CV - Median Coefficient of Variation of all IPC targets (maximum = ", QCPlateCriteria()$thresholds['IPCTarget_CV']*100,"%)"),
              paste0("Detectability - Percentage of targets that are detectable (target is considered detectable if > 50% samples have signal > LOD) (minimum = ",  QCPlateCriteria()$thresholds['Detectability']*100,"%)"),
              paste0("MinReads - Number of total Parseable Match reads (signal) for the experiment (minimum = ", QCPlateCriteria()$thresholds['MinReads'],")"
              )))
pandoc.p("QC criteria are assessed either on unnormalized (raw) or IC-normalized (IC) data")

for( i in 1:length(runs)){
  qcPlate <- QCFlagPlate(runs[[i]]$Data, normData[[i]], runs[[i]]$targets, runs[[i]]$samples)
  table.attr <- paste0("id=\"QCFlagPlate-summary", i, "\"")
  qcPlate$status[which(qcPlate$status == "F")] <- "Pass"
  qcPlate$status[which(qcPlate$status == "T")] <- "Fail"
  qcPlate$QCthreshold[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$QCthreshold[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$QCthreshold[nrow(qcPlate)] <- format(as.numeric(qcPlate$QCthreshold[nrow(qcPlate)]), big.mark=",")
  qcPlate$val[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$val[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$val[nrow(qcPlate)] <- format(as.numeric(qcPlate$val[nrow(qcPlate)]), big.mark=",")
  cat(knitr::kable(qcPlate[,1:ncol(qcPlate)-1], 
                   caption=paste0("Plate ", as.character(i), ": Plate QC Flag Summary"), 
                   align='r', 
                   format.args=list(big.mark = ",", digits=2),
                   table.attr=table.attr,
                   col.names = c("Flag Name", "Normalization", "QC Status", "QC Value", "QC Threshold"
                   )) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) %>%
        row_spec(which(qcPlate$status == "Fail"), bold=T, color="white", background="red"))
}
```

### Sample QC 
#### Sample QC summary table
```{r, out.width='100%', fig.asp=2, results='asis'}
pandoc.p("Sample-specific QC criteria:")
pandoc.list(c(paste0("Detectability - Percentage of targets above LOD for a sample (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability'])*100,"%)"),
              paste0("ICReads - Number of IC reads for a sample (minimum = ", QCSampleCriteria()$thresholds['ICReads'],")"),
              paste0("NumReads - Number of total Parseable Match (signal) reads for a sample (minimum = ", QCSampleCriteria()$thresholds['NumReads'],")"),
              paste0("IC_Median - % deviation from the overall plate median IC reads (within +/-", as.numeric(unlist(strsplit(QCSampleCriteria()$thresholds['IC_Median'], ',')))[2]*100, "% of plate median)")
))

rmin <- rmax <- val <- list()
criteria <- QCSampleCriteria()
rowNameQC <- c()
QCSummary <- matrix(nrow=length(runs)+1, ncol=length(criteria$thresholds)+1)
for (i in 1:length(runs)){
  QCSummary[i, 1] <- ncol(runs[[i]]$Data)
  rowNameQC <- c(rowNameQC,  paste0("Plate ", as.character(i))) 
}

for (j in 1:length(criteria$thresholds)){
  for (i in 1:length(runs)){
    well_order <- wellorder(runs[[i]]$sample, params$rowAnnotName, params$colAnnotName)
    qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
    inds <- which(qcSample$flagName == names(criteria$thresholds)[j])
    val[j] <- if(names(criteria$thresholds)[j] == "Detectability") as.numeric(criteria$thresholds[j])*100 else criteria$thresholds[j]
    if(names(criteria$thresholds)[j] == "Detectability"){
      xval <- as.numeric(qcSample[inds, ]$val)*100
      rmax[j] <- 100.0
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=T) 
    }else if (names(criteria$thresholds)[j] == "IC_Median"){
      xval <- as.numeric(qcSample[inds, ]$val)*100
      minmaxVal <- unlist(strsplit(val[[j]], ","))
      rmin[j] <- min(as.numeric(minmaxVal[1])*100, as.numeric(xval), na.rm=T)
      rmax[j] <- max(as.numeric(minmaxVal[2])*100, as.numeric(xval), na.rm=T)
    }else{
      xval <- as.numeric(qcSample[inds, ]$val)
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=T)
      rmax[j] <- max(as.numeric(val[[j]]), as.numeric(xval), na.rm=T)
    }
    QCSummary[i, j+1] <- length(which(qcSample[inds,]$status == "T"))
  }
}
QCSummary[i+1, ] <- colSums(QCSummary, na.rm=T) 
rownames(QCSummary) <- c(rowNameQC, "Total")
colnames(QCSummary) <- c("# of Samples", names(criteria$thresholds))

# print sample QC summary table
knitr::kable(QCSummary, caption='', 
             align='r', 
             table.attr="id=\"QC-summary-table\"",
             format.args=list(big.mark = ",", digits=2, escape=FALSE)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

for( i in 1:length(runs)){
  well_order <- wellorder(runs[[i]]$sample, params$rowAnnotName, params$colAnnotName)
  # Sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  if(indicatorSC){
    inds <- which(grepl(paste(params$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(params$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }
  par(mfrow=c(ceiling(length(criteria$thresholds)/2), 2), mar=c(5,6,2,2))
  for(j in 1:length(names(criteria$thresholds))){
    inds <- which(qcSample$flagName == names(criteria$thresholds)[j])
    color <- rep("black", length(inds))
    xlab <- ""
    xval <- NULL
    if(names(criteria$thresholds)[j] == "Detectability"){
      xlab <- "Detectability %"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    }else if(names(criteria$thresholds)[j] == "IC_Median"){
      xlab <- "% of mCherry Median"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    }else{
      xlab <- "Number of Reads"
      xval <- qcSample[inds, ]$val
      zs <- which(xval == 0)
      if(length(zs) > 0){
        xval[zs] <- xval[zs]+1
      }
    }
    color[which(qcSample[inds,]$sampleType == "IPC")] <- boxplot_colors[2]
    color[which(qcSample[inds,]$sampleType == "NC")] <- boxplot_colors[3]
    if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "SC")] <- boxplot_colors[4]
    }
    if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "Bridge")] <- boxplot_colors[5]
    }
    
    log <- if(names(criteria$thresholds)[j] != "Detectability" && names(criteria$thresholds)[j] != "IC_Median") "x" else ""
    par(mar=c(5,6,2,2))
    dotchart(x=as.numeric(xval), xlab=xlab, 
             labels=qcSample[inds, ]$sampleName, las=1, 
             cex=0.45, xlim=c(rmin[[j]], rmax[[j]]), color=color, log=log)
    xvalFail <- xval
    xvalFail[which(qcSample[inds,]$status != "T")] <- NA
    xvalPass <- xval
    xvalPass[which(qcSample[inds,]$status != "F")] <- NA
    points(as.numeric(xvalPass),1:length(xvalPass), pch=19, col="green")
    points(as.numeric(xvalFail),1:length(xvalFail), pch=19, col="red")
    if(names(criteria$thresholds)[j] == "IC_Median"){
      minmaxVal <- unlist(strsplit(val[[j]], ","))
      abline(v=as.numeric(minmaxVal[[1]])*100, col='brown')
      abline(v=as.numeric(minmaxVal[[2]])*100, col='brown')
    }else{
      abline(v=val[[j]], col='brown')
    }
    legend('bottomright', legend=c('Pass', "Fail"), col=c('green', 'red'), pch=19, cex=0.4, bty='n', inset=c(0,1), xpd=T,horiz=T)
    title(main=paste0("Plate ", as.character(i), ": ", names(criteria$thresholds)[j]))
  } 
}
```

---

## Detectability
Target detectability is the percentage of samples that are above the limit of detection for that target. Target detectability reported here excludes IPCs, SCs, and bridge samples. A target is considered "detectable" if it is above limit of detection in at least 50% of samples. "Overall" detectability is the total number of samples across all plates that are above LOD for a given target. 
```{r, echo=FALSE}
# calculate fig.asp for detectability plots
detect_fig_asp <- 2*ceiling(length(params$xmlFiles)/2)
```

```{r, results='asis', out.width='100%', fig.asp=detect_fig_asp}
# Detectability summary
kable_styling(knitr::kable(detectability_summary, caption='Detectability Summary', 
                           align='r', 
                           table.attr="id=\"detectability-summary\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

# Target detectability
kable_styling(knitr::kable(detectability_targets, caption='Target Detectability %', 
                           align='r', 
                           table.attr="id=\"detectability-indepth\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) 

# Target Boxplot
pandoc.header("Target Detectability Boxplot", 3)
pandoc.p("Shows target mCherry-normalized count distributions relative to LOD.")
par(mfrow=c(ceiling(length(params$xmlFiles)/2), 2), mar=c(4,3,2,2))
for (i in 1:length(params$xmlFiles)){
  targetBoxplot(runs[[i]]$Data, 
                title=PlateNames[i], 
                subtractLOD=TRUE, 
                blanks=runs[[i]]$NC, 
                horizontal=TRUE, 
                cex.targets=0.25, 
                excludeTargets=runs[[i]]$IC, 
                excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC))
}
```

---

## Intra-plate normalization {#intraPlateNorm}
%CV was calculated for each target (excluding internal controls) for the IPC and / or sample control replicates. Only values above LOD were used to calculate %CV. 

```{r, eval=(params$reportType=="internal" & indicatorSC==TRUE)}
pandoc.header("SC Intra-plate %CV table -- unnormalized", 3)
knitr::kable(SC_intraCV_unnorm_summary_table, caption='', align='r', table.attr="id=\"intra-plateCV-unnormalized-summary\"", 
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

```{r, eval=params$reportType=="internal" & indicatorSC==TRUE}
pandoc.header("SC Intra-plate %CV table -- mCherry-normalized", 3)
knitr::kable(SC_intraCV_mCherry_summary_table, caption='', align='r', table.attr="id=\"intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

### Intra-plate %CV boxplots by plate
```{r, out.width='100%', fig.asp=0.25*length(runs)}
SC_intraCV_unnorm2 <- SC_intraCV_unnorm
colnames(SC_intraCV_unnorm2) <- paste0(colnames(SC_intraCV_mCherry), ' unnormalized')
SC_intraCV_mCherry2 <- SC_intraCV_mCherry
colnames(SC_intraCV_mCherry2) <- paste0(colnames(SC_intraCV_mCherry), ' mCherry-normalized')
SC_intraCV_vals <- t(interleave(t(SC_intraCV_unnorm2), t(SC_intraCV_mCherry2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(SC_intraCV_vals[1,])/2), nReps=2)))
par(mar=c(5, 7, 2, 1))
boxplot(SC_intraCV_vals[,ncol(SC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(SC_intraCV_vals), na.rm=TRUE)),
        main='Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

## Sample boxplots
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Sample boxplots show distributions of the log2 counts for each sample, unnormalized and after mCherry + IPC normalization.")

# function to draw boxplot
sampleboxplot <- function(data, ordering, label, plate_sample_colors, boxplot_colors){
  par(mar=c(2,6,2,0.5))
  boxplot(log2(data[,ordering]+0.01),
          las=1, 
          yaxt='n',
          xaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": ", label),
          outcex=0.5,
          col=plate_sample_colors, 
          horizontal=TRUE, 
          cex=0.5,
          cex.main=0.75,
          cex.lab=0.75)
  for (j in 1:ncol(data)){
    color <- if(plate_sample_colors[j] == boxplot_colors[1]) "black" else plate_sample_colors[j]
    axis(2, at=j, labels=FALSE, cex.axis=0.3, las=2, col.axis=color, tck=-0.01)
    axis(2, at=j, labels=colnames(data)[ordering[j]], cex.axis=0.3, las=2, col.axis=color, tick=FALSE, line=-0.75)
  }
  axis(side=1, labels=FALSE, tck=-0.01)
  axis(side=1, labels=TRUE, cex.axis=0.5, line=-1, tick=FALSE)
  # add mCherry line
  lines(cbind(log2(data['mCherry', ordering]+0.01), 1:ncol(data)), col='red', las=1)
  mtext('log2(count + 0.01)', side=1, line=0.75, cex=0.5)
  legend('topleft', 'mCherry', col='red', lty=1, cex=0.4, bty='n')
  abline(v=c(-50:50*5), col='grey', lty=3)
}

for(i in 1:length(params$xmlFiles)){
  plate_sample_type <- rep("1_sample", ncol(runs[[i]]$Data))
  plate_sample_type[grepl(paste0(IPC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '3_IPC'
  # put NCs last
  plate_sample_type[grepl(paste0(NC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '6_NC'
  # put colors in order 
  boxplot_colors2 <- boxplot_colors[c(1,2,3)]
  if(indicatorSC){
    plate_sample_type[grepl(paste0(SC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '4_SC'
    boxplot_colors2 <- boxplot_colors[c(1,2,4,3)]
  }
  if(indicatorBridge){
    plate_sample_type[grepl(paste0(Bridge_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '5_Bridge'
    boxplot_colors2 <- boxplot_colors[c(1,2,5,3)]
  }
  if(indicatorSC & indicatorBridge){
    boxplot_colors2 <- boxplot_colors[c(1,2,4,5,3)]
  }
  ordering2 <- wellorder(runs[[i]]$samples, params$rowAnnotName, params$colAnnotName) 
  ordering <- NULL
  types <- sort(unique(plate_sample_type))
  for(j in 1:length(types)){
    inds <- which(plate_sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }
  # reverse ordering so special wells are at the bottom
  ordering <- rev(ordering)
  plate_sample_colors <- boxplot_colors2[as.numeric(as.factor(plate_sample_type))[ordering]]
  numPlots <- if(params$reportType == "internal") 2 else 1
  par(mfrow=c(1,numPlots), mar=c(4,6,2,0))
  if(params$reportType == "internal"){
    sampleboxplot(runs[[i]]$Data, ordering, "unnormalized", plate_sample_colors, boxplot_colors2)
  }
  sampleboxplot(mCherry_IPC$interNormData[[i]], ordering, "mCherry + IPC", plate_sample_colors, boxplot_colors2)
}
```

---

## Sample correlation
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Plot shows the Pearson correlation between samples. Heirarchical clustering is done using complete linkage.")
wellcolors <- function(data, well_types, boxplot_colors){
  # all labels black by default
  colors <- rep("black", ncol(data))
  for (j in 1:length(well_types)){
    # save indices matching the given well type
    indices <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    # color well label to match well type
    if(length(indices) > 0){
      colors[indices] <- boxplot_colors[j+1]
    }
  }
  return(colors)
}

for(i in 1:length(params$xmlFiles)){
  pdf(file=NULL)
  corrvals <- corrplot(cor(intraPlateNormData[[i]]$mCherry$normData), 
                       order='hclust') 
  dev.off()
  
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  colors <- wellcolors(data=corrvals$corr, 
                       well_types=well_types, 
                       boxplot_colors=boxplot_colors)
  corrplot(corrvals$corr,
           tl.cex=0.4,
           mar=c(1,1,1,1),
           tl.col=colors,
           order="original",
           title=paste("Plate", i),
           is.corr=FALSE)
  cat("\n")
}
```

---

## Sample and target clustering 
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Hierarchical clustering of both samples and targets using a Euclidean distance metric and complete linkage. Data is log2 and mCherry-normalized; targets are centered and scaled.")
# define colors
paletteLength <- 50
heatmapColors <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
# loop over plates and draw heatmaps
for(i in 1:length(params$xmlFiles)){
  # define label colors
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  label_colors <- wellcolors(data=data_mCherry_log2_scaled[[i]], 
                             well_types=well_types, 
                             boxplot_colors=boxplot_colors)
  # define color scale breaks
  breaks <- c(seq(min(data_mCherry_log2_scaled[[i]]), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_log2_scaled[[i]])/paletteLength, 
                  max(data_mCherry_log2_scaled[[i]]), length.out=floor(paletteLength/2)))
  # transpose and add color variable
  data_mCherry_log2_scaled2 <- data.frame(t(data_mCherry_log2_scaled[[i]]))
  data_mCherry_log2_scaled2$label_colors <- label_colors
  # generate heatmap for plate i
  heatmap_i <- pheatmap(data_mCherry_log2_scaled2[,1:(ncol(data_mCherry_log2_scaled2) - 1)],
                        main = paste("Plate", i), 
                        fontsize=5,
                        color=heatmapColors,
                        breaks=breaks,
                        show_colnames=FALSE, silent=TRUE)
  # put colors in order
  label_colors_ordered <- data_mCherry_log2_scaled2[order(match(rownames(data_mCherry_log2_scaled2), heatmap_i$gtable$grobs[[5]]$label)),]$label_colors
  # add label colors to plot
  heatmap_i$gtable$grobs[[5]]$gp=gpar(col=label_colors_ordered)
  grid::grid.newpage()
  grid::grid.draw(heatmap_i$gtable)
  cat("\n")
}
```

---

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate normalization {#interPlateNorm}", 2)
cat("%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV.")
```

```{r eval=multipleFiles, results='asis'}
pandoc.header("SC Inter-plate %CV", 3)
if(params$reportType != "internal"){
  remove <- "mCherry + IN"
  SC_interCV_summary_table2 <- SC_interCV_summary_table[!(rownames(SC_interCV_summary_table) %in% remove),]
  SC_interCV_results2 <- SC_interCV_results[, !(colnames(SC_interCV_results) %in% remove)]
}else{
  SC_interCV_summary_table2 <- SC_interCV_summary_table
  SC_interCV_results2 <- SC_interCV_results
}
knitr::kable(SC_interCV_summary_table2, caption='', 
             align='r', 
             table.attr="id=\"inter-plateCV-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

```{r out.width='100%', fig.asp=0.5, eval=multipleFiles, results='asis'}
pandoc.header("SC Inter-plate %CV boxplot", 3)
par(mar=c(5,12,1,1))
boxplot(SC_interCV_results2[,ncol(SC_interCV_results2):1], las=1, xlab='inter-plate CV (%)',
        ylim=c(0, max(SC_interCV_results2, na.rm=TRUE)), 
        col=rev(alamarColorPalette(ncol(SC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

```{r, out.width='100%', fig.asp=(0.4)+as.numeric(multipleFiles)*0.4, results='asis', eval=params$reportType=="internal"}
pandoc.header("Sample PCA", 2)
PCAplot <- function(data, plateID, scale=TRUE, center=TRUE, title=NULL){
  pca <- prcomp(log2(t(data)+0.01), scale=scale, center=center)
  par(mar=c(4,4,2,5))
  plateID <- factor(plateID)
  colors <- alamarColorPalette(length(levels(plateID)))
  IPC_samples <- grep(paste(params$IPC, collapse="|"), colnames(data))
  point_shapes <- rep(1, ncol(data))
  point_shapes[IPC_samples] <- 8
  legendText <- c(levels(plateID), 'Sample', 'IPCs')
  legend_point_shapes <- rep(1, (length(levels(plateID)) + 1))
  legend_point_shapes <- c(legend_point_shapes, 8)
  if(indicatorSC==TRUE){
    SC_samples <- grep(paste(params$SC, collapse="|"), colnames(data))
    point_shapes[SC_samples] <- 9
    legendText <- c(legendText, "SCs")
    legend_point_shapes <- c(legend_point_shapes, 9)
  }
  if(indicatorBridge==TRUE){
    Bridge_samples <- grep(paste(params$Bridge, collapse="|"), colnames(data))
    point_shapes[Bridge_samples] <- 10
    legendText <- c(legendText, "Bridge")
    legend_point_shapes <- c(legend_point_shapes, 10)
  }
  
  legend_colors <- c(colors, rep('black', (length(legend_point_shapes) - length(colors))))
  
  plot(pca$x[,1], pca$x[,2],
       col=colors[as.integer(plateID)],
       pch=point_shapes,
       xlab=paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), 
                   '% variance)'),
       ylab=paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), 
                   '% variance)'),
       main=title, las=1, cex=0.5)
  legend(par('usr')[2], par('usr')[4], 
         legendText,
         col=legend_colors, xpd=NA,
         pch=legend_point_shapes, cex=0.75, bty='n')
}

removeTargetsSamples <- function(data, NC){
  data <- data[-which(grepl("mCherry", rownames(data))),]
  data <- data[,-which(grepl(paste(NC, collapse="|"), colnames(data)))]
  return(data)
}

dataPCA_unnorm <- dataPCA_mCherry <- dataPCA_mCherryIPC <- dataPCA_mCherryIN <- plateID <- NULL
for(i in 1:length(params$xmlFiles)){
  dataPCA_unnorm <- cbind(dataPCA_unnorm, removeTargetsSamples(runs[[i]]$Data, params$NC))
  dataPCA_mCherry <- cbind(dataPCA_mCherry, removeTargetsSamples(intraPlateNormData[[i]][[1]]$normData, params$NC))
  dataPCA_mCherryIPC <- cbind(dataPCA_mCherryIPC, removeTargetsSamples(mCherry_IPC$interNormData[[i]], params$NC))
  dataPCA_mCherryIN <- cbind(dataPCA_mCherryIN, removeTargetsSamples(mCherry_IN$interNormData[[i]], params$NC))
  plateID <- c(plateID, rep(paste0("Plate",i), ncol(dataPCA_unnorm)))
}

nRowsPCA <- if(multipleFiles) 2 else 1
nCols <- 2
par(mfrow=c(nRowsPCA, nCols))
PCAplot(dataPCA_unnorm, plateID, scale=TRUE, center=TRUE, title="Unnormalized")
PCAplot(dataPCA_mCherry, plateID, scale=TRUE, center=TRUE, title="mCherry")
if(multipleFiles){
  PCAplot(dataPCA_mCherryIPC, plateID, scale=TRUE, center=TRUE, title="mCherry + IPC")
  if(params$reportType == "internal"){
    PCAplot(dataPCA_mCherryIN, plateID, scale=TRUE, center=TRUE, title="mCherry + IN")
  }
}
```
