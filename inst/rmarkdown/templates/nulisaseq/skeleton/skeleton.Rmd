---
params:
  study_name: "Study Name"
  assayName: "NULISAseq 200-plex Inflammation Panel"
  ## directory where xml files are located
  dataDir: "."
  ## XML file names
  xmlFiles: !r c("detectability_P1_Tr03.xml","detectability_P2_Tr03.xml")
  dataRuns: NULL 
  ## manually set plate ID, otherwise plate ID will be 
  ## "Plate 1", "Plate 2", ... according to order of filenames 
  plateNames: !r c()
  ## type of report
  ## options:
  ## internal
  ## WebApp
  reportType: "internal"
  ## internal control name(s) e.g. "mCherry", "NIC_1", "NIC_3" 
  # first IC will be used for LOD calculations (should typically be mCherry)
  IC: !r c("mCherry")
  ## string(s) that denotes inter-plate controls
  IPC: !r NULL # c("IPC")
  ## string(s) that denotes negative controls
  NC: !r NULL # c("NC") 
  ## string(s) that denotes sample controls
  SC: !r NULL # c("SC")
  ## string(s) that denotes bridge samples
  Bridge: !r NULL
  ## variables in XML that indicate row, column, and plate ID
  rowAnnotName: "AUTO_WELLROW"
  colAnnotName: "AUTO_WELLCOL"
  plateAnnotName: "AUTO_PLATE"
  ## older version names for row, column, plate ID variables
  # rowAnnotName: "Annot2"
  # colAnnotName: "Annot3"
  # plateAnnotName: "Annot1"
  # optional list of names of samples to exclude
  ## excludeSamples: !r list(c('A_01_C001 P3', 'A_02_C044 P1'), c('A_01_C040 P1'))
  excludeSamples: !r NULL
  ## excludeTargets: !r list(c('IL16', 'IL9'), c('KDR'))
  excludeTargets: !r NULL
  ## sampleGroupCovar -- Specify the covariate to retrieve sample group information.
  # this information is used when determining detectability.
  # defaults to NULL.
  # for testing sampleGroupCovar: "AUTO_WELLROW"
  # sampleGroupCovar: "CONDITION_1"
  sampleGroupCovar: !r NULL  # could be something like SAMPLE_MATRIX
  outPlateLayout: !r TRUE
  outReadSummary: !r TRUE
  outHeatmaps: !r TRUE
  outQC: !r TRUE
  outDetectability: !r TRUE
  outIntraPlateNorm: !r TRUE
  outSampleBoxplot: !r TRUE
  outSampleCorrelation: !r TRUE
  outSampleClustering: !r TRUE
  outInterPlateNorm: !r TRUE
  outSamplePCA: !r TRUE
  ## should heatmaps show % median units?
  heatMapRel: !r TRUE
  ## outputPlots -- if TRUE will output a set of plots in a nice format for slides
  outputPlots: !r TRUE
  ## outputDetectCSV
  # if TRUE, outputs a CSV file with detectability for each target and sample type
  outputDetectCSV: !r TRUE
  ## set to TRUE if this is being rendered by a Shiny wrapper (adds progress bar)
  rendered_by_shiny: !r FALSE
output:
  html_document:
    toc: yes
    toc_depth: 4
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
library(gdata)
library(dplyr)
```


```{r, include=FALSE}
# function for colorizing wells in heatmap
# sampleTypeFactor should have levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC')
wellorder <- function(samples, sampleTypeFactor=NULL){
  cols <- formatC(as.numeric(samples$AUTO_WELLCOL), width=2, flag=0)
  rows <- samples$AUTO_WELLROW
  inds <- if(is.null(sampleTypeFactor)){
    sort(paste0(rows, cols), index.return=TRUE)
  } else sort(paste0(as.numeric(sampleTypeFactor), rows, cols), index.return=TRUE)
  return(inds$ix)
}

wellcolors <- function(data, well_types, boxplot_colors){
  # all labels black by default
  colors <- rep("black", ncol(data))
  for (j in 1:length(well_types)){
    # save indices matching the given well type
    indices <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    # color well label to match well type
    if(length(indices) > 0){
      colors[indices] <- boxplot_colors[j+1]
    }
  }
  return(colors)
}

# function to convert data into matrix for plate layout and heatmap
matrixify <- function(runSamples, plate=FALSE){
  val <- matrix(rep(NA, 96), nrow=8)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  for(j in LETTERS[1:8]){
    for(k in 1:12){
      sample_jk <- runSamples$sampleName[runSamples$AUTO_WELLROW==j & runSamples$AUTO_WELLCOL==k]
      if(length(sample_jk)!=0){
        val[rownames(val)==j, colnames(val)==k] <- sample_jk
      }
      if(plate && length(sample_jk) == 0){
        val[rownames(val)==j, colnames(val)==k] <- ""
      }
    }
  }
  return(val)
}
```

```{r, include=FALSE}
if (params$rendered_by_shiny) shiny::setProgress(0.1, message = "Parsing XML files ...")

# define title
title_var <- paste(params$study_name, params$assayName, sep='<br>')
# define sample specific boxplot colors for use in plots
#boxplot_colors <- unlist(lapply(alamarColorPalette(n=5, tint='light', nReps=5), function(x) x[4]))
boxplot_colors <- grDevices::hcl.colors(5, palette = "Set3")[c(4,3,1,5,2)]
if(is.null(params$dataRuns)){
  numFiles <- length(params$xmlFiles)
  # set data directory
  if(is.null(params$dataDir)){
    xmlFilesPath <- params$xmlFiles
  } else {
    knitr::opts_knit$set(root.dir=params$dataDir)
    # save xml file path
    xmlFilesPath <- paste0(params$dataDir, "/", params$xmlFiles)
  }
  # define variables to store results
  runs <- vector('list', numFiles)
  runSummaries <- vector('list', numFiles)
  read_summary <- NULL
  # define plateIDs / plate names
  if(length(params$plateNames) == 0){
    PlateNames <- paste0('Plate ', 1:numFiles)
  }else{
    PlateNames <- params$plateNames
  }
  # read in XML files
  for(i in 1:numFiles){
    runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=PlateNames[i], 
                               NC=params$NC, SC=params$SC, IC=params$IC, 
                               IPC=params$IPC, Bridge=params$Bridge,
                               sample_group_covar=params$sampleGroupCovar)
    # check if plate / row / col AnnotName match the data
    if(!(params$plateAnnotName %in% colnames(runs[[i]]$samples)) | !(params$plateAnnotName %in% colnames(runs[[i]]$samples)) | !(params$plateAnnotName %in% colnames(runs[[i]]$samples))){
      stop('plate / row / col AnnotName do not match the data. Check and update params.')
    }
    # exclude samples if specified
    if(!is.null(params$excludeSamples)){
        exclude_samples <- params$excludeSamples[[i]]
        runs[[i]]$samples <- runs[[i]]$samples[!(runs[[i]]$samples$sampleName %in% exclude_samples),]
        runs[[i]]$SampleNames <- runs[[i]]$SampleNames[!(runs[[i]]$SampleNames %in% exclude_samples)]
        runs[[i]]$Data <- runs[[i]]$Data[,!(colnames(runs[[i]]$Data) %in% exclude_samples)]
    }
    
    # exclude targets if specified
    if(!is.null(params$excludeTargets)){
      exclude_targets <- params$excludeTargets[[i]]
      runs[[i]]$targets <- runs[[i]]$targets[!(runs[[i]]$targets$targetName %in% exclude_targets),]
      runs[[i]]$Data <- runs[[i]]$Data[!(rownames(runs[[i]]$Data) %in% exclude_targets),]
    }
    # summarize each plate
    runSummaries[[i]] <- plateSummary(runs[[i]])
    read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
    if(is.null(runs[[i]]$samples[["AUTO_PLATE"]]) | !is.null(params$plateAnnotName)){
      runs[[i]]$samples$AUTO_PLATE = eval(str2expression(paste0("runs[[i]]$samples$", params$plateAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLROW"]]) | !is.null(params$rowAnnotName)){
      runs[[i]]$samples$AUTO_WELLROW = eval(str2expression(paste0("runs[[i]]$samples$", params$rowAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLCOL"]]) | !is.null(params$colAnnotName)){
      runs[[i]]$samples$AUTO_WELLCOL = eval(str2expression(paste0("runs[[i]]$samples$", params$colAnnotName)))
    }
  }
}else{ # passed in runs[[i]] from SAM, etc.
  runs <- params$dataRuns
  numFiles <- length(runs)
  runSummaries <- vector('list', numFiles)
  read_summary <- NULL
  for(i in 1:numFiles){
    runSummaries[[i]] <- plateSummary(runs[[i]])
    read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
    if(is.null(runs[[i]]$samples[["AUTO_PLATE"]]) | !is.null(params$plateAnnotName)){
      runs[[i]]$samples$AUTO_PLATE = eval(str2expression(paste0("runs[[i]]$samples$", params$plateAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLROW"]]) | !is.null(params$rowAnnotName)){
      runs[[i]]$samples$AUTO_WELLROW = eval(str2expression(paste0("runs[[i]]$samples$", params$rowAnnotName)))
    }
    if(is.null(runs[[i]]$samples[["AUTO_WELLCOL"]]) | !is.null(params$colAnnotName)){
      runs[[i]]$samples$AUTO_WELLCOL = eval(str2expression(paste0("runs[[i]]$samples$", params$colAnnotName)))
    }
  }
  PlateNames <- paste0('Plate ', 1:numFiles)
}
names(runs) <- names(runSummaries) <- PlateNames
colnames(read_summary) <- PlateNames
# transpose read summary
read_summary <- t(read_summary)
# set multiple file indicator
multipleFiles <- if(numFiles > 1) TRUE else FALSE
# set SC indicator
indicatorSC <- if(sum(sapply(runs, function(x) length(x$SC)))==0) FALSE else TRUE
# set Bridge indicator
indicatorBridge <- if(sum(sapply(runs, function(x) length(x$Bridge)))==0) FALSE else TRUE
```

```{r, include=FALSE}

if (params$rendered_by_shiny) shiny::setProgress(0.3, message = "Performing Normalization ...")

# do intra-plate normalization
intraPlateNormData <- vector("list", numFiles)
for (i in 1:numFiles){
  intraPlateNormData[[i]] <- vector("list", length(runs[[i]]$IC))
  for (j in 1:length(runs[[i]]$IC)){
    intraPlateNormData[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                                                   method="IC",
                                                   IC=runs[[i]]$IC[j])
  }
  names(intraPlateNormData[[i]]) <- runs[[i]]$IC[j]
}
names(intraPlateNormData) <- PlateNames
```

```{r, include=FALSE}
# calculate LOD on the IC normalized data
# use 1st IC as the primary IC (should be mCherry)
plate_lod <- vector('list', numFiles)
for (i in 1:numFiles){
  plate_lod[[i]] <- lod(data_matrix=intraPlateNormData[[i]][[1]]$normData, 
                        blanks=runs[[i]]$NC, 
                        min_count=0)
}
```

```{r, include=FALSE}
# do inter-plate normalization 
# save mCherry-normalized data in a list

normData <- lapply(intraPlateNormData, function(x) x[[1]]$normData)

# save IPC, NC, etc wells for each plate
IPC_wells <- lapply(runs, function(x) x$IPC)
NC_wells <- lapply(runs, function(x) x$NC)
SC_wells <- lapply(runs, function(x) x$SC)
Bridge_wells <- lapply(runs, function(x) x$Bridge)

# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')

# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                             IPC=TRUE, IN=TRUE,
                             IPC_wells=IPC_wells,
                             NC_wells=NC_wells)

if(indicatorBridge==TRUE){
  mCherry_Bridge <- interPlateNorm(data_list=normData,
                                   IPC=TRUE, IN=TRUE,
                                   IN_samples=Bridge_wells)
}
```

```{r, include=FALSE}
# calculate intra-plate CVs on unnormalized and mCherry normalized data
# using IPCs and SCs (sample controls) if present
IPC_intraCV_unnorm <- IPC_intraCV_mCherry <- NULL
if(indicatorSC==TRUE){
  SC_intraCV_unnorm <- SC_intraCV_mCherry <- NULL
}
# loop through plates and calculate CVs
for (i in 1:numFiles){
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(runs[[i]]$samples))
  IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$SC] <- 'SC'
  }
  # unnormalized intraCV
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                  samples=IPC_SC_samples,
                                  aboveLOD=plate_lod[[i]]$aboveLOD,
                                  exclude_targets=runs[[i]]$IC)
  # combine plates into one matrix
  IPC_intraCV_unnorm <- cbind(IPC_intraCV_unnorm, plate_unnorm_intraCV[,'IPC']) 
  if(indicatorSC==TRUE){
    SC_intraCV_unnorm <- cbind(SC_intraCV_unnorm, plate_unnorm_intraCV[,'SC'])
  }
  # mCherry intraCV
  plate_mCherry_intraCV <- intraCV(data_matrix=intraPlateNormData[[i]]$mCherry$normData,
                                   samples=IPC_SC_samples,
                                   aboveLOD=plate_lod[[i]]$aboveLOD,
                                   exclude_targets=runs[[i]]$IC)
  # combine plates into one matrix
  IPC_intraCV_mCherry <- cbind(IPC_intraCV_mCherry, plate_mCherry_intraCV[,'IPC'])
  if(indicatorSC==TRUE){
    SC_intraCV_mCherry <- cbind(SC_intraCV_mCherry, plate_mCherry_intraCV[,'SC'])
  }
}
# set colnames
colnames(IPC_intraCV_unnorm) <- colnames(IPC_intraCV_mCherry) <- PlateNames
if(indicatorSC==TRUE){
  colnames(SC_intraCV_unnorm) <- colnames(SC_intraCV_mCherry) <- PlateNames
}
# if more than one plate, add Overall column of mean intraCV
if(multipleFiles==TRUE){
  IPC_intraCV_unnorm <- cbind(IPC_intraCV_unnorm, Overall=rowMeans(IPC_intraCV_unnorm, na.rm=TRUE))
  IPC_intraCV_mCherry <- cbind(IPC_intraCV_mCherry, Overall=rowMeans(IPC_intraCV_mCherry, na.rm=TRUE))
  if(indicatorSC==TRUE){
    SC_intraCV_unnorm <- cbind(SC_intraCV_unnorm, Overall=rowMeans(SC_intraCV_unnorm, na.rm=TRUE))
    SC_intraCV_mCherry <- cbind(SC_intraCV_mCherry, Overall=rowMeans(SC_intraCV_mCherry, na.rm=TRUE))
  }
}

# function to summarize columns of a matrix
column_summary_stats <- function(x, rowNames=colnames(x)){
  output <- cbind(colMeans(x, na.rm=TRUE),
                  apply(x, 2, sd, na.rm=TRUE),
                  apply(x, 2, median, na.rm=TRUE),
                  apply(x, 2, min, na.rm=TRUE),
                  apply(x, 2, max, na.rm=TRUE),
                  apply(x, 2, function(y){
                    sum(is.na(y))
                  }))
  colnames(output) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
  rownames(output) <- rowNames
  return(output)
}

# create CV summary tables
IPC_intraCV_unnorm_summary_table <- column_summary_stats(IPC_intraCV_unnorm)
IPC_intraCV_mCherry_summary_table <- column_summary_stats(IPC_intraCV_mCherry)
if(indicatorSC==TRUE){
  SC_intraCV_unnorm_summary_table <- column_summary_stats(SC_intraCV_unnorm)
  SC_intraCV_mCherry_summary_table <- column_summary_stats(SC_intraCV_mCherry)
}

```

```{r, include=FALSE}
# calculate inter-plate CVs on unnormalized, mCherry normalized,
# and inter-plate normalized data
# using IPCs and SCs (sample controls) if present

if (params$rendered_by_shiny) shiny::setProgress(0.4, message = "Performing Normalization ...")

# get input data lists
IPC_SC_samples_list <- lapply(runs, function(x) {
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(x$samples))
  IPC_SC_samples[colnames(x$Data) %in% x$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(x$Data) %in% x$SC] <- 'SC'
  }
  return(IPC_SC_samples)
})
plateData <- lapply(runs, function(x) x$Data)
plate_mCherry <- lapply(intraPlateNormData, function(x) x$mCherry$normData)
aboveLOD <- lapply(plate_lod, function(x) x$aboveLOD)
exclude_targets <- lapply(runs, function(x) x$IC)

# unnormalized interCV
interCV_unnorm <- interCV(data_list=plateData,
                          samples=IPC_SC_samples_list,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry interCV
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=IPC_SC_samples_list,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC interCV
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=IPC_SC_samples_list,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN interCV
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=IPC_SC_samples_list,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)


if(indicatorBridge==FALSE){
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_mCherry[,'IPC'],
                               interCV_mCherry_IPC[,'IPC'],
                               interCV_mCherry_IN[,'IPC'])
  
  colnames(IPC_interCV_results) <- c('unnorm',
                                     'mCherry',
                                     'mCherry + IPC',
                                     'mCherry + IN')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_mCherry[,'SC'],
                                interCV_mCherry_IPC[,'SC'],
                                interCV_mCherry_IN[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'mCherry',
                                      'mCherry + IPC',
                                      'mCherry + IN')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results)
  }
}


if(indicatorBridge==TRUE){
  # mCherry + Bridge
  interCV_mCherry_Bridge <- interCV(data_list=mCherry_Bridge$interNormData,
                                    samples=IPC_SC_samples_list,
                                    aboveLOD=aboveLOD,
                                    exclude_targets=exclude_targets,
                                    useMean=FALSE)
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_mCherry[,'IPC'],
                               interCV_mCherry_IPC[,'IPC'],
                               interCV_mCherry_IN[,'IPC'],
                               interCV_mCherry_Bridge[,'IPC'])
  
  colnames(interCV_results) <- c('unnorm',
                                 'mCherry',
                                 'mCherry + IPC',
                                 'mCherry + IN',
                                 'mCherry + Bridge')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_mCherry[,'SC'],
                                interCV_mCherry_IPC[,'SC'],
                                interCV_mCherry_IN[,'SC'],
                                interCV_mCherry_Bridge[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'mCherry',
                                      'mCherry + IPC',
                                      'mCherry + IN',
                                      'mCherry + Bridge')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results)
  }
}


```

```{r, include=FALSE}
# calculate detectability on regular samples only
# NOTE: we may also want to add detectability_summary for IPCs, SCs, and Bridge samples

if (params$rendered_by_shiny) shiny::setProgress(0.5, message = "Calculating Detectability ...")

# initialize data stores
detectability_return_summary <- list()
detectability_return_targets <- list()

for (i in 1:numFiles){
  detectability_summary <- detectability_targets <- NULL
  
  # column names of return data
  col_names_targets <- NULL
  col_names_summary <- c('type', '# samples', 'mean', 'sd', 'median',
                         'min', 'max', '# of detectable targets (%)')
  
  # retrieve sample type group information accurately
  if (is.null(params$sampleGroupCovar)){
    sample_groups <- NULL
  } else{
    sample_groups <- runs[[i]][[params$sampleGroupCovar]]
  }
  
  # run detectability calculation
  plate_detect <- detectability(aboveLOD_matrix=plate_lod[[i]]$aboveLOD,
                                sample_subset=runs[[i]]$SampleNames,
                                sample_groups=sample_groups,
                                exclude_targets=runs[[i]]$IC)
  
  # add all sample type/identity detectability data
  raw_detectability <- plate_detect$all$detectability
  detectability <- cbind('all',
                         plate_detect$all$sampleNumber,
                         format(round(mean(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                         format(round(sd(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                         formatC(median(raw_detectability, na.rm=TRUE), width=2),
                         formatC(min(raw_detectability, na.rm=TRUE), width=2),
                         formatC(max(raw_detectability, na.rm=TRUE), width=2),
                         paste0(sum(raw_detectability > 50),
                                ' (',
                                format(round(sum(raw_detectability > 50)/length(raw_detectability) * 100, 1), nsmall=1),
                                '%)'))
  col_names_targets <- c(col_names_targets, "all")
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_targets <- cbind(detectability_targets,
                                 format(round(raw_detectability, 1), nsmall=1))
  
  # check if both sample and all data present
  if (length(names(plate_detect)) == 2){
    for (j in names(plate_detect$sample_group$detectability)){
      raw_detectability <- plate_detect$sample_group$detectability[[j]]
      detectability <- cbind(j,
                             plate_detect$sample_group$sampleNumber[[j]],
                             format(round(mean(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                             format(round(sd(raw_detectability, na.rm=TRUE), 1), nsmall=1),
                             formatC(median(raw_detectability, na.rm=TRUE), width=2),
                             formatC(min(raw_detectability, na.rm=TRUE), width=2),
                             formatC(max(raw_detectability, na.rm=TRUE), width=2),
                             paste0(sum(raw_detectability > 50),
                                    ' (',
                                    format(round(sum(raw_detectability > 50)/length(raw_detectability) * 100, 1), nsmall=1),
                                    '%)'))
      col_names_targets <- c(col_names_targets, j)
      detectability_summary <- rbind(detectability_summary, detectability)
      detectability_targets <- cbind(detectability_targets,
                                     format(round(raw_detectability, 1), nsmall=1))
    }
  }
  
  # update column names
  colnames(detectability_summary) <- col_names_summary
  colnames(detectability_targets) <- col_names_targets
  
  # update return data
  detectability_return_summary[[paste("Plate ", i)]] <- detectability_summary
  detectability_return_targets[[paste("Plate ", i)]] <- detectability_targets
}

# if more than one plate, summarize across plates using weighted average
combine_detectability <- FALSE
if(numFiles > 1){
  # identify all sample types and all targets
  unique_types <- unique(unlist(lapply(detectability_return_summary, function(x) x[, "type"])))
  all_targets <- unique(unlist(lapply(detectability_return_targets, rownames)))
  
  # get sample specific totals
  sample_total <- list()
  for (i in unique_types){
    sample_count <- sapply(detectability_return_summary, function(plate){
      sample_type_row <- plate[plate[, "type"] == i, "# samples"]
      if (length(sample_type_row) == 1) {as.integer(sample_type_row)} else {NA}
    })
    sample_total[[i]] <- sum(sample_count, na.rm = TRUE)
  }
  
  # calculate sample specific weights
  sample_weights_plate <- lapply(detectability_return_summary, function(plate){
    sample_types <- plate[, "type"]
    sample_counts <- as.numeric(plate[, "# samples"])
    weights <- list()
    for (i in seq_along(sample_types)) {
      sample_type <- sample_types[i]
      total <- sample_total[[sample_type]]
      weights[[sample_type]] <- sample_counts[i] / total
    }
    weights
  })
  
  # apply weights
  weighted_target_detectabilities <- list()
  for (plate_name in names(detectability_return_targets)){
    # get plate matrix and weights
    plate_matrix <- detectability_return_targets[[plate_name]]
    plate_weights <- sample_weights_plate[[plate_name]]
    
    # multiply the appropriate column with the corresponding weight
    multiplied_matrix <- sapply(1:ncol(plate_matrix), function(col_index){
      weight <- plate_weights[[col_index]]
      column <- as.numeric(plate_matrix[, col_index])
      multiplied_column <- weight * column
      multiplied_column
    })
    
    # assign the multiplied columns to the corresponding plate in the result list
    rownames(multiplied_matrix) <- rownames(plate_matrix)
    colnames(multiplied_matrix) <- colnames(plate_matrix)
    
    weighted_target_detectabilities[[plate_name]] <- multiplied_matrix
  }
  
  # get the sum of weights applied matrices
  sum_matrix <- matrix(0, nrow = nrow(weighted_target_detectabilities[[1]]),
                       ncol = length(unique_types))
  colnames(sum_matrix) <- unique_types
  rownames(sum_matrix) <- unique(unlist(lapply(weighted_target_detectabilities, rownames)))
  
  for (plate in weighted_target_detectabilities) {
    matching_cols <- intersect(colnames(plate), unique_types)
    sum_matrix[, matching_cols] <- sum_matrix[, matching_cols] + plate[, matching_cols]
  }
  
  # update target detectability data vector: add overall data
  detectability_return_targets[["Overall"]] <- sum_matrix
  
  # update detectability summary with overall data
  detectability_summary_overall <- NULL
  for (j in colnames(sum_matrix)){
    data_col <- as.numeric(sum_matrix[, j])
    detectability <- cbind(j,
                           sample_total[[j]],
                           format(round(mean(data_col, na.rm=TRUE), 1), nsmall=1),
                           format(round(sd(data_col, na.rm=TRUE), 1), nsmall=1),
                           formatC(round(median(data_col, na.rm=TRUE), 1), width=2),
                           formatC(round(min(data_col, na.rm=TRUE), 1), width=2),
                           formatC(round(max(data_col, na.rm=TRUE), 1), width=2),
                           paste0(sum(data_col > 50),
                                  ' (',
                                  format(round(sum(data_col > 50)/length(data_col) * 100, 1), nsmall=1),
                                  '%)'))
    detectability_summary_overall <- rbind(detectability_summary_overall,
                                           detectability)
  }
  colnames(detectability_summary_overall) <- col_names_summary
  
  # update summary detectability data vector: add overall data
  detectability_return_summary[["Overall"]] <- detectability_summary_overall
  
  # present data tables better if all plates have the same sample type
  # applicable only if sample group information is provided and/or all samples are
  # of the same group (e.g., plasma)
  if (length(unique_types) <= 2){
    # summary data
    all_rows <- lapply(detectability_return_summary,
                       function(plate) plate[plate[, "type"] == "all", ])
    combined_all_matrix <- do.call(rbind, all_rows)
    detectability_return_summary[["Combined"]] <- combined_all_matrix
    
    # detectability targets
    all_cols <- lapply(detectability_return_targets,
                       function(plate) plate[, "all"])
    combined_all_matrix <- do.call(cbind, all_cols)
    detectability_return_targets[["Combined"]] <- combined_all_matrix
    
    combine_detectability <- TRUE
  }
}
```

```{r, include=FALSE}
# log transform and scale data for clustered heatmap
# and sample correlation plot
data_mCherry_IPC_log2_scaled <- list()
data_mCherry_IPC_log2_no_NC_scaled <- list()
for(i in 1:numFiles){
  data_mCherry_IPC <- mCherry_IPC$interNormData[[i]]
  # remove ICs
  data_mCherry_IPC <- data_mCherry_IPC[!grepl(paste(runs[[i]]$IC, collapse="|"), rownames(data_mCherry_IPC)),]
  # remove NCs to calculate center and scale (so NCs don't skew the scale parameters)
  data_mCherry_IPC_no_NC <- data_mCherry_IPC[,!grepl(paste(runs[[i]]$NC, collapse="|"), colnames(data_mCherry_IPC))]
  data_mCherry_IPC_log2_no_NC_scaled[[i]] <- t(scale(t(log2(data_mCherry_IPC_no_NC + 1)),
                                                     center=TRUE, scale=TRUE))
  # log transform and scale targets
  data_mCherry_IPC_log2_scaled[[i]] <- t(scale(t(log2(data_mCherry_IPC + 1)),
                                               center=attributes(data_mCherry_IPC_log2_no_NC_scaled[[i]])$`scaled:center`, 
                                               scale=attributes(data_mCherry_IPC_log2_no_NC_scaled[[i]])$`scaled:scale`))
}
```

---
title: "`r title_var`"
---


```{r, eval=(params$outPlateLayout), results='asis'}

if (params$rendered_by_shiny) shiny::setProgress(0.6, message = "Writing Document ...")

pandoc.header("Plate layout", 2)
pandoc.p("Shows the layout of samples, controls (e.g., negative controls (NC), inter-plate controls (IPC)), and special wells if any (e.g., sample controls (SC), bridge samples) on the 96 well assay plate." )
for(i in 1:numFiles){
  val <- matrixify(runs[[i]]$samples, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){      well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){  well_types <- append(well_types, list(Bridge_wells[[i]]))}
  
  for (j in 1:length(well_types)){
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space for text wrapping
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate Layout"), 
                   align="c", escape=FALSE, table.attr=table.attr) %>%
        kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE) %>%
        column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
        row_spec(0:8, extra_css = "border-bottom: 1px solid") 
  )
}
```


```{r, eval=(params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Read summary", 2)
pandoc.p("Summary of the number and classification of reads for the assay run") 
pandoc.list(c("Parseable - Valid next generation sequencing (NGS) read (assay signal or background)",
              "Parseable Match - Valid NGS read (assay signal)",
              "Parseable Non-match - Vaild NGS read (assay background)",
              "Unparseable - Sequencing background",
              "Total samples - Total number of samples on plate (including controls)",
              "Total targets - Total number of assay targets (including internal controls)",
              "Zero values - Number of targets * samples which had no assay signal"
))
knitr::kable(read_summary, caption='', 
             align='r', format.args=list(big.mark = ","), 
             table.attr="id=\"read-summary\"") %>% 
  kable_styling(bootstrap_options=c("striped", "hover", "condensed"), full_width=TRUE)
```


```{r, eval=(params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Internal controls (IC)", 3)
pandoc.p("Each sample of the assay is spiked with the same concentration of an internal control (IC). This is used both as part of a well normalization procedure and as a method for assessing the uniformity of the assay run.") 
if(length(params$IC) == 1){
  IC_tables <- NULL
  for (i in 1:numFiles){
    IC_tables <- rbind(IC_tables, runSummaries[[i]]$IC_table)
  }
  rownames(IC_tables) <- paste0("Plate", as.character(1:numFiles)) 
  cat(knitr::kable(IC_tables, 
                   caption="mCherry (IC) summary", 
                   align='r', 
                   format.args=list(big.mark = ","), 
                   table.attr="id=\"IC-summary\"") %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))  
} else {
  for(i in 1:numFiles){
    table.attr <- paste0("id=\"IC-summary", i, "\"")
    cat(knitr::kable(runSummaries[[i]]$IC_table, 
                     caption=paste0("Plate ", as.character(i), ": IC summary"), 
                     align='r', 
                     format.args=list(big.mark = ","), 
                     table.attr=table.attr) %>% 
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```


```{r, eval=(params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Inter-plate controls (IPC)", 3)
pandoc.p("IPC samples are pooled plasma controls used both to normalize samples between experiments and to assess performance (e.g., precision) of the assay.")
pandoc.p("Note: %CV in this table does not exclude values below LOD. See [Intra-plate normalization](#intraPlateNorm) or [Inter-plate normalization](#interPlateNorm) sections for %CV (before and after normalization) that excludes values below LOD.")
for(i in 1:numFiles){
  table.attr <- paste0("id=\"IPC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```


```{r, eval=(params$outReadSummary), results='asis'}

if (params$rendered_by_shiny) shiny::setProgress(0.7, message = "Writing Document ...")

knitr::asis_output("\n\n---\n\n")
pandoc.header("Negative controls (NC)", 3)
pandoc.p("NC wells are reactions where no sample input is provided (i.e., buffer only). These are used to assess Limit of Detection (LOD) for each target assay and to assess run quality (e.g., background levels).")
for(i in 1:numFiles){
  table.attr <- paste0("id=\"NC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```


```{r eval=(indicatorSC & params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Sample controls (SC)", 3)
pandoc.p("SC samples are pooled plasma controls from an independent pooled plasma source that is different from IPCs. They could be a pooled sample derived from all study samples, for example. They should be from the same source across all plates that will be analysed together. SCs are used for calculating intra- and inter-plate coefficient of variation (CV). They are necessary for obtaining an unbiased measure of inter-plate CV when IPC normalization is used.")
for(i in 1:numFiles){
  table.attr <- paste0("id=\"SC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$SC_table, caption=paste0("Plate ", as.character(i), ": SC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```


```{r eval=(indicatorBridge & params$outReadSummary), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Bridge samples (Bridge)", 3)
pandoc.p("Bridge samples can be used for inter-plate normalization. Bridge sample normalization uses the bridge sample subset to estimate plate- and target-specific medians, and then uses these medians to normalize all samples in a manner similar to intensity normalization.")
for(i in 1:numFiles){
  table.attr <- paste0("id=\"Bridge-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$Bridge_table, caption=paste0("Plate ", as.character(i), ": Bridge summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```


```{r, out.width='100%', eval=(params$outHeatmaps), fig.asp=0.33333*ceiling((length(params$IC)+1)/2), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Heatmaps", 2)
heatmap_description <- if (params$heatMapRel==TRUE) "percent relative to plate median" else "absolute normalized read count"
pandoc.p(paste0("Heatmaps show the ", heatmap_description, " for log2(total counts) and the specified internal control."))
for(i in 1:numFiles){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  val <- matrixify(runs[[i]]$samples)
  vals <- unlist(as.list(t(val)))
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsmCherry <- if(params$heatMapRel) 1 else 0
  logVals <- log2(colSums(runs[[i]]$Data, na.rm=TRUE))
  well_order <- wellorder(runs[[i]]$sample)
  val <- vals
  val[which(!is.na(vals))] <- logVals[well_order]
  plateHeatmap(as.numeric(val), 
               title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), 
               cex=0.5, digits=1,
               relative=params$heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    val <- vals
    val[which(!is.na(vals))] <- runs[[i]]$Data[ICs[j],][well_order]
    plateHeatmap(as.numeric(val), 
                 title=paste0("Plate ", as.character(i),": ",  runs[[i]]$IC[j]), 
                 cex=0.5, digits=digitsmCherry, 
                 relative=params$heatMapRel, cex.axis=0.5)
  }
}
```


```{r, eval=(params$outQC), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Quality control", 2)
pandoc.header("Plate QC", 3)
pandoc.p("Plate-specific QC criteria:")
pandoc.list(c(paste0("ICRead_CV - Coefficient of Variation of internal control signal across all samples (maximum = ", QCPlateCriteria()$thresholds['ICRead_CV']*100,"%)"),
              paste0("IPCRead_CV - Coefficient of Variation of the total assay signal across all IPCs (maximum = ", QCPlateCriteria()$thresholds['IPCRead_CV']*100,"%)"),
              paste0("IPCTarget_CV - Median Coefficient of Variation of all IPC targets (maximum = ", QCPlateCriteria()$thresholds['IPCTarget_CV']*100,"%)"),
              paste0("Detectability - Percentage of targets that are detectable (target is considered detectable if > 50% samples have signal > LOD) (minimum = ",  QCPlateCriteria()$thresholds['Detectability']*100,"%)"),
              paste0("MinReads - Number of total Parseable Match reads (signal) for the experiment (minimum = ", QCPlateCriteria()$thresholds['MinReads'],")"
              )))
pandoc.p("QC criteria are assessed either on unnormalized (raw) or IC-normalized (IC) data.")

for( i in 1:numFiles){
  qcPlate <- QCFlagPlate(runs[[i]]$Data, normData[[i]], runs[[i]]$targets, runs[[i]]$samples)
  table.attr <- paste0("id=\"QCFlagPlate-summary", i, "\"")
  qcPlate$status[which(qcPlate$status == FALSE)] <- "Pass"
  qcPlate$status[which(qcPlate$status == TRUE)] <- "Warning"
  qcPlate$QCthreshold[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$QCthreshold[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$QCthreshold[nrow(qcPlate)] <- format(as.numeric(qcPlate$QCthreshold[nrow(qcPlate)]), big.mark=",")
  qcPlate$val[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$val[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$val[nrow(qcPlate)] <- format(as.numeric(qcPlate$val[nrow(qcPlate)]), big.mark=",")
  cat(knitr::kable(qcPlate[,1:5], 
                   caption=paste0("Plate ", as.character(i), ": Plate QC Summary"), 
                   align='r', 
                   format.args=list(big.mark = ",", digits=2),
                   table.attr=table.attr,
                   col.names = c("QC Criterion", "Normalization", "QC Status", "QC Value", "QC Threshold"
                   )) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) %>%
        row_spec(which(qcPlate$status == "Warning"), bold=T, color="white", background="red"))
}
```

```{r, eval=(params$outQC), out.width='100%', results='asis'}
pandoc.header("Sample QC", 3)
pandoc.header("Sample QC summary tables", 4)
pandoc.p("Sample-specific QC criteria:")
pandoc.list(c(
              paste0("Detectability - Percentage of targets above LOD for a sample - Plasma (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.plasma'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - Serum (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.serum'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - CSF (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.csf'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - Urine (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.urine'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - Cell Culture Media (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.cell_culture'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - NHP Plasma (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.nhp_plasma'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - NHP Serum (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.nhp_serum'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - Dried Blood Spot (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.dried_blood_spot'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - Control (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.control'])*100,"%)"),
              paste0("Detectability - Percentage of targets above LOD for a sample - Other (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability.other'])*100,"%)"),
              paste0("ICReads - Number of IC reads for a sample (minimum = ", QCSampleCriteria()$thresholds['ICReads'],")"),
              paste0("NumReads - Number of total Parseable Match (signal) reads for a sample (minimum = ", QCSampleCriteria()$thresholds['NumReads'],")"),
              paste0("IC_Median - % deviation from the overall plate median IC reads (within +/-", as.numeric(unname(unlist(strsplit(QCSampleCriteria()$thresholds['IC_Median'], ',')))[2])*100, "% of plate median)")
))

# make empty sample QC summary table
criteria <- QCSampleCriteria()
rowNameQC <- c()
QCSummary <- matrix(nrow=numFiles + 1, ncol=length(criteria$thresholds) - length(which(startsWith(names(criteria$thresholds), "Detectability"))) + 1 + 1)
for (i in 1:numFiles){
  QCSummary[i,1] <- length(runs[[i]]$SampleNames)
  rowNameQC <- c(rowNameQC,  paste0("Plate ", as.character(i))) 
}

# loop over criteria
# get xlim for plots
val <- list()
QCplot_axis_limits <- vector(mode='list', length=numFiles)
for (i in 1:numFiles){
  well_order <- wellorder(runs[[i]]$samples)
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  rmin <- rmax <- c()
  for (j in 1:length(criteria$thresholdNames)){
    inds <- which(startsWith(names(criteria$thresholdNames)[j], qcSample$flagName))
    QC_criterion_j_data <- qcSample[inds, ]
    if (startsWith(names(criteria$thresholdNames)[j], "Detectability")){
      val[j] <- criteria$thresholds[1]
    }else{
      val[j] <- criteria$thresholds[which(names(criteria$thresholds) == names(criteria$thresholdNames)[j])]
    }
    val[j] <- criteria$thresholds[j] #if(names(criteria$thresholds)[j] == "Detectability") as.numeric(unlist(strsplit(criteria$thresholds[j],",")))*100 else unlist(strsplit(criteria$thresholds[j],","))
    if(names(criteria$thresholdNames)[j] == "Detectability"){
      xval <- as.numeric(QC_criterion_j_data$val)*100
      rmax[j] <- 100.0
      rmin[j] <- 0.0 #min(as.numeric(val[[j]])*100, as.numeric(xval), na.rm=TRUE)
    }else if (names(criteria$thresholdNames)[j] == "IC_Median"){
      xval <- as.numeric(QC_criterion_j_data$val)*100
      minmaxVal <- unname(unlist(strsplit(val[[j]], ",")))
      rmin[j] <- min(as.numeric(minmaxVal[1])*100, as.numeric(xval), na.rm=TRUE)
      rmax[j] <- max(as.numeric(minmaxVal[2])*100, as.numeric(xval), na.rm=TRUE)
    }else{
      xval <- as.numeric(QC_criterion_j_data$val)
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=TRUE)
      rmax[j] <- max(as.numeric(val[[j]]), as.numeric(xval), na.rm=TRUE)
    }
    # add a small amount of padding to x axis limits
    if(names(criteria$thresholdNames)[j] %in% c("ICReads", "NumReads")){
      rlim_delta <- log10(rmax[j]) - log10(rmin[j])
      rmin[j] <- 10^(log10(rmin[j]) - 0.025 * rlim_delta)
      rmax[j] <- 10^(log10(rmax[j]) + 0.025 * rlim_delta)
    } else {
      rlim_delta <- rmax[j] - rmin[j]
      rmin[j] <- rmin[j] - 0.025 * rlim_delta
      rmax[j] <- rmax[j] + 0.025 * rlim_delta
    }
    # count how many samples fail QC (excludes controls)
    QCSummary[i, j+1] <- length(which(QC_criterion_j_data[QC_criterion_j_data$sampleName %in% runs[[i]]$SampleNames,]$status=="TRUE"))
  }
  QCplot_axis_limits[[i]] <- list(rmin=rmin, rmax=rmax)
}

# fill in & format QCSummary
QCSummary[i+1, ] <- colSums(QCSummary, na.rm=TRUE)
rownames(QCSummary) <- c(rowNameQC, "Total")
colnames(QCSummary) <- c("# of Samples", names(criteria$thresholdNames))

# print sample QC summary table
knitr::kable(QCSummary, caption='Number of samples that have warnings for each QC criterion (excludes IPC, SC, NC & bridge samples)',
             align='r',
             table.attr="id=\"QC-summary-table\"",
             format.args=list(big.mark = ",", digits=2, escape=FALSE)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r, eval=(params$outQC), out.width='100%', results='asis'}
# table to show which specific samples fail each QC flag
QC_sample_fail <- vector(mode='list', length=length(names(criteria$thresholdNames)))
names(QC_sample_fail) <- names(criteria$thresholdNames)
QC_sample_fail <- lapply(QC_sample_fail, function(x) x <- data.frame(Plate=character(0), QC_fail_samples=character(0)))
for (i in 1:numFiles){
  well_order <- wellorder(runs[[i]]$samples)
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  for (j in 1:length(criteria$thresholdNames)){
    QC_criterion_j_data <- qcSample[qcSample$flagName == names(criteria$thresholdNames)[j], ]
    QC_criterion_j_data_samples <- QC_criterion_j_data[QC_criterion_j_data$sampleName %in% runs[[i]]$SampleNames,]
    QC_fail_samples_j <- QC_criterion_j_data_samples$sampleName[QC_criterion_j_data_samples$status==TRUE]
    # reverse so they are sorted A1 - H12
    QC_fail_samples_j <- rev(QC_fail_samples_j)
    if(length(QC_fail_samples_j) > 0){
      QC_sample_fail[[j]] <- rbind(QC_sample_fail[[j]], data.frame(Plate=PlateNames[i], QC_fail_samples=QC_fail_samples_j))
    }
  }
}

# print QC fail tables
# need to fix table.attr
for(i in 1:length(names(criteria$thresholdNames))){
  if(nrow(QC_sample_fail[[i]]) > 0){
    cat(knitr::kable(QC_sample_fail[[i]], caption=paste0('Samples with warnings: ', names(criteria$thresholdNames)[i]),
                     align='r',
                     table.attr="id=\"sample-QC-summary-table\"",
                     format.args=list(big.mark = ",", digits=2, escape=FALSE)) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```


```{r, eval=(params$outQC), out.width='100%', fig.asp=1, results='asis'}
if (params$rendered_by_shiny) shiny::setProgress(0.8, message = "Writing Document ...")
pandoc.header("Sample QC plots", 4)
# make sample QC plots
for( i in 1:numFiles){
  # sort in order: samples, IPC, SC, Bridge, NC
  sampleType_factor <- factor(runs[[i]]$sample$sampleType,
                              levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  well_order <- wellorder(runs[[i]]$samples,
                          sampleTypeFactor=sampleType_factor)
  # do sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  if(indicatorSC){
    inds <- which(grepl(paste(runs[[i]]$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(runs[[i]]$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }

  # make plots
  par(mfcol=c(1, length(criteria$thresholdNames)+1), mar=c(5,0.05,2,0.05))
  # empty plot
  dotchart(x=rep(0, length(sampleType_factor)),
           xlab='',
           xlim=c(50, 100),
           labels=qcSample[inds, ]$sampleName,
           color="white",
           lcolor='white',
           gcolor='black',
           xaxt='n', frame.plot=FALSE,
           offset=-1,
           cex=0.45)
  title(main=PlateNames[i])


  for(j in 1:length(names(criteria$thresholdNames))){
    inds <- which(qcSample$flagName == names(criteria$thresholdNames)[j])
    xlab <- ""
    xval <- NULL
    # define xlabels
    if(names(criteria$thresholdNames)[j] == "Detectability"){
      xlab <- "Detectability %"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    } else if(names(criteria$thresholdNames)[j] == "IC_Median"){
      xlab <- "% of mCherry Median"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    } else {
      xlab <- "Number of Reads"
      xval <- as.numeric(qcSample[inds, ]$val)
      zs <- which(xval == 0)
      if(length(zs) > 0){
        xval[zs] <- xval[zs]+1
      }
    }

    # use log scale for number of reads
    log <- if(names(criteria$thresholdNames)[j] != "Detectability" && names(criteria$thresholdNames)[j] != "IC_Median") "x" else ""
    # use y labels only for first plot
    if(j==1) {
      labels <- qcSample[inds, ]$sampleName
    } else {
      labels <- rep('', length(xval))
    }
    # define colors
    color <- rep("black", length(inds))
    color[which(qcSample[inds,]$sampleType == "IPC")] <- boxplot_colors[2]
    color[which(qcSample[inds,]$sampleType == "NC")] <- boxplot_colors[3]
    if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "SC")] <- boxplot_colors[4]
    }
    if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "Bridge")] <- boxplot_colors[5]
    }
    dotchart(x=as.numeric(xval),
             xlab=xlab,
             labels=rep('', length(xval)), las=1,
             cex=0.45, xlim=c(QCplot_axis_limits[[i]]$rmin[j], QCplot_axis_limits[[i]]$rmax[j]),
             color=color, log=log)
    if(j==1){
      # need to loop over labels and color individuals
      for (k in 1:length(xval)){
        axis(side=2, at=k,
             labels=labels[k], col.axis=color[k], las=1,
             cex.axis=0.5)
      }
    }
    # color points green if PASS, red if FAIL
    xvalFail <- xval
    xvalFail[which(qcSample[inds,]$status != TRUE)] <- NA
    xvalPass <- xval
    xvalPass[which(qcSample[inds,]$status != FALSE)] <- NA
    points(as.numeric(xvalPass),1:length(xvalPass), pch=19, col="green")
    points(as.numeric(xvalFail),1:length(xvalFail), pch=19, col="red")

    if(names(criteria$thresholdNames)[j] == "IC_Median"){
      minmaxVal <- unlist(strsplit(criteria$thresholds["IC_Median"], ","))
      abline(v=as.numeric(minmaxVal[[1]])*100, col='brown')
      abline(v=as.numeric(minmaxVal[[2]])*100, col='brown')
      abline(v=0, col='brown', lty=2)
    } else if(names(criteria$thresholdNames)[j] == "Detectability"){
      value <- if(criteria$format[j] == "percentage") as.numeric(val[[j]])*100 else as.numeric(val[[j]])
      detectVals <- as.numeric(qcSample$QCthreshold[which(qcSample$flagName == "Detectability")]) * 100
      for(k in 1:length(detectVals)){
        if(!is.na(detectVals[k])){
          segments(detectVals[k], k - 0.5, detectVals[k], k + 0.5, col = "brown")
        }
      }
    } else{
#      value <- if(criteria$format[j] == "percentage") as.numeric(val[[j]])*100 else as.numeric(val[[j]])
      thresh <- criteria$thresholds[which(names(criteria$format)[j] == names(criteria$thresholds))]
      value <- if(criteria$format[j] == "percentage") as.numerical(thresh) * 100 else as.numeric(thresh)
      abline(v=value, col='brown')
    }
    legend('bottomright', legend=c('Pass', "Fail"), col=c('green', 'red'), pch=19, cex=0.4, bty='n', inset=c(0,1), xpd=T,horiz=T)
    title(main=names(criteria$thresholdNames)[j], cex.main=1)
  } 
}
```

---

```{r, echo=FALSE}
# calculate fig.asp for detectability plots
detect_fig_asp <- 2*ceiling(numFiles/2)
```

```{r, results='asis', eval=(params$outDetectability), out.width='100%', fig.asp=detect_fig_asp}
if (params$rendered_by_shiny) shiny::setProgress(0.9, message = "Writing Document ...")
pandoc.header("Detectability", 2)
pandoc.p("Target detectability is the percentage of samples that are above the limit of detection for that target. A target is considered \"detectable\" if it is above limit of detection in greater than 50% of samples. \"Overall\" detectability is the overall percentage of samples across all plates that are above LOD for a given target. Target detectability reported here excludes IPCs, SCs, NCs, and bridge samples.")
pandoc.header("Detectability summary", 3)
# Detectability summary
if (combine_detectability){
  table.attr <- paste0("id=\"detectability-summary-combined", "\"")
  cat(knitr::kable(detectability_return_summary[["Combined"]],
                   caption=NULL, 
                   align="r", table.attr=table.attr,
                   format.args=list(big.mark = ",", digits=2)) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE))
} else{
  for (i in names(detectability_return_summary)){
    table.attr <- paste0("id=\"detectability-summary", i, "\"")
    cat(knitr::kable(detectability_return_summary[[i]],
                     caption=paste(as.character(i)), 
                     align="r", table.attr=table.attr,
                     format.args=list(big.mark = ",", digits=2)) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                        full_width = TRUE))
  }
}
```

```{r, results='asis', eval=(params$outDetectability), out.width='100%', fig.asp=detect_fig_asp}
pandoc.header("Target detectability %", 3)
# Target detectability
if (combine_detectability){
  table.attr <- paste0("id=\"detectability-indepth-combined", "\"")
  cat(knitr::kable(detectability_return_targets[["Combined"]],
                   caption=NULL, 
                   align="r", table.attr=table.attr,
                   format.args=list(big.mark = ",", digits=2)) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE))
} else{
  for (i in names(detectability_return_targets)){
    table.attr <- paste0("id=\"detectability-indepth", i, "\"")
    cat(knitr::kable(detectability_return_targets[[i]],
                     caption=paste(as.character(i)), 
                     align="r", table.attr=table.attr,
                     format.args=list(big.mark = ",", digits=2)) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                        full_width = TRUE))
  }
}
```

```{r, eval=params$outputDetectCSV==TRUE, include=FALSE}
# make directory -- we will put the file in the outputFiles directory
dir.create("./outputFiles")

# Target detectability -- output CSV file
# code depends on multipleFiles TRUE / FALSE and sampleGroupCovar NULL / non-NULL
if(multipleFiles==FALSE & is.null(params$sampleGroupCovar)){
  # put overall summary first
  detect_output_table <- detectability_return_targets[[1]]
  detect_table_names <- colnames(detect_output_table)
  detect_summary_output_table <- detectability_return_summary[[1]]
  # add n's to column name
  colnames(detect_output_table)[1] <- paste0(PlateNames[1], ' (n = ',  detect_summary_output_table[1,2], ')')
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

if(multipleFiles==FALSE & !is.null(params$sampleGroupCovar)){
  # put overall summary first
  detect_output_table <- detectability_return_targets[[1]]
  detect_table_names <- colnames(detect_output_table)
  detect_summary_output_table <- detectability_return_summary[[1]]
  # add n's to columns
  for (i in 1:length(detect_table_names)){
    colnames(detect_output_table)[i] <- paste0(detect_table_names[i], ' (n = ',  detect_summary_output_table[i,2], ')')
  }
  # save colnames
  detect_output_table_colnames <- colnames(detect_output_table)
  detect_output_table_colnames <-  detect_output_table_colnames[-grep("all ", colnames(detect_output_table))]
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # remove "all" column
  detect_output_table <- data.frame(detect_output_table[,-grep("all ", colnames(detect_output_table))])
  colnames(detect_output_table) <- detect_output_table_colnames
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

if(multipleFiles==TRUE & is.null(params$sampleGroupCovar)){
  # put overall summary first
  detect_output_table <- detectability_return_targets$Combined[,c(ncol(detectability_return_targets$Combined), 1:(ncol(detectability_return_targets$Combined) - 1))]
  detect_table_names <- colnames(detect_output_table)
  detect_summary_output_table <- detectability_return_summary$Combined[c(nrow(detectability_return_summary$Combined), 1:(nrow(detectability_return_summary$Combined) - 1)),]
  # add plate name and n's to columns
  for (i in 1:length(detect_table_names)){
    colnames(detect_output_table)[i] <- paste0(detect_table_names[i], ' (n = ',  detect_summary_output_table[i,2], ')')
  }
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

if(multipleFiles==TRUE & !is.null(params$sampleGroupCovar)){
  # put overall summary first
  detect_output_table <- detectability_return_targets[c(length(detectability_return_targets), 1:(length(detectability_return_targets) - 1))]
  detect_table_names <- names(detect_output_table)
  detect_summary_output_table <- detectability_return_summary[c(length(detectability_return_summary), 1:(length(detectability_return_summary) - 1))]
  # add plate name and n's to columns
  for (i in 1:length(detect_table_names)){
    colnames(detect_output_table[[i]]) <- paste0(detect_table_names[i], ': ', colnames(detect_output_table[[i]]))
    colnames(detect_output_table[[i]]) <- paste0(colnames(detect_output_table[[i]]), ' (n = ',  detect_summary_output_table[[i]][,2], ')')
  }
  # cbind the tables together
  detect_output_table <- do.call(cbind, detect_output_table)
  # remove "all" columns
  detect_output_table <- detect_output_table[,-grep(" all ", colnames(detect_output_table))]
  # save rownames 
  detect_output_table_rownames <- rownames(detect_output_table)
  # round to 1 decimal place
  detect_output_table <- apply(detect_output_table, 2, function(x) round(as.numeric(x), 1))
  # add rownames
  rownames(detect_output_table) <- detect_output_table_rownames
}

write.csv(detect_output_table, './outputFiles/target_detectability_table.csv')
```

```{r, results='asis', eval=(params$outDetectability), out.width='100%', fig.asp=2*ceiling(numFiles/2)}
# Target Boxplot
pandoc.header("Target detectability boxplot", 3)
pandoc.p("Plot shows target mCherry-IPC-normalized count distributions relative to LOD. For each target, log2(LOD) was subtracted from log2(count) for mCherry-normalized data.")
par(mfrow=c(ceiling(numFiles/2), 2), mar=c(4,2,2,1))
for (i in 1:numFiles){
  targetBoxplot(mCherry_IPC$interNormData[[i]], 
                title=PlateNames[i], 
                subtractLOD=TRUE, 
                blanks=runs[[i]]$NC, 
                horizontal=TRUE, 
                replace_zero_LOD=FALSE,
                axis_lab_normalized=TRUE,
                cex.targets=0.25,
                excludeTargets=runs[[i]]$IC,
                excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC))
}
```


```{r, eval=(params$outIntraPlateNorm & params$reportType=="internal" & indicatorSC==TRUE), results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Intra-plate normalization", 2) #{#intraPlateNorm}
pandoc.p("%CV was calculated for each target (excluding internal controls) for the sample control replicates (if given) and IPCs. Only values above LOD were used to calculate %CV. ")
pandoc.header("Intra-plate %CV table -- unnormalized", 3)
knitr::kable(SC_intraCV_unnorm_summary_table, caption='SC intra-plate %CV -- unnormalized', align='r', table.attr="id=\"SC-intra-plateCV-unnorm-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

knitr::kable(IPC_intraCV_unnorm_summary_table, caption='IPC intra-plate %CV -- unnormalized', align='r', table.attr="id=\"IPC-intra-plateCV-unnorm-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

pandoc.header("Intra-plate %CV table -- mCherry-normalized", 3)
knitr::kable(SC_intraCV_mCherry_summary_table, caption='SC intra-plate %CV -- mCherry-normalized', align='r', table.attr="id=\"SC-intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

knitr::kable(IPC_intraCV_mCherry_summary_table, caption='IPC intra-plate %CV -- mCherry-normalized', align='r', table.attr="id=\"IPC-intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r, eval=(params$outIntraPlateNorm & params$reportType=="internal" & indicatorSC==FALSE), results='asis'}
pandoc.header("Intra-plate %CV table -- unnormalized", 3)
knitr::kable(IPC_intraCV_unnorm_summary_table, caption='IPC intra-plate %CV -- unnormalized', align='r', table.attr="id=\"IPC-intra-plateCV-unnorm-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

pandoc.header("Intra-plate %CV table -- mCherry-normalized", 3)
knitr::kable(IPC_intraCV_mCherry_summary_table, caption='IPC intra-plate %CV -- mCherry-normalized', align='r', table.attr="id=\"intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r, out.width='100%', eval=(params$outIntraPlateNorm & indicatorSC == TRUE), fig.asp=(0.2*numFiles + 0.15)}
pandoc.header("Intra-plate %CV boxplots by plate", 3)
SC_intraCV_unnorm2 <- SC_intraCV_unnorm
colnames(SC_intraCV_unnorm2) <- paste0(colnames(SC_intraCV_mCherry), ' unnormalized')
SC_intraCV_mCherry2 <- SC_intraCV_mCherry
colnames(SC_intraCV_mCherry2) <- paste0(colnames(SC_intraCV_mCherry), ' mCherry-normalized')
SC_intraCV_vals <- t(interleave(t(SC_intraCV_unnorm2), t(SC_intraCV_mCherry2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(SC_intraCV_vals[1,])/2), nReps=2)))
par(mar=c(5, 7, 2, 1))
boxplot(SC_intraCV_vals[,ncol(SC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(SC_intraCV_vals), na.rm=TRUE)),
        main='SC Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r, out.width='100%', eval=(params$outIntraPlateNorm), fig.asp=(0.2*numFiles + 0.15)}
IPC_intraCV_unnorm2 <- IPC_intraCV_unnorm
colnames(IPC_intraCV_unnorm2) <- paste0(colnames(IPC_intraCV_unnorm), ' unnormalized')
IPC_intraCV_mCherry2 <- IPC_intraCV_mCherry
colnames(IPC_intraCV_mCherry2) <- paste0(colnames(IPC_intraCV_mCherry), ' mCherry-normalized')
IPC_intraCV_vals <- t(interleave(t(IPC_intraCV_unnorm2), t(IPC_intraCV_mCherry2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(IPC_intraCV_vals[1,])/2), nReps=2)))
par(mar=c(5, 7, 2, 1))
boxplot(IPC_intraCV_vals[,ncol(IPC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(IPC_intraCV_vals), na.rm=TRUE)),
        main='IPC Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r, out.width='100%', eval=(params$outSampleBoxplot), fig.asp=1, results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Sample boxplots", 2)
pandoc.p("Sample boxplots show distributions of the log2 counts for each sample, unnormalized and after mCherry + IPC normalization.")

# function to draw boxplot
sampleboxplot <- function(data, 
                          data_order, 
                          title, 
                          boxplot_colors, 
                          label_colors, 
                          horiz=TRUE,
                          data_axis_limits=NULL,
                          internal_control_label='mCherry',
                          data_axis_label='log2(count + 1)'){
  par(mar=c(2,6,2,0.5))
  if(horiz==TRUE){
    sample_axis_side <- 2
    data_axis_side <- 1
    xlimits <- NULL
    ylimits <- data_axis_limits
  } else if(horiz==FALSE){
    sample_axis_side <- 1
    data_axis_side <- 2
    xlimits <- NULL
    ylimits <- data_axis_limits
  }
  
  boxplot(log2(data[,data_order] + 1),
          xlim=xlimits,
          ylim=ylimits,
          las=1, 
          yaxt='n',
          xaxt='n',
          ylab='',
          main=title,
          outcex=0.5,
          col=boxplot_colors[data_order], 
          horizontal=horiz, 
          cex=0.5,
          cex.main=0.75,
          cex.lab=0.75)
  # draw axes
  for (j in 1:ncol(data)){
    axis(sample_axis_side, at=j, labels=FALSE, cex.axis=0.3, las=2, col.axis=label_colors[data_order[j]], tck=-0.01)
    axis(sample_axis_side, at=j, labels=colnames(data)[data_order[j]], 
         cex.axis=0.3, las=2, col.axis=label_colors[data_order[j]], tick=FALSE, line=-0.75)
  }
  axis(side=data_axis_side, labels=FALSE, tck=-0.01)
  axis(side=data_axis_side, labels=TRUE, cex.axis=0.5, line=-1, tick=FALSE)
  # add internal control line
  lines(cbind(log2(data['mCherry', data_order] + 1), 1:ncol(data)), col='red', las=1)
  # add data axis label
  mtext(data_axis_label, side=1, line=0.75, cex=0.5)
  # legend
  legend('topleft', internal_control_label, col='red', lty=1, cex=0.4, bty='n')
  # grid lines
  abline(v=c(-50:50*5), col='grey', lty=3)
}

for(i in 1:numFiles){
  sample_type <- runs[[i]]$samples$sampleType
  sample_type <- factor(sample_type, levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  # make colors
  boxplot_colors2 <- boxplot_colors[c(1,2,4,5,3)][as.numeric(sample_type)]
  #label_colors <- unlist(lapply(alamarColorPalette(n=5, nReps=5), function(x) x[2]))[c(1,2,4,5,3)]
  label_colors <- grDevices::hcl.colors(5, palette = "Set3")[c(4,3,5,2,1)]
  label_colors[1] <- 'black'
  label_colors2 <- label_colors[as.numeric(sample_type)]
  # get well order
  ordering2 <- wellorder(runs[[i]]$samples) 
  ordering <- NULL
  types <- sort(unique(sample_type))
  for(j in 1:length(types)){
    inds <- which(sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }
  # reverse ordering so special wells are at the bottom
  ordering <- rev(ordering)
  # make plots
  numPlots <- if(params$reportType == "internal") 2 else 1
  par(mfrow=c(1,numPlots), mar=c(4,6,2,0))
  if(params$reportType == "internal"){
    sampleboxplot(runs[[i]]$Data, data_order=ordering, 
                  title=paste0(PlateNames[i], ": unnormalized"), 
                  boxplot_colors=boxplot_colors2,
                  label_colors=label_colors2)
  }
  sampleboxplot(mCherry_IPC$interNormData[[i]], data_order=ordering, 
                title=paste0(PlateNames[i], ": mCherry + IPC"), 
                boxplot_colors=boxplot_colors2,
                label_colors=label_colors2)
}
```


```{r, out.width='100%', eval=(params$outSampleCorrelation), fig.asp=1, results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Sample correlation", 2)
pandoc.p("Plot shows the Pearson correlation between samples. Heirarchical clustering is done using complete linkage.")

for(i in 1:numFiles){
  pdf(file=NULL)
  corrvals <- corrplot(cor(data_mCherry_IPC_log2_scaled[[i]], use="complete.obs"), 
                       order='hclust') 
  dev.off()
  
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  colors <- wellcolors(data=corrvals$corr, 
                       well_types=well_types, 
                       boxplot_colors=boxplot_colors)
  corrplot(corrvals$corr,
           tl.cex=0.4,
           mar=c(1,1,1,1),
           tl.col=colors,
           order="original",
           title=paste("Plate", i),
           #col=colorRampPalette(c("red","white","blue"))(200),
           col=colorRampPalette(c("blue","white","red"))(200),
           is.corr=FALSE)
  cat("\n")
}
```


```{r, out.width='100%', eval=(params$outSampleClustering), fig.asp=1, results='asis'}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Sample and target clustering", 2)
pandoc.p("Hierarchical clustering of both samples and targets was done using a Euclidean distance metric and complete linkage. Data is log2 and mCherry-normalized; targets are centered and scaled.")
# define colors
paletteLength <- 50
heatmapColors <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
# loop over plates and draw heatmaps
for(i in 1:numFiles){
  # define label colors
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  label_colors <- wellcolors(data=data_mCherry_IPC_log2_scaled[[i]], 
                             well_types=well_types, 
                             boxplot_colors=boxplot_colors)
  # define color scale breaks
  # omit NCs for determining min
  breaks <- c(seq(min(data_mCherry_IPC_log2_no_NC_scaled[[i]],na.rm=TRUE), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_IPC_log2_scaled[[i]], na.rm=TRUE)/paletteLength, 
                  max(data_mCherry_IPC_log2_scaled[[i]], na.rm=TRUE), length.out=floor(paletteLength/2)))
  # transpose and add color variable
  data_mCherry_IPC_log2_scaled2 <- data.frame(t(data_mCherry_IPC_log2_scaled[[i]]))
  data_mCherry_IPC_log2_scaled2$label_colors <- label_colors
  # generate heatmap for plate i
  vals <- data_mCherry_IPC_log2_scaled2[,1:(ncol(data_mCherry_IPC_log2_scaled2) - 1)]
  
  heatmap_i <- pheatmap(vals[,colSums(is.na(vals))==0],
                        main = paste("Plate", i), 
                        fontsize=5,
                        color=heatmapColors,
                        breaks=breaks,
                        show_colnames=FALSE, silent=TRUE)
  # put colors in order
  label_colors_ordered <- data_mCherry_IPC_log2_scaled2[order(match(rownames(data_mCherry_IPC_log2_scaled2), heatmap_i$gtable$grobs[[5]]$label)),]$label_colors
  # add label colors to plot
  heatmap_i$gtable$grobs[[5]]$gp=gpar(col=label_colors_ordered)
  grid::grid.newpage()
  grid::grid.draw(heatmap_i$gtable)
  cat("\n")
}
```


```{r eval=(multipleFiles & params$outInterPlateNorm), results='asis'}

if (params$rendered_by_shiny) shiny::setProgress(0.9, message = "Writing Document ...")

knitr::asis_output("\n\n---\n\n")
pandoc.header("Inter-plate normalization {#interPlateNorm}", 2)
cat("%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV.")
```

```{r eval=(multipleFiles & params$outInterPlateNorm), results='asis'}
pandoc.header("Inter-plate %CV", 3)

if(params$reportType != "internal"){
  remove <- "mCherry + IN"
  if(indicatorSC==TRUE){
    SC_interCV_summary_table2 <- SC_interCV_summary_table[!(rownames(SC_interCV_summary_table) %in% remove),]
    SC_interCV_results2 <- SC_interCV_results[, !(colnames(SC_interCV_results) %in% remove)]
  }
  IPC_interCV_summary_table2 <- IPC_interCV_summary_table[!(rownames(IPC_interCV_summary_table) %in% remove),]
  IPC_interCV_results2 <- IPC_interCV_results[, !(colnames(IPC_interCV_results) %in% remove)]
} else {
  if(indicatorSC==TRUE){
    SC_interCV_summary_table2 <- SC_interCV_summary_table
    SC_interCV_results2 <- SC_interCV_results
  }
  IPC_interCV_summary_table2 <- IPC_interCV_summary_table
  IPC_interCV_results2 <- IPC_interCV_results
}

if(indicatorSC==TRUE){
  knitr::kable(SC_interCV_summary_table2, 
               caption='SC inter-plate %CV', 
               align='r', 
               table.attr="id=\"SC-inter-plateCV-summary\"",
               format.args=list(big.mark = ",", digits=3)) %>% 
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
}

knitr::kable(IPC_interCV_summary_table2, 
             caption='IPC inter-plate %CV', 
             align='r', 
             table.attr="id=\"IPC-inter-plateCV-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r out.width='100%', fig.asp=0.5, eval=(params$outInterPlateNorm & multipleFiles & indicatorSC), results='asis'}
pandoc.header("Inter-plate %CV boxplot", 3)

par(mar=c(5,12,2,1))
boxplot(SC_interCV_results2[,ncol(SC_interCV_results2):1], las=1, 
        xlab='inter-plate CV (%)',
        ylim=c(0, max(SC_interCV_results2, na.rm=TRUE)), 
        main='SC Inter-plate CV',
        col=rev(alamarColorPalette(ncol(SC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r out.width='100%', fig.asp=0.5, eval=(params$outInterPlateNorm & multipleFiles & indicatorSC), results='asis'}
par(mar=c(5,12,2,1))
boxplot(IPC_interCV_results2[,ncol(IPC_interCV_results2):1], las=1, 
        xlab='inter-plate CV (%)',
        ylim=c(0, max(IPC_interCV_results2, na.rm=TRUE)), 
        main='IPC Inter-plate CV',
        col=rev(alamarColorPalette(ncol(IPC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```


```{r, out.width='100%', fig.asp=(0.4)+as.numeric(multipleFiles)*0.4, results='asis', eval=(params$reportType=="internal" & params$outSamplePCA)}
knitr::asis_output("\n\n---\n\n")
pandoc.header("Sample PCA", 2)
# function to make PCA plot
PCAplot <- function(data, plateID, IPC_samples, SC_samples, Bridge_samples, scale=TRUE, center=TRUE, title=NULL){
  data <- data[, which(apply(data, 2, sd) != 0)] # remove columns with stdev = 0
  data <- data[which(apply(data,1,sd) != 0),] # remove rows with stdev = 0
  pca <- prcomp(log2(t(data) + 1), scale=scale, center=center)
  plateID <- factor(plateID)
  colors <- alamarColorPalette(length(levels(plateID)))
  point_shapes <- rep(1, ncol(data))
  point_shapes[colnames(data) %in% IPC_samples] <- 8
  legendText <- c(levels(plateID), 'Sample', 'IPCs')
  legend_point_shapes <- rep(1, (length(levels(plateID)) + 1))
  legend_point_shapes <- c(legend_point_shapes, 8)
  if(indicatorSC==TRUE){
    point_shapes[colnames(data) %in% SC_samples] <- 9
    legendText <- c(legendText, "SCs")
    legend_point_shapes <- c(legend_point_shapes, 9)
  }
  if(indicatorBridge==TRUE){
    point_shapes[colnames(data) %in% Bridge_samples] <- 10
    legendText <- c(legendText, "Bridge")
    legend_point_shapes <- c(legend_point_shapes, 10)
  }
  
  legend_colors <- c(colors, rep('black', (length(legend_point_shapes) - length(colors))))
  
  # make plot
  par(mar=c(4,4,2,5))
  plot(pca$x[,1], pca$x[,2],
       col=colors[as.integer(plateID)],
       pch=point_shapes,
       xlab=paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), 
                   '% variance)'),
       ylab=paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), 
                   '% variance)'),
       main=title, las=1, cex=0.5)
  legend(par('usr')[2], par('usr')[4], 
         legendText,
         col=legend_colors, xpd=NA,
         pch=legend_point_shapes, cex=0.75, bty='n')
}

# function to remove targets and samples
removeTargetsSamples <- function(data, NC, IC){
  data <- data[-which(grepl(paste(IC, collapse="|"), rownames(data))),]
  data <- data[,-which(grepl(paste(NC, collapse="|"), colnames(data)))]
  return(data)
}

# merge data across plates for PCA
dataPCA_unnorm <- dataPCA_mCherry <- dataPCA_mCherryIPC <- dataPCA_mCherryIN <- plateID <- NULL
for(i in 1:numFiles){
  dataPCA_unnorm <- cbind(dataPCA_unnorm, removeTargetsSamples(runs[[i]]$Data, runs[[i]]$NC, runs[[i]]$IC))
  dataPCA_mCherry <- cbind(dataPCA_mCherry, removeTargetsSamples(intraPlateNormData[[i]][[1]]$normData, runs[[i]]$NC, runs[[i]]$IC))
  dataPCA_mCherryIPC <- cbind(dataPCA_mCherryIPC, removeTargetsSamples(mCherry_IPC$interNormData[[i]], runs[[i]]$NC, runs[[i]]$IC))
  dataPCA_mCherryIN <- cbind(dataPCA_mCherryIN, removeTargetsSamples(mCherry_IN$interNormData[[i]], runs[[i]]$NC, runs[[i]]$IC))
  plateID <- c(plateID, rep(paste0("Plate",i), ncol(removeTargetsSamples(runs[[i]]$Data, runs[[i]]$NC, runs[[i]]$IC))))
}
IPC_all <- unlist(lapply(runs, function(x) x$IPC))
SC_all <- unlist(lapply(runs, function(x) x$SC))
Bridge_all <- unlist(lapply(runs, function(x) x$Bridge))

# set plot layout params
nRowsPCA <- if(multipleFiles) 2 else 1
nCols <- 2

# draw plots
par(mfrow=c(nRowsPCA, nCols))
PCAplot(dataPCA_unnorm, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all, scale=TRUE, center=TRUE, title="Unnormalized")
PCAplot(dataPCA_mCherry, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all,scale=TRUE, center=TRUE, title="mCherry")
if(multipleFiles){
  PCAplot(dataPCA_mCherryIPC, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all, scale=TRUE, center=TRUE, title="mCherry + IPC")
  if(params$reportType == "internal"){
    PCAplot(dataPCA_mCherryIN, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all, scale=TRUE, center=TRUE, title="mCherry + IN")
  }
}
```

```{r, include=FALSE, eval=params$outputPlots==TRUE}
# create directory for outputFiles
dir.create("./outputFiles")

##########################
# plate layouts
##########################
for(i in 1:numFiles){
  val <- matrixify(runs[[i]]$samples, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){      well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){  well_types <- append(well_types, list(Bridge_wells[[i]]))}
  
  for (j in 1:length(well_types)){
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space for text wrapping
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate Layout"), 
               align="c", escape=FALSE, table.attr=table.attr) %>%
    kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                  full_width = TRUE) %>%
    column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
    row_spec(0:8, extra_css = "border-bottom: 1px solid")  %>%
    save_kable(file=paste0('./outputFiles/plate_layout_', i, '.pdf'))
  
}

##########################
# IC median QC plot
##########################
for(i in 1:numFiles){
  # sort in order: samples, IPC, SC, Bridge, NC
  sampleType_factor <- factor(runs[[i]]$sample$sampleType,
                              levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  well_order <- wellorder(runs[[i]]$samples, 
                          sampleTypeFactor=sampleType_factor)
  # do sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  # define sample types
  if(indicatorSC){
    inds <- which(grepl(paste(runs[[i]]$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(runs[[i]]$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }
  # values
  inds <- which(qcSample$flagName == 'IC_Median')
  xval <- as.numeric(qcSample[inds, ]$val)*100
  # replace values < -100 or > 100 
  xval[xval < -100] <- -100
  xval[xval > 100] <- 100
  # define labels
  labels <- qcSample[inds, ]$sampleName
  # define colors
  label_colors <- unlist(lapply(alamarColorPalette(n=5, nReps=5), function(x) x[2]))
  color <- rep("black", length(inds))
  color[which(qcSample[inds,]$sampleType == "IPC")] <- label_colors[2]
  color[which(qcSample[inds,]$sampleType == "NC")] <- label_colors[3]
  if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
    color[which(qcSample[inds,]$sampleType == "SC")] <- label_colors[4]
  }
  if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
    color[which(qcSample[inds,]$sampleType == "Bridge")] <- label_colors[5]
  }
  # make plot
  pdf(paste0('./outputFiles/sample_QC_IC_median_', i, '.pdf'), width=12, height=4)
  par(mfcol=c(1, 1), mar=c(5,4,2,0.5))
  plot(x=1:length(xval),
       y=rev(as.numeric(xval)), 
       ylab="% of Internal Control Median", 
       xlab='',
       xaxt='n', 
       las=1, 
       cex=0.7, ylim=c(-100, 100), 
       col='white',
       main=paste0(PlateNames[i], ' Sample QC: Internal Control Median'))
  # need to loop over labels and color individuals
  axis(side=1, at=1:length(xval), labels=FALSE, tck=-0.01)
  for (k in 1:length(xval)){
    text(x=k, y=par('usr')[3] - 4, 
         labels=rev(labels)[k], xpd=NA, col=rev(color)[k],
         srt=45, adj=1,
         cex=0.45)
  }
  abline(v=1:length(xval), col='lightgray', lty='dotted')
  # color points green if PASS, red if FAIL
  xvalFail <- xval
  xvalFail[which(qcSample[inds,]$status != TRUE)] <- NA
  xvalPass <- xval
  xvalPass[which(qcSample[inds,]$status != FALSE)] <- NA
  points(1:length(xvalPass), rev(as.numeric(xvalPass)), pch=19, col="green", cex=0.75)
  points(1:length(xvalFail), rev(as.numeric(xvalFail)), pch=19, col="red", cex=0.75)
  abline(h=-30, col='gray41')
  abline(h=30, col='gray41')
  abline(h=0, col='gray41', lty=2)
  legend('bottomright', legend=c('Pass', "Warning"), col=c('green', 'red'), 
         pch=19, cex=0.75, bty='n', inset=c(0,1), xpd=T,horiz=T)
  dev.off()
}


##########################
# sample distribution boxplots after normalization
##########################
for(i in 1:numFiles){
  sample_type <- runs[[i]]$samples$sampleType
  sample_type <- factor(sample_type, levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  # make colors
  boxplot_colors2 <- boxplot_colors[c(1,2,4,5,3)][as.numeric(sample_type)]
  label_colors <- unlist(lapply(alamarColorPalette(n=5, nReps=5), function(x) x[2]))[c(1,2,4,5,3)]
  label_colors[1] <- 'black'
  label_colors2 <- label_colors[as.numeric(sample_type)]
  # get well order
  ordering2 <- wellorder(runs[[i]]$samples) 
  ordering <- NULL
  types <- sort(unique(sample_type))
  for(j in 1:length(types)){
    inds <- which(sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }
  # reverse ordering so special wells are at the bottom
  ordering <- rev(ordering)
  # make plots
  pdf(paste0('./outputFiles/sample_boxplot_', i, '.pdf'), width=4, height=9)
  par(mar=c(4,6,2,0))
  sampleboxplot(mCherry_IPC$interNormData[[i]], data_order=ordering, 
                title=paste0(PlateNames[i], ": Sample Distributions After Normalization"), 
                boxplot_colors=boxplot_colors2,
                label_colors=label_colors2,
                horiz=TRUE,
                data_axis_label = 'log2(Normalized Count)',
                internal_control_label = 'Internal Control')
  dev.off()
  
}

##########################
# intra-plate and inter-plate CV histograms
##########################
# intra-plate CV 
pdf(paste0('./outputFiles/intraCV_histogram.pdf'), 
    width=5, height=5)
colors <- alamarColorPalette(2, nReps = 5, palette = 2)
par(mar=c(4.5, 4.5, 2, 1))
if(indicatorSC==TRUE){
  intraCV_mean <- rowMeans(SC_intraCV_mCherry, na.rm=TRUE)
} else {
  intraCV_mean <- rowMeans(IPC_intraCV_mCherry, na.rm=TRUE)
}
hist(intraCV_mean,
     main='Intra-plate CV (%)',
     xlab='CV (%)', las=1, breaks=50,
     col=colors[[1]][5],
     border=colors[[1]][2])
abline(v=mean(intraCV_mean, na.rm=TRUE), col=colors[[2]][3], lwd=2)
abline(v=median(intraCV_mean, na.rm=TRUE), col=colors[[2]][3], lty=2, lwd=2)
legend('topright', c(paste0('mean CV% = ', format(round(mean(intraCV_mean, na.rm=TRUE), 1), nsmall=1)), 
                     paste0('median CV% = ', format(round(median(intraCV_mean, na.rm=TRUE), 1), nsmall=1))),
       lty=c(1,2), col=colors[[2]][3], bty='n', lwd=2, cex=1.25)
dev.off()

# inter-plate CV
if(multipleFiles==TRUE){
  pdf(paste0('./outputFiles/interCV_histogram.pdf'), 
      width=5, height=5)
  colors <- alamarColorPalette(2, nReps = 5, palette = 2)
  par(mar=c(4.5, 4.5, 2, 1))
  if(indicatorSC==TRUE){
    interCV <- interCV_mCherry_IPC[,'SC']
  } else {
    interCV <- interCV_mCherry_IPC[,'IPC']
  }
  hist(interCV,
       main='Inter-plate CV (%)',
       xlab='CV (%)', las=1, breaks=50,
       col=colors[[1]][5],
       border=colors[[1]][2])
  abline(v=mean(interCV, na.rm=TRUE), col=colors[[2]][3], lwd=2)
  abline(v=median(interCV, na.rm=TRUE), col=colors[[2]][3], lty=2, lwd=2)
  legend('topright', c(paste0('mean CV% = ', format(round(mean(interCV, na.rm=TRUE), 1), nsmall=1)), 
                       paste0('median CV% = ', format(round(median(interCV, na.rm=TRUE), 1), nsmall=1))),
         lty=c(1,2), col=colors[[2]][3], bty='n', lwd=2, cex=1.25)
  dev.off()
}


##########################
# target detectability histograms
##########################

if(multipleFiles==FALSE & is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table
  detectability_data_name <- colnames(detect_output_table)
  # make histogram
  pdf('./outputFiles/target_detectability_histogram.pdf',
      width=5, height=5)
  par(mar=c(4.5, 4.5, 2, 1))
  hist(detectability_data,
       main=paste0('Target detectability (%):\n', detectability_data_name),
       xlab='Detectability (%)', las=1, breaks=50, 
       col=colors[[1]][5],
       border=colors[[1]][2])
  abline(v=50, col=colors[[2]][3], lwd=1)
  ydist <- par('usr')[4] - par('usr')[3]
  text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
       col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
  legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data, na.rm=TRUE), 1), nsmall=1)),
                      paste0('median = ', format(round(median(detectability_data, na.rm=TRUE), 1), nsmall=1))),
         lty=c(1,2), col=colors[[1]][2], bty='n', lwd=2, cex=1)
  dev.off()
}

if(multipleFiles==FALSE & !is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table
  sample_groups <- detectability_return_summary[[1]][2:nrow(detectability_return_summary[[1]]),1]
  sample_groups <- gsub(' ', replacement = '_', sample_groups)
  colnames(detectability_data) <- paste0('Target detectability (%):\n', colnames(detectability_data))
  filenames <- paste0('./outputFiles/target_detectability_histogram_', sample_groups, '.pdf')
  # make histogram for each sample type
  for (i in 1:ncol(detectability_data)){
    pdf(filenames[i],
        width=5, height=5)
    par(mar=c(4.5, 4.5, 2, 1))
    hist(detectability_data[,i],
         main=colnames(detectability_data)[i],
         xlab='Detectability (%)', las=1, breaks=50, 
         col=colors[[1]][5],
         border=colors[[1]][2])
    abline(v=50, col=colors[[2]][3], lwd=1)
    ydist <- par('usr')[4] - par('usr')[3]
    text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
         col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
    legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data[,i], na.rm=TRUE), 1), nsmall=1)),
                        paste0('median = ', format(round(median(detectability_data[,i], na.rm=TRUE), 1), nsmall=1))),
           lty=c(1,2), col=colors[[1]][2], bty='n', lwd=2, cex=1)
    dev.off()
  }
}

if(multipleFiles==TRUE & is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table[,grep('Overall', colnames(detect_output_table))]
  detectability_data_name <- colnames(detect_output_table)[grep('Overall', colnames(detect_output_table))]
  # make histogram
  pdf('./outputFiles/target_detectability_histogram.pdf',
      width=5, height=5)
  par(mar=c(4.5, 4.5, 2, 1))
  hist(detectability_data,
       main=paste0('Target detectability (%):\n', detectability_data_name),
       xlab='Detectability (%)', las=1, breaks=50, 
       col=colors[[1]][5],
       border=colors[[1]][2])
  abline(v=50, col=colors[[2]][3], lwd=1)
  ydist <- par('usr')[4] - par('usr')[3]
  text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
       col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
  legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data, na.rm=TRUE), 1), nsmall=1)),
                      paste0('median = ', format(round(median(detectability_data, na.rm=TRUE), 1), nsmall=1))),
         lty=c(1,2), col=colors[[1]][2], bty='n', lwd=2, cex=1)
  dev.off()
}

if(multipleFiles==TRUE & !is.null(params$sampleGroupCovar)){
  # get only Overall estimates
  detectability_data <- detect_output_table[,grep('Overall', colnames(detect_output_table))]
  sample_groups <- detectability_return_summary$Overall[2:nrow(detectability_return_summary$Overall),1]
  sample_groups <- gsub(' ', replacement = '_', sample_groups)
  colnames(detectability_data) <- gsub('Overall: ', replacement = 'Target detectability (%):\n', colnames(detectability_data))
  filenames <- paste0('./outputFiles/target_detectability_histogram_', sample_groups, '.pdf')
  # make histogram for each sample type
  for (i in 1:ncol(detectability_data)){
    pdf(filenames[i],
        width=5, height=5)
    par(mar=c(4.5, 4.5, 2, 1))
    hist(detectability_data[,i],
         main=colnames(detectability_data)[i],
         xlab='Detectability (%)', las=1, breaks=50, 
         col=colors[[1]][5],
         border=colors[[1]][2])
    abline(v=50, col=colors[[2]][3], lwd=1)
    ydist <- par('usr')[4] - par('usr')[3]
    text(47, par('usr')[4] - 0.7 * ydist, 'detectability = 50%',
         col=colors[[2]][3], adj=c(1,1), cex=0.5, srt=90)
    legend('topleft', c(paste0('mean = ', format(round(mean(detectability_data[,i], na.rm=TRUE), 1), nsmall=1)),
                        paste0('median = ', format(round(median(detectability_data[,i], na.rm=TRUE), 1), nsmall=1))),
           lty=c(1,2), col=colors[[1]][2], bty='n', lwd=2, cex=1)
    dev.off()
  }
}


##########################
# target detectability boxplot -- by plate
##########################
for(i in 1:numFiles){
  pdf(paste0('./outputFiles/target_detectability_boxplot_', i, '.pdf'), width=20, height=7)
  targetBoxplot(mCherry_IPC$interNormData[[i]],
                title=paste0('Target detectability: ', PlateNames[i]),
                subtractLOD = TRUE,
                blanks = runs[[i]]$NC,
                horizontal = FALSE,
                replace_zero_LOD=FALSE,
                axis_lab_normalized=TRUE,
                excludeTargets=runs[[i]]$IC,
                excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC))
  dev.off()
}

##########################
# target detectability boxplot -- combine across plates
# if no sample group specified and more than one plate, combine all data
##########################
if(is.null(params$sampleGroupCovar) & numFiles > 1){
  # calculate LODs on IC - IPC normalized data
  plate_lod_IPC <- vector('list', length(params$xmlFiles))
  for (i in 1:numFiles){
    plate_lod_IPC[[i]] <- lod(data_matrix=mCherry_IPC$interNormData[[i]], 
                              blanks=runs[[i]]$NC, 
                              min_count=0)
    plate_lod_IPC[[i]]$LOD_log2 <- log2(plate_lod_IPC[[i]]$LOD + 1)
  }
  # subtract LODs from the IC - IPC normalized sample data
  data_minus_LOD <- vector('list', length(params$xmlFiles))
  for (i in 1:length(params$xmlFiles)){
    plate_i_sample_data <- mCherry_IPC$log2_interNormData[[i]][,runs[[i]]$SampleNames]
    # add plate ID to colnames in case any names are identical across plates
    colnames(plate_i_sample_data) <- paste0('plate_', i, '_', colnames(plate_i_sample_data))
    data_minus_LOD[[i]] <- sweep(plate_i_sample_data, MARGIN=1, STATS=plate_lod_IPC[[i]]$LOD_log2)
  }
  data_minus_LOD <- do.call(cbind, data_minus_LOD)
  # sort targets
  target_medians <- apply(data_minus_LOD, 1, median)
  target_medians <- target_medians[order(target_medians, decreasing=TRUE)]
  data_minus_LOD <- data_minus_LOD[names(target_medians),]
  # calculate detectability
  detect <- apply(data_minus_LOD, 1, function(x) sum(x > 0)) / ncol(data_minus_LOD) * 100
  # create colors to indicate detectability
  makeColors <- colorRamp(colors=c('blue', 'pink'))
  detectColors <- makeColors(detect/100)
  detectColors <- apply(detectColors, 1, 
                        function(x) rgb(x[1], x[2], x[3], maxColorValue=255))
  
  pdf('./outputFiles/target_detectability_boxplot_all_plates.pdf', width=20, height=7)
  # make plot
  par(mar=c(4,4,2,0.5))
  boxplot(t(data_minus_LOD), 
          horizontal=FALSE,
          xlab='',
          ylab='NPQ - LOD',
          main='Target detectability: All plates',
          las=3, 
          lty=1,
          pch=16, 
          cex=0.5,
          staplelty=0,
          cex.axis=0.4,
          yaxt='n',
          col=detectColors)
  axis(side=2, las=1)
  grid(nx=NA, ny=NULL)
  abline(h=0, col='darkred')
  axis_limits <- par('usr')
  text(x=axis_limits[1] + (axis_limits[2] - axis_limits[1])/20, y=0,
       labels='LOD', col='darkred', cex=0.8, pos=3)
  
  # make legend
  # add color gradient legend
  # define coordinates
  axis_limits <- par('usr')
  x_axis_length <- axis_limits[2] - axis_limits[1]
  y_axis_length <- axis_limits[4] - axis_limits[3]
  legend_length <- x_axis_length/6
  legend_right <- axis_limits[2] - x_axis_length/20
  legend_left <- legend_right - legend_length
  legend_height <- y_axis_length/20
  legend_top <- axis_limits[4] - y_axis_length/10
  legend_bottom <- legend_top - legend_height
  # create color gradient
  colfunc <- colorRampPalette(c('blue', 'pink'))
  legend_image <- as.raster(matrix(colfunc(20), nrow=1))
  rasterImage(legend_image, legend_left, legend_bottom, legend_right, legend_top)
  # make labels
  text(x=seq(legend_left, legend_right, l=6), 
       y = legend_bottom - y_axis_length/40,
       labels = seq(0,100,l=6), 
       cex=0.8, adj=0.5)
  text(x=(legend_left+legend_right)/2, y=legend_top, 
       labels='detectability (%)', pos=3, cex=0.8) # end legend
  dev.off()
}


##########################
# target detectability boxplot -- combine across plates, by sample group
# if sample group is specified, combine data across plates
# and make separate plots by sample type
##########################
if(!is.null(params$sampleGroupCovar)){
  # calculate LODs on IC - IPC normalized data
  plate_lod_IPC <- vector('list', length(params$xmlFiles))
  for (i in 1:length(params$xmlFiles)){
    plate_lod_IPC[[i]] <- lod(data_matrix=mCherry_IPC$interNormData[[i]], 
                              blanks=runs[[i]]$NC, 
                              min_count=0)
    plate_lod_IPC[[i]]$LOD_log2 <- log2(plate_lod_IPC[[i]]$LOD + 1)
  }
  # subtract LODs from the IC - IPC normalized sample data
  data_minus_LOD <- vector('list', length(params$xmlFiles))
  for (i in 1:length(params$xmlFiles)){
    plate_i_sample_data <- mCherry_IPC$log2_interNormData[[i]]
    # add plate ID to colnames in case any names are identical across plates
    colnames(plate_i_sample_data) <- paste0('plate_', i, '_', colnames(plate_i_sample_data))
    # add plate ID - sample name to the samples data frame
    runs[[i]]$samples$plate_sampleName <- paste0('plate_', i, '_', runs[[i]]$sample$sampleName)
    data_minus_LOD[[i]] <- sweep(plate_i_sample_data, MARGIN=1, STATS=plate_lod_IPC[[i]]$LOD_log2)
  }
  
  data_minus_LOD <- do.call(cbind, data_minus_LOD)
  samples_data <- lapply(runs, function(x) x$samples)
  matching_column <- Reduce(intersect, lapply(samples_data, colnames))
  samples_data <- lapply(samples_data, function(x) x[,matching_column])
  samples_data <- do.call(rbind, samples_data)
  
  # loop over sample groups
  sample_groups <- unique(samples_data[,params$sampleGroupCovar])
  # remove control sample groups
  sample_groups <- sample_groups[!(sample_groups %in% c('IPC', 'SC', 'NC'))]
  
  for(k in 1:length(sample_groups)){
    
    sample_group_data <- data_minus_LOD[,samples_data$plate_sampleName[samples_data[,params$sampleGroupCovar]==sample_groups[k]]]
    # remove any control samples -- SC, IPC, NC
    sample_group_data <- sample_group_data[,colnames(sample_group_data) %in% samples_data$plate_sampleName[samples_data$sampleType=='Sample']]
    
    if (!is.null(colnames(sample_group_data))) {
      # sort targets
      target_medians <- apply(sample_group_data, 1, median)
      target_medians <- target_medians[order(target_medians, decreasing=TRUE)]
      sample_group_data <- sample_group_data[names(target_medians),]
      # calculate detectability
      detect <- apply(sample_group_data, 1, function(x) sum(x > 0)) / ncol(sample_group_data) * 100
      # create colors to indicate detectability
      makeColors <- colorRamp(colors=c('blue', 'pink'))
      detectColors <- makeColors(detect/100)
      detectColors <- apply(detectColors, 1, 
                            function(x) rgb(x[1], x[2], x[3], maxColorValue=255))
      
      # define filename and plot title
      sample_group_filename <- paste0('./outputFiles/target_detectability_boxplot_all_plates_', sample_groups[k], '.pdf')
      sample_group_title <- paste0('Target detectability: All plates, ', sample_groups[k], ' (n = ', ncol(sample_group_data), ')')
      pdf(sample_group_filename, width=20, height=7)
      # make plot
      par(mar=c(4,4,2,0.5))
      boxplot(t(sample_group_data), 
              horizontal=FALSE,
              xlab='',
              ylab='NPQ - LOD',
              main=sample_group_title,
              las=3, 
              lty=1,
              pch=16, 
              cex=0.5,
              staplelty=0,
              cex.axis=0.4,
              yaxt='n',
              col=detectColors)
      axis(side=2, las=1)
      grid(nx=NA, ny=NULL)
      abline(h=0, col='darkred')
      axis_limits <- par('usr')
      text(x=axis_limits[1] + (axis_limits[2] - axis_limits[1])/20, y=0,
           labels='LOD', col='darkred', cex=0.8, pos=3)
      
      # make legend
      # add color gradient legend
      # define coordinates
      axis_limits <- par('usr')
      x_axis_length <- axis_limits[2] - axis_limits[1]
      y_axis_length <- axis_limits[4] - axis_limits[3]
      legend_length <- x_axis_length/6
      legend_right <- axis_limits[2] - x_axis_length/20
      legend_left <- legend_right - legend_length
      legend_height <- y_axis_length/20
      legend_top <- axis_limits[4] - y_axis_length/10
      legend_bottom <- legend_top - legend_height
      # create color gradient
      colfunc <- colorRampPalette(c('blue', 'pink'))
      legend_image <- as.raster(matrix(colfunc(20), nrow=1))
      rasterImage(legend_image, legend_left, legend_bottom, legend_right, legend_top)
      # make labels
      text(x=seq(legend_left, legend_right, l=6), 
           y = legend_bottom - y_axis_length/40,
           labels = seq(0,100,l=6), 
           cex=0.8, adj=0.5)
      text(x=(legend_left+legend_right)/2, y=legend_top, 
           labels='detectability (%)', pos=3, cex=0.8) # end legend
      dev.off()
    }
  }
}



```
