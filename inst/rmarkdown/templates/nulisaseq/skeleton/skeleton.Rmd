---
output:
  html_document:
    toc: yes
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
library(gdata)
```

```{r, include=FALSE}
###############################################################################
# User-changeable settings / parameters for running the template
###############################################################################

### Data directory
dataDir <- '/Users/dkuo/Projects/NULISAseqR/data'

### Input file names
xmlFiles <- c(
#  '20221226_Cleveland_plate01_nomismatch_XML.xml',
#  '20221227_cleveland_plate02_nononmatch_XML.xml',
#  '20221227_Cleveland_plate03_nononmatch_XML.xml',
#  '20221229_cleveland_plate04_nononmatch_XML.xml',
  '20221229_cleveland_plate05_nononmatch_XML.xml',
  '20221230_Cleveland_plate06_nononmatch_XML.xml'
  )

### Document Text
study_name<- "Study Name"
assayName <- "NULISAseq 200-plex Inflammation Panel"
sample_desc <- "This is a sample description"
goal_desc <- " NULISAseq 200-plex inflammation panel"

### Special Targets
#IC <- c('mCherry', 'NIC_1', 'NIC_3') #Internal Control
IC <- c('mCherry') #Internal Control

### Special Samples
IPC <- c('IPC') #"InterPlateControl"
NC <- c('NC') #"NegativeControl"
Bridge <- c('Donor') #NULL

### Heat map values are relative or absolute
heatMapRel <- TRUE

### XML annotation names relating to plate row, column and name
rowAnnotName <- "Annot2"
colAnnotName <- "Annot3"
plateAnnotName <- "Annot1"
```

```{r, include=FALSE}
###############################################################################
# Function for colorizing wells
###############################################################################

wellorder <- function(samples, rowAnnotName, colAnnotName){
  cmd <- paste0("samples$", colAnnotName)
  cols <- eval(parse(text=cmd))
  cols <- formatC( as.numeric(cols), width=2, flag=0)
  cmd <- paste0("samples$", rowAnnotName)
  inds <- sort(paste0(eval(parse(text=cmd)), cols), index.return=T)
  return(inds$ix)
}

###############################################################################
# Read in files
###############################################################################
multipleFiles = if(length(xmlFiles) > 1) TRUE else FALSE
title_var <- paste(study_name, assayName, sep='<br>')
boxplot_colors <- unlist(lapply(alamarColorPalette(n=4, tint='light', nReps=4), function(x) x[3]))
knitr::opts_knit$set(root.dir=dataDir)
xmlFilesPath <- paste0(dataDir, "/", xmlFiles)
xmlFilePlateNames <- rep("", times=length(xmlFiles))
runs <- vector('list', length(xmlFiles))
runSummarys <- vector('list', length(xmlFiles))
read_summary <- NULL
PlateNames <- NULL
for(i in 1:length(xmlFiles)){
  # Read each run1
  plateID <- if(xmlFilePlateNames[i] == "") paste0("plate", i) else xmlFilePlateNames[i]
  runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=plateID)
  xmlFilePlateNames[i] <- plateID
  ICs  <- runs[[i]]$targets$targetName[which(grepl(paste(IC, collapse="|"),  runs[[i]]$targets$targetName))]
  IPCs <- runs[[i]]$samples$sampleName[which(grepl(paste(IPC, collapse="|"), runs[[i]]$samples$sampleName))]
  NCs  <- runs[[i]]$samples$sampleName[which(grepl(paste(NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  IPCs <- paste0(plateID, "_", IPCs)
  NCs  <- paste0(plateID, "_", NCs)

  # Summarize each Plate
  runSummarys[[i]] <- plateSummary(runs[[i]], ICs=ICs, IPCs=IPCs, NCs=NCs)
  read_summary <- cbind(read_summary,runSummarys[[i]]$readsTable)
  PlateNames <- c(PlateNames, paste("Plate", i, sep=" "))
}
names(runs) <- xmlFilePlateNames
names(runSummarys) <- xmlFilePlateNames
colnames(read_summary) <- PlateNames
rownames(read_summary)[length(xmlFiles)] <- 'Total samples * targets'
read_summary <- t(read_summary)
```

```{r, include=FALSE}
run_lod <- vector('list',length(xmlFiles))
for (i in 1:length(xmlFiles)){
  # replace NAs with 0
  runs[[i]]$Data[is.na(runs[[i]]$Data)] <- 0

  # calculate LODs 
  NCs  <- runs[[i]]$samples$sampleName[which(grepl(paste(NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  plateID <- if(xmlFilePlateNames[i] == "") paste0("plate", i) else xmlFilePlateNames[i]
  NCs  <- paste0(plateID, "_", NCs)
  run_lod[[i]] <- lod(data_matrix=runs[[i]]$Data, blanks=NCs, min_count=0)
}
```

```{r, include=FALSE}
# do intra-plate normalizations
plateNorms <- vector("list", length(xmlFiles))
for (i in 1:length(xmlFiles)){
  plateNorms[[i]] <- vector("list", length(ICs))
  for (j in 1:length(ICs)){
    plateNorms[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                               method="IC",
                               IC=ICs[j])
  }
  names(plateNorms[[i]]) <- ICs
}
names(plateNorms) <- xmlFilePlateNames
```

```{r, include=FALSE}
# do inter-plate normalization 

normData <- list()
IPC_wells <- NC_wells <- Bridge_wells <- IPC_wells_orig <- NC_wells_orig <- Bridge_wells_orig <- list(list())
for (i in 1:length(xmlFiles)){
  normData[[i]] <- plateNorms[[i]]$mCherry$normData
  IPC_wells_orig[[i]] <- runs[[i]]$samples$sampleName[which(grepl(paste(IPC, collapse="|"), runs[[i]]$samples$sampleName))]
  plateID <- if(xmlFilePlateNames[i] == "") paste0("run", i) else xmlFilePlateNames[i]
  if(!is.null(Bridge)){
    Bridge_wells_orig[[i]] <-runs[[i]]$samples$sampleName[which(grepl(paste(Bridge, collapse="|"), runs[[i]]$samples$sampleName))]
    Bridge_wells[[i]] <- paste0(plateID,"_", Bridge_wells_orig[[i]])
  }
  IPC_wells[[i]] <- paste0(plateID, "_", IPC_wells_orig[[i]])
  NC_wells_orig[[i]]  <- runs[[i]]$samples$sampleName[which(grepl(paste(NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  NC_wells[[i]]  <- paste0(plateID, "_", NC_wells_orig[[i]]) 
} 

# using intra-plate means
# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')
# using intra-plate means
# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                              IPC=FALSE, IN=TRUE,
                              IPC_wells=IPC_wells,
                              NC_wells=NC_wells
                            )
```

```{r, include=FALSE}
# do inter-plate bridge sample normalization 
# mCherry + bridge
if(length(Bridge_wells[[1]])){
  mCherry_bridge <- interPlateNorm(data_list=normData,
                                 IPC=FALSE, IN=TRUE,
                                 IN_samples=Bridge_wells
                                  )
}
```

```{r, include=FALSE}
# calculate intra-plate CVs unnormalized
# using the sample controls 

intraCV_unnorm <- NULL
intraCV_mCherry <- NULL
for (i in 1:length(xmlFiles)){
  sc <- rep(NA, 96)
  sc[colnames(runs[[i]]$Data) %in% IPC_wells[[i]]]<- 'SC'
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                 samples=sc,
                                 aboveLOD=run_lod[[i]]$aboveLOD,
                                 exclude_targets=ICs)
# combine plates into one matrix
  intraCV_unnorm <- cbind(intraCV_unnorm, plate_unnorm_intraCV) 
  plate_mCherry_intraCV <- intraCV(data_matrix=plateNorms[[i]]$mCherry$normData,
                                  samples=sc,
                                  aboveLOD=run_lod[[i]]$aboveLOD,
                                  exclude_targets=ICs)
  intraCV_mCherry <- cbind(intraCV_mCherry, plate_mCherry_intraCV)
}

colnames(intraCV_unnorm) <- PlateNames

# calculate intra-plate CVs mCherry
colnames(intraCV_mCherry) <- PlateNames

# create intra-plate CV table
intraCV_unnorm_summary_table <- cbind(colMeans(intraCV_unnorm, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, sd, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, median, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, min, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, max, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, function(x){
                                        sum(is.na(x))
                                      }))


rownames(intraCV_unnorm_summary_table) <- PlateNames
colnames(intraCV_unnorm_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')

# create intra-plate CV table
intraCV_mCherry_summary_table <- cbind(colMeans(intraCV_mCherry, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, sd, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, median, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, min, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, max, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, function(x){
                                         sum(is.na(x))
                                       }))

rownames(intraCV_mCherry_summary_table) <- PlateNames
colnames(intraCV_mCherry_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# calculate inter-plate CVs 
# using individual replicates

# run-run plates 1-6
# un-normalized data
scs <- vector("list", length(xmlFiles))
plateData <- vector("list", length(xmlFiles))
aboveLOD <- vector("list", length(xmlFiles))
exclude_targets <- vector("list", length(xmlFiles))
plate_mCherry <- vector("list", length(xmlFiles))
for(i in 1:length(xmlFiles)){
  sc <- rep(NA, 96)
  sc[colnames(runs[[i]]$Data) %in% IPC_wells[[i]]]<- 'SC'
  scs[[i]] <- sc
  plateData[[i]] <- runs[[i]]$Data
  aboveLOD[[i]] <- run_lod[[i]]$aboveLOD
  exclude_targets[[i]] <- ICs
  plate_mCherry[[i]] <- plateNorms[[i]]$mCherry$normData
}
interCV_unnorm <- interCV(data_list=plateData,
                          samples=scs,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry normalized data
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=scs,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC normalized data
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=scs,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN normalized data
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=scs,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)

# mCherry + bridge sample normalized data
if(length(Bridge_wells[[1]])){
  interCV_mCherry_bridge <- interCV(data_list=mCherry_bridge$interNormData,
                                  samples=scs,
                                  aboveLOD=aboveLOD,
                                  exclude_targets=exclude_targets,
                                  useMean=FALSE)
}

# combine results into one matrix
interCV_results <- NULL
if(length(Bridge_wells[[1]])){
  interCV_results <- cbind(interCV_unnorm,
                         interCV_mCherry,
                         interCV_mCherry_IPC,
                         interCV_mCherry_IN,
                         interCV_mCherry_bridge)
  colnames(interCV_results) <- c('unnorm',
                               'mCherry',
                               'mCherry + IPC',
                               'mCherry + IN',
                               'mCherry + bridge')
}else{
  interCV_results <- cbind(interCV_unnorm,
                         interCV_mCherry,
                         interCV_mCherry_IPC,
                         interCV_mCherry_IN)
                                  
  colnames(interCV_results) <- c('unnorm',
                               'mCherry',
                               'mCherry + IPC',
                               'mCherry + IN')
}

# create inter-plate CV table
interCV_summary_table <- cbind(colMeans(interCV_results, na.rm=TRUE),
                               apply(interCV_results, 2, sd, na.rm=TRUE),
                               apply(interCV_results, 2, median, na.rm=TRUE),
                               apply(interCV_results, 2, min, na.rm=TRUE),
                               apply(interCV_results, 2, max, na.rm=TRUE),
                               apply(interCV_results, 2, function(x){
                                 sum(is.na(x))
                               }))
if(length(Bridge_wells[[1]])){
  rownames(interCV_summary_table) <- c('unnorm',
                                                 'mCherry',
                                                 'mCherry + IPC',
                                                 'mCherry + IN',
                                                 'mCherry + bridge')
} else{
  rownames(interCV_summary_table) <- c('unnorm',
                                                 'mCherry',
                                                 'mCherry + IPC',
                                                 'mCherry + IN')
}
  colnames(interCV_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# convert data to long format
```

```{r, include=FALSE}
# calculate detectability
detectability_summary <- list()
detectability_tar <- NULL
for (i in 1:length(xmlFiles)){
  detect_samples <- colnames(plateNorms[[i]]$mCherry$normData)
  detect_samples <- detect_samples[-which(grepl(paste(IPC, collapse="|"), detect_samples))]
  detect_samples <- detect_samples[-which(grepl(paste(NC, collapse="|"), detect_samples))]
  detect_samples <- detect_samples[-which(grepl(paste(Bridge, collapse="|"), detect_samples))]
  plate_detect <- detectability(aboveLOD_matrix=run_lod[[i]]$aboveLOD,
                                 sample_subset=detect_samples,
                                 exclude_targets=ICs)
  detectability <- cbind(format(round(mean(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                                 format(round(sd(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                                 formatC(median(plate_detect$detectability, na.rm=TRUE), width=2),
                                 formatC(min(plate_detect$detectability, na.rm=TRUE), width=2),
                                 formatC(max(plate_detect$detectability, na.rm=TRUE), width=2),
                                 paste0(sum(plate_detect$detectability >= 50),
                                        ' (',
                                        format(round(sum(plate_detect$detectability > 50)/length(plate_detect$detectability) * 100, 1), nsmall=1),
                                        '%)'))
  colnames(detectability) <- c('mean',
                                     'sd',
                                     'median',
                                     'min',
                                     'max',
                                     'detectable targets n (%)')
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_tar <- cbind(detectability_tar, plate_detect$detectability)
}
rownames(detectability_summary) <- PlateNames
colnames(detectability_tar) <- PlateNames
```

```{r, include=FALSE}
# sample clustering
data_mCherry_scaled <- list(list())
for(i in 1:length(xmlFiles)){
  data_mCherry_scaled[[i]] <- scale(log2(plateNorms[[i]]$mCherry$normData+0.01))
#  colnames(data_mCherry_scaled[[i]]) <- paste0(sample_info$personID, '_', 
#                                        sample_info$sample, 
#                                        '_',
#                                        sample_info$sampleName)
}
```

---
title: `r title_var`
---

## Summary
* **Goal:** `r goal_desc`.
* Sample description: `r sample_desc`


---

## Plate layout
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  well_order <- wellorder(runs[[i]]$samples, rowAnnotName, colAnnotName)
  val <- matrix(runs[[i]]$samples[well_order,]$sampleName, nrow=8, byrow=T)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  B_well_orig <- if (!is.null(Bridge)) Bridge_wells_orig[[i]] else NULL
  well_types <- list(B_well_orig, IPC_wells_orig[[i]], NC_wells_orig[[i]])
  for (j in 1:length(well_types)){
    if (j == 1 && is.null(Bridge)){
      next
    }
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate/Sample Layout"), align="c",escape=F) %>% kable_styling(font_size=9))
}
```

---

## Read summary
```{r, results='asis'}
knitr::kable(read_summary, caption='', align='r', format.args=list(big.mark = ",")) %>% kable_styling()
```

---

### Internal controls (IC)
```{r, results='asis'}
if(length(ICs) == 1){
  IC_tables <- NULL
  for (i in 1:length(xmlFiles)){
    IC_tables <- rbind(IC_tables, runSummarys[[i]]$IC_table)
  }
  rownames(IC_tables) <- paste0("Plate", as.character(1:length(xmlFiles))) 
  cat(knitr::kable(IC_tables, caption="mCherry (IC) summary", align='r', format.args=list(big.mark = ",")) %>% kable_styling())  
}else{
  for(i in 1:length(xmlFiles)){
    cat(knitr::kable(runSummarys[[i]]$IC_table, caption=paste0("Plate ", as.character(i), ": IC summary"), align='r', format.args=list(big.mark = ",")) %>% kable_styling())  
  }
}
```

---

### Inter-plate control (IPC)
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  cat(knitr::kable(runSummarys[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ",")) %>% kable_styling())
}
```
---

### Negative control (NC) 
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  cat(knitr::kable(runSummarys[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summaray"), align='r', format.args=list(big.mark = ",")) %>% kable_styling())
}
```

---

### Heatmap
```{r, out.width='100%', fig.asp=0.33333*ceiling((length(ICs)+1)/2)}
if (heatMapRel){
  write("Numbers shown are percent relative to plate median",stdout());
}
for(i in 1:length(xmlFiles)){
  well_order <- wellorder(runs[[i]]$samples, rowAnnotName, colAnnotName)
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsTotal <- 1
  digitsmCherry <- if(heatMapRel) 1 else 0
  plateHeatmap(log2(colSums(runs[[i]]$Data, na.rm=TRUE)), title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), cex=0.5, digits=digitsTotal,
               well_order=well_order, relative=heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    plateHeatmap(runs[[i]]$Data[ICs[j],], title=paste0("Plate ", as.character(i),": ",  ICs[j]), cex=0.5, digits=digitsmCherry, well_order=well_order,relative=heatMapRel, cex.axis=0.5)
  }
}
```

---

## Quality Control:
### QC Flags
### Intra-plate CV
Only values above LOD were used to calculate %CV (no minimum count requirement). %CV was calculated for each of the 204 targets for the 2 pooled plasma (sample control) replicates (PP).

#### Intra-plate %CV table -- un-normalized
```{r}
knitr::kable(intraCV_unnorm_summary_table, caption='', align='r', 
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling()
```

#### Intra-plate %CV table -- mCherry-normalized
```{r}
knitr::kable(intraCV_mCherry_summary_table, caption='', align='r', 
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling()
```

#### Intra-plate CV boxplots by plate
```{r, out.width='100%', fig.asp=0.5}
intraCV_mCherry2 <- intraCV_mCherry
colnames(intraCV_mCherry2) <- paste0("*", colnames(intraCV_mCherry))
intraCV_vals <- t(interleave(t(intraCV_unnorm), t(intraCV_mCherry2), drop=F))
col <- alamarColorPalette(ceiling(length(intraCV_vals[1,])/2))
boxplot(intraCV_vals
        , las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(intraCV_vals), na.rm=TRUE)),
        main='Intra-plate CV (* - Normalized)', horizontal=T,
        col=interleave(col,col))
abline(v=c(0:8*5), col='grey', lty=3)
```

---

### Sample boxplots
```{r, out.width='100%', fig.asp=1}
sampleboxplot <- function( data, ordering, label, plate_sample_colors, boxplot_colors){
  boxplot(log2(data[,ordering]+0.01),
          las=1, yaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": ", label),
          outcex=0.5,
          col=plate_sample_colors, horizontal=T, cex=0.5)
  for (j in 1:96){
    color <- if(plate_sample_colors[j] == boxplot_colors[1]) "black" else plate_sample_colors[j]
    axis(2, at=j, labels=colnames(data)[ordering[j]], cex.axis=0.3, las=2, col.axis=color, tck=-0.01)
  }
  lines(cbind(log2(data['mCherry',ordering]+0.01), 1:96), col='red', las=1)
  mtext('log2(count + 0.01)', side=1, line=2)
  legend('topleft', 'mCherry', col='red', lty=1, cex=0.4, bty='n')
  abline(v=c(-50:50*5), col='grey', lty=3)
  return(NULL)
}

for(i in 1:length(xmlFiles)){
  plate_sample_type <- rep("1_sample",96)
  if(!is.null(Bridge)){
    plate_sample_type[grepl(paste0(Bridge_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '2_donor'
  }
  plate_sample_type[grepl(paste0(IPC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '3_IPC'
  plate_sample_type[grepl(paste0(NC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '4_NC'

  ordering2 <- wellorder(runs[[i]]$samples, rowAnnotName, colAnnotName) 
  ordering <- NULL
  types <- sort(unique(plate_sample_type))
  for(j in 1:length(types)){
    inds <- which(plate_sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }

  plate_sample_colors <- boxplot_colors[as.numeric(as.factor(plate_sample_type))[ordering]]
  par(mfrow=c(1,2), mar=c(4,6,2,0))
  sampleboxplot(runs[[i]]$Data, ordering, "unnormalized", plate_sample_colors, boxplot_colors)
  sampleboxplot(mCherry_IPC$interNormData[[i]], ordering, "mCherry + IPC", plate_sample_colors, boxplot_colors)
}
```

### Detectability table
```{r, results='asis'}
kable_styling(knitr::kable(detectability_summary, caption='Detectability Summary', align='r', 
             format.args=list(big.mark = ",", digits=2)))
kable_styling(knitr::kable(detectability_tar, caption='Target Detectability %', align='r', 
             format.args=list(big.mark = ",", digits=2)))
```

## Sample and target clustering 
```{r, out.width='100%', fig.asp=1, results='asis'}
wellcolors <- function(data, well_types, boxplot_colors ){
  mycolors <- rep("black", 96)
  for (j in 1:length(well_types)){
    if (j == 1 && well_types[j] == ""){
      next
    }
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    if(length(inds) > 0){
      mycolors[inds] <- boxplot_colors[j+1]
    }
  }
  return(mycolors)
}

paletteLength <- 50
myColor <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
for(i in 1:length(xmlFiles)){
  B_well_orig <- if (!is.null(Bridge)) Bridge_wells_orig[[i]] else ""
  well_types <- list(B_well_orig, IPC_wells_orig[[i]], NC_wells_orig[[i]])
  mycolors <- wellcolors(data_mCherry_scaled[[i]], well_types, boxplot_colors)
  myBreaks <- c(seq(min(data_mCherry_scaled[[i]]), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_scaled[[i]])/paletteLength, max(data_mCherry_scaled[[i]]), length.out=floor(paletteLength/2)))
  data_mCherry_scaled2 <- data.frame(t(data_mCherry_scaled[[i]]))
  data_mCherry_scaled2$status <- rep(1, 96) # 
  data_mCherry_scaled2$colors <- mycolors
  e <- pheatmap(data_mCherry_scaled2[,1:(length(data_mCherry_scaled2[1, ]) - 2)],
         main = paste("Plate", i), fontsize=5,
         color=myColor,
         breaks=myBreaks,
         show_colnames=FALSE, silent=T)
  cols <- data_mCherry_scaled2[order(match(rownames(data_mCherry_scaled2), e$gtable$grobs[[5]]$label)), ]$colors
  e$gtable$grobs[[5]]$gp=gpar(col=cols)
  grid::grid.newpage()
  grid::grid.draw(e$gtable)
  cat("\n")
}
```

## Sample correlation
```{r, out.width='100%', fig.asp=1, results='asis'}
for(i in 1:length(xmlFiles)){
  pdf(file=NULL)
  corrvals <- corrplot(cor(data_mCherry_scaled[[i]]), order='hclust') 
  dev.off()
  B_well_orig <- if (!is.null(Bridge)) Bridge_wells_orig[[i]] else ""
  well_types <- list(B_well_orig, IPC_wells_orig[[i]], NC_wells_orig[[i]])
  mycolors <- wellcolors(corrvals$corr, well_types, boxplot_colors)
  corrplot(corrvals$corr,
         tl.cex=0.4,
         mar=c(1,1,1,1),
         tl.col=mycolors,
         order="original",
         title=paste("Plate", i),
         is.corr=FALSE)
  cat("\n")
}
```

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate Normalization", 2)
pandoc.header("Inter-plate CV", 3)
cat("Only values above LOD were used to calculate %CV (no minimum count requirement). %CV was calculated for each of the 204 targets for the 2 pooled plasma (sample control) replicates (PP).")

pandoc.header("Inter-plate %CV", 3)
knitr::kable(interCV_summary_table, caption='', align='r', 
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling()
```

```{r out.width='100%', fig.asp=0.5, eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate CV boxplot", 3)
par(mfrow=c(1,2))
par(mar=c(5,12,1,1))
boxplot(interCV_results, las=1, xlab='inter-plate CV (%)',
        ylim=c(0, max(interCV_results, na.rm=TRUE)), col=alamarColorPalette(5), horizontal=T)
abline(v=c(0:16*5), col='grey', lty=3)
```

```{r, out.width='100%', fig.asp=0.5, results='asis', eval=multipleFiles}
pandoc.header("Sample / Plate PCA", 3)
doPCA <- function(data, plateVar, normed=F, scale=F, center=F){
  pca <- if(normed) prcomp(t(data), scale=scale, center=center) else prcomp(log2(t(data)+0.01), scale=scale, center=center)
  title <- if(normed) "Normalized" else "Unnormalized"
  par(mar=c(4,4,2,5))
  plot(pca$x[,1], pca$x[,2], 
       col=(1:length(levels(factor(plateVar))))[as.integer(factor(plateVar))],
       pch=(1:length(levels(factor(plateVar))))[as.integer(factor(plateVar))],
       xlab=paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), '% variance)'), 
       ylab=paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), '% variance)'), 
       main=title, las=1, cex=0.5)
  legend(par('usr')[2], par('usr')[4], levels(factor(plateVar)),
         col=1:length(levels(factor(plateVar))), xpd=NA,
         pch=1:length(levels(factor(plateVar))), cex=0.75, bty='n')
  return(NULL)
}

removeTargetsSamples <- function(data, NC, IPC){
  data <- data[-which(grepl("mCherry", rownames(data))),]
  data <- data[,-which(grepl(paste(c(NC, IPC), collapse="|"), colnames(data)))]
  return(data)
}

dataPCAunnormal <- dataPCAnormed <- plateVar <- NULL
for(i in 1:length(xmlFiles)){
  dataPCAunnormal <- cbind(dataPCAunnormal, removeTargetsSamples(runs[[i]]$Data, NC, IPC))
  dataPCAnormed <- cbind(dataPCAnormed, removeTargetsSamples(data_mCherry_scaled[[i]], NC, IPC))
  plateVar <- c(plateVar, rep(paste0("Plate",i), length(data_mCherry_scaled[[i]][1, ])))
}

par(mfrow=c(1,2))
e <- doPCA(dataPCAunnormal, plateVar, normed=F, scale=T, center=T)
e <- doPCA(dataPCAnormed, plateVar, normed=T, scale=T, center=T)
```

