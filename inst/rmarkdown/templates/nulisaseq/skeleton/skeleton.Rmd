---
params:
  ## internal control name(s) e.g. "mCherry", "NIC_1", "NIC_3" 
  # first IC will be used for LOD calculations (should typically be mCherry)
  IC: !r c("mCherry")
  ## string that denotes inter-plate controls
  # IPC: !r c("IPC")
  IPC: !r c("IPC_rep01", "IPC_rep02")
  ## string that denotes negative controls
  NC: !r c("NC")
  ## string that denotes sample controls
  # SC: !r c("SC")
  SC: !r c("IPC_rep03", "IPC_rep04")
  ## string that denotes bridge samples
  Bridge: !r NULL
  ## directory where xml files are located
  dataDir: "/Users/jbeer/github/TAP-Bonn-COVID/data"
  ## variables in XML that indicate row, column, and plate ID
  # rowAnnotName: "AUTO_WELLROW"
  # colAnnotName: "AUTO_WELLCOL"
  # plateAnnotName: "AUTO_PLATE"
  rowAnnotName: "Annot2"
  colAnnotName: "Annot3"
  plateAnnotName: "Annot1"
  ## should heatmaps show % median units?
  heatMapRel: !r TRUE
  study_name: "Study Name"
  assayName: "NULISAseq 200-plex Inflammation Panel"
  sample_desc: "This is a sample description."
  goal_desc: "NULISAseq 200-plex Inflammation Panel"
  xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml","20230109_TAP_covid_plate01_nononmatch_XML.xml", "20230109_TAP_covid_plate02_nononmatch_XML.xml")
  # xmlFiles: !r c("20230109_TAP_covid_plate01_nononmatch_XML.xml")
  ## manually set plate ID, otherwise plate ID will be 
  ## "Plate 1", "Plate 2", ... according to order of filenames 
  plateNames: !r c()
  ## type of report
  ## options:
  ## internal
  ## WebApp
  reportType: "internal"
output:
  html_document:
    toc: yes
    toc_depth: 4
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
library(gdata)
library(dplyr)
```

```{r, include=FALSE}
# function for colorizing wells in heatmap
# sampleTypeFactor should have levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC')
wellorder <- function(samples, sampleTypeFactor=NULL){
  cols <- formatC(as.numeric(samples$AUTO_WELLCOL), width=2, flag=0)
  rows <- samples$AUTO_WELLROW
  inds <- if(is.null(sampleTypeFactor)){
    sort(paste0(rows, cols), index.return=TRUE)
  } else sort(paste0(as.numeric(sampleTypeFactor), rows, cols), index.return=TRUE)
  return(inds$ix)
}

# function to convert data into matrix for plate layout and heatmap
matrixify <- function(runSamples, plate=FALSE){
  val <- matrix(rep(NA, 96), nrow=8)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  for(j in LETTERS[1:8]){
    for(k in 1:12){
      sample_jk <- runSamples$sampleName[runSamples$AUTO_WELLROW==j & runSamples$AUTO_WELLCOL==k]
      if(length(sample_jk)!=0){
        val[rownames(val)==j, colnames(val)==k] <- sample_jk
      }
      if(plate && length(sample_jk) == 0){
        val[rownames(val)==j, colnames(val)==k] <- ""
      }
    }
  }
  return(val)
}
```

```{r, include=FALSE}
# define title
title_var <- paste(params$study_name, params$assayName, sep='<br>')
# define sample specific boxplot colors for use in plots
boxplot_colors <- unlist(lapply(alamarColorPalette(n=5, tint='light', nReps=5), function(x) x[4]))
# set data directory
if(is.null(params$dataDir)){
  xmlFilesPath <- params$xmlFiles
} else {
  knitr::opts_knit$set(root.dir=params$dataDir)
  # save xml file path
  xmlFilesPath <- paste0(params$dataDir, "/", params$xmlFiles)
}
# define variables to store results
runs <- vector('list', length(params$xmlFiles))
runSummaries <- vector('list', length(params$xmlFiles))
read_summary <- NULL
# define plateIDs / plate names
if(length(params$plateNames) == 0){
  PlateNames <- paste0('Plate ', 1:length(params$xmlFiles))
} else {
  PlateNames <- params$plateNames
}
# read in XML files
for(i in 1:length(params$xmlFiles)){
  runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=PlateNames[i], 
                             NC=params$NC, SC=params$SC, IC=params$IC, 
                             IPC=params$IPC, Bridge=params$Bridge)
  # summarize each plate
  runSummaries[[i]] <- plateSummary(runs[[i]])
  read_summary <- cbind(read_summary, runSummaries[[i]]$readsTable)
  if(is.null(runs[[i]]$samples[["AUTO_PLATE"]]) | !is.null(params$plateAnnotName)){
    runs[[i]]$samples$AUTO_PLATE = eval(str2expression(paste0("runs[[i]]$samples$", params$plateAnnotName)))
  }
  if(is.null(runs[[i]]$samples[["AUTO_WELLROW"]]) | !is.null(params$rowAnnotName)){
    runs[[i]]$samples$AUTO_WELLROW = eval(str2expression(paste0("runs[[i]]$samples$", params$rowAnnotName)))
  }
  if(is.null(runs[[i]]$samples[["AUTO_WELLCOL"]]) | !is.null(params$colAnnotName)){
    runs[[i]]$samples$AUTO_WELLCOL = eval(str2expression(paste0("runs[[i]]$samples$", params$colAnnotName)))
  }
}
names(runs) <- names(runSummaries) <- PlateNames
colnames(read_summary) <- PlateNames
# transpose read summary
read_summary <- t(read_summary)
# set multiple file indicator
multipleFiles <- if(length(params$xmlFiles) > 1) TRUE else FALSE
# set SC indicator
indicatorSC <- if(sum(sapply(runs, function(x) length(x$SC)))==0) FALSE else TRUE
# set Bridge indicator
indicatorBridge <- if(sum(sapply(runs, function(x) length(x$Bridge)))==0) FALSE else TRUE
```

```{r, include=FALSE}
# do intra-plate normalization
intraPlateNormData <- vector("list", length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  intraPlateNormData[[i]] <- vector("list", length(runs[[i]]$IC))
  for (j in 1:length(runs[[i]]$IC)){
    intraPlateNormData[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                                                   method="IC",
                                                   IC=runs[[i]]$IC[j])
  }
  names(intraPlateNormData[[i]]) <- runs[[i]]$IC[j]
}
names(intraPlateNormData) <- PlateNames
```

```{r, include=FALSE}
# calculate LOD on the IC normalized data
# use 1st IC as the primary IC (should be mCherry)
plate_lod <- vector('list', length(params$xmlFiles))
for (i in 1:length(params$xmlFiles)){
  plate_lod[[i]] <- lod(data_matrix=intraPlateNormData[[i]][[1]]$normData, 
                        blanks=runs[[i]]$NC, 
                        min_count=0)
}
```

```{r, include=FALSE}
# do inter-plate normalization 
# save mCherry-normalized data in a list
normData <- lapply(intraPlateNormData, function(x) x[[1]]$normData)

# save IPC, NC, etc wells for each plate
IPC_wells <- lapply(runs, function(x) x$IPC)
NC_wells <- lapply(runs, function(x) x$NC)
SC_wells <- lapply(runs, function(x) x$SC)
Bridge_wells <- lapply(runs, function(x) x$Bridge)

# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')

# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                             IPC=FALSE, IN=TRUE,
                             IPC_wells=IPC_wells,
                             NC_wells=NC_wells)

if(indicatorBridge==TRUE){
  mCherry_Bridge <- interPlateNorm(data_list=normData,
                                   IPC=FALSE, IN=TRUE,
                                   IN_samples=Bridge_wells)
}
```

```{r, include=FALSE}
# calculate intra-plate CVs on unnormalized and mCherry normalized data
# using IPCs and SCs (sample controls) if present
IPC_intraCV_unnorm <- IPC_intraCV_mCherry <- NULL
if(indicatorSC==TRUE){
  SC_intraCV_unnorm <- SC_intraCV_mCherry <- NULL
}
# loop through plates and calculate CVs
for (i in 1:length(params$xmlFiles)){
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(runs[[i]]$samples))
  IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(runs[[i]]$Data) %in% runs[[i]]$SC] <- 'SC'
  }
  # unnormalized intraCV
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                  samples=IPC_SC_samples,
                                  aboveLOD=plate_lod[[i]]$aboveLOD,
                                  exclude_targets=runs[[i]]$IC)
  # combine plates into one matrix
  IPC_intraCV_unnorm <- cbind(IPC_intraCV_unnorm, plate_unnorm_intraCV[,'IPC']) 
  if(indicatorSC==TRUE){
    SC_intraCV_unnorm <- cbind(SC_intraCV_unnorm, plate_unnorm_intraCV[,'SC'])
  }
  # mCherry intraCV
  plate_mCherry_intraCV <- intraCV(data_matrix=intraPlateNormData[[i]]$mCherry$normData,
                                   samples=IPC_SC_samples,
                                   aboveLOD=plate_lod[[i]]$aboveLOD,
                                   exclude_targets=runs[[i]]$IC)
  # combine plates into one matrix
  IPC_intraCV_mCherry <- cbind(IPC_intraCV_mCherry, plate_mCherry_intraCV[,'IPC'])
  if(indicatorSC==TRUE){
    SC_intraCV_mCherry <- cbind(SC_intraCV_mCherry, plate_mCherry_intraCV[,'SC'])
  }
}

colnames(IPC_intraCV_unnorm) <- colnames(IPC_intraCV_mCherry) <- PlateNames
if(indicatorSC==TRUE){
  colnames(SC_intraCV_unnorm) <- colnames(SC_intraCV_mCherry) <- PlateNames
}

# function to summarize columns of a matrix
column_summary_stats <- function(x, rowNames=colnames(x)){
  output <- cbind(colMeans(x, na.rm=TRUE),
                  apply(x, 2, sd, na.rm=TRUE),
                  apply(x, 2, median, na.rm=TRUE),
                  apply(x, 2, min, na.rm=TRUE),
                  apply(x, 2, max, na.rm=TRUE),
                  apply(x, 2, function(y){
                    sum(is.na(y))
                  }))
  colnames(output) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
  rownames(output) <- rowNames
  return(output)
}

# create CV summary tables
IPC_intraCV_unnorm_summary_table <- column_summary_stats(IPC_intraCV_unnorm)
IPC_intraCV_mCherry_summary_table <- column_summary_stats(IPC_intraCV_mCherry)
if(indicatorSC==TRUE){
  SC_intraCV_unnorm_summary_table <- column_summary_stats(SC_intraCV_unnorm)
  SC_intraCV_mCherry_summary_table <- column_summary_stats(SC_intraCV_mCherry)
}

```

```{r, include=FALSE}
# calculate inter-plate CVs on unnormalized, mCherry normalized,
# and inter-plate normalized data
# using IPCs and SCs (sample controls) if present

# get input data lists
IPC_SC_samples_list <- lapply(runs, function(x) {
  # define IPC / SC vector
  IPC_SC_samples <- rep(NA, nrow(x$samples))
  IPC_SC_samples[colnames(x$Data) %in% x$IPC] <- 'IPC'
  if(indicatorSC==TRUE){
    IPC_SC_samples[colnames(x$Data) %in% x$SC] <- 'SC'
  }
  return(IPC_SC_samples)
})
plateData <- lapply(runs, function(x) x$Data)
plate_mCherry <- lapply(intraPlateNormData, function(x) x$mCherry$normData)
aboveLOD <- lapply(plate_lod, function(x) x$aboveLOD)
exclude_targets <- lapply(runs, function(x) x$IC)

# unnormalized interCV
interCV_unnorm <- interCV(data_list=plateData,
                          samples=IPC_SC_samples_list,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry interCV
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=IPC_SC_samples_list,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC interCV
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=IPC_SC_samples_list,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN interCV
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=IPC_SC_samples_list,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)


if(indicatorBridge==FALSE){
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_mCherry[,'IPC'],
                               interCV_mCherry_IPC[,'IPC'],
                               interCV_mCherry_IN[,'IPC'])
  
  colnames(IPC_interCV_results) <- c('unnorm',
                                     'mCherry',
                                     'mCherry + IPC',
                                     'mCherry + IN')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_mCherry[,'SC'],
                                interCV_mCherry_IPC[,'SC'],
                                interCV_mCherry_IN[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'mCherry',
                                      'mCherry + IPC',
                                      'mCherry + IN')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results)
  }
}


if(indicatorBridge==TRUE){
  # mCherry + Bridge
  interCV_mCherry_Bridge <- interCV(data_list=mCherry_Bridge$interNormData,
                                    samples=IPC_SC_samples_list,
                                    aboveLOD=aboveLOD,
                                    exclude_targets=exclude_targets,
                                    useMean=FALSE)
  # combine results into one matrix
  IPC_interCV_results <- cbind(interCV_unnorm[,'IPC'],
                               interCV_mCherry[,'IPC'],
                               interCV_mCherry_IPC[,'IPC'],
                               interCV_mCherry_IN[,'IPC'],
                               interCV_mCherry_Bridge[,'IPC'])
  
  colnames(interCV_results) <- c('unnorm',
                                 'mCherry',
                                 'mCherry + IPC',
                                 'mCherry + IN',
                                 'mCherry + Bridge')
  
  # create IPC inter-plate CV summary table
  IPC_interCV_summary_table <- column_summary_stats(IPC_interCV_results)
  
  if(indicatorSC==TRUE){
    # combine results into one matrix
    SC_interCV_results <- cbind(interCV_unnorm[,'SC'],
                                interCV_mCherry[,'SC'],
                                interCV_mCherry_IPC[,'SC'],
                                interCV_mCherry_IN[,'SC'],
                                interCV_mCherry_Bridge[,'SC'])
    
    colnames(SC_interCV_results) <- c('unnorm',
                                      'mCherry',
                                      'mCherry + IPC',
                                      'mCherry + IN',
                                      'mCherry + Bridge')
    
    # create SC inter-plate CV summary table
    SC_interCV_summary_table <- column_summary_stats(SC_interCV_results)
  }
}


```

```{r, include=FALSE}
# calculate detectability on regular samples only
# NOTE: we may also want to add detectability_summary for IPCs, SCs, and Bridge samples
detectability_summary <- detectability_targets <- NULL
for (i in 1:length(params$xmlFiles)){
  plate_detect <- detectability(aboveLOD_matrix=plate_lod[[i]]$aboveLOD,
                                sample_subset=runs[[i]]$SampleNames,
                                exclude_targets=runs[[i]]$IC)
  detectability <- cbind(length(runs[[i]]$SampleNames),
                         format(round(mean(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         format(round(sd(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                         formatC(median(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(min(plate_detect$detectability, na.rm=TRUE), width=2),
                         formatC(max(plate_detect$detectability, na.rm=TRUE), width=2),
                         paste0(sum(plate_detect$detectability >= 50),
                                ' (',
                                format(round(sum(plate_detect$detectability > 50)/length(plate_detect$detectability) * 100, 1), nsmall=1),
                                '%)'))
  colnames(detectability) <- c('# samples', 
                               'mean',
                               'sd',
                               'median',
                               'min',
                               'max',
                               '# of detectable targets (%)')
  detectability_summary <- rbind(detectability_summary, detectability)
  detectability_targets <- cbind(detectability_targets, plate_detect$detectability)
}

rownames(detectability_summary) <- colnames(detectability_targets) <- PlateNames

# if more than one plate, summarize across plates using weighted average
if(length(params$xmlFiles) > 1){
  plate_sample_size <- sapply(runs, function(x) length(x$SampleNames))
  plate_weights <- plate_sample_size / sum(plate_sample_size)
  detectability_targets <- cbind(detectability_targets,
                                 Overall=apply(detectability_targets, 1, function(x){
                                   sum(x*plate_weights)
                                 }))
  detectability_overall <- cbind(sum(plate_sample_size),
                                 format(round(mean(detectability_targets[,'Overall'], na.rm=TRUE), 1), nsmall=1),
                                 format(round(sd(detectability_targets[,'Overall'], na.rm=TRUE), 1), nsmall=1),
                                 formatC(median(detectability_targets[,'Overall'], na.rm=TRUE), width=2),
                                 formatC(min(detectability_targets[,'Overall'], na.rm=TRUE), width=2),
                                 formatC(max(detectability_targets[,'Overall'], na.rm=TRUE), width=2),
                                 paste0(sum(detectability_targets[,'Overall'] >= 50),
                                        ' (',
                                        format(round(sum(detectability_targets[,'Overall'] > 50)/length(detectability_targets[,'Overall']) * 100, 1), nsmall=1),
                                        '%)'))
  colnames(detectability_overall) <- c('# samples', 
                                       'mean',
                                       'sd',
                                       'median',
                                       'min',
                                       'max',
                                       '# of detectable targets (%)')
  rownames(detectability_overall) <- 'Overall'
  detectability_summary <- rbind(detectability_summary, detectability_overall)
  
}


```

```{r, include=FALSE}
# log transform and scale data for clustered heatmap
# and sample correlation plot
data_mCherry_log2_scaled <- list()
data_mCherry_log2_no_NC_scaled <- list()
for(i in 1:length(params$xmlFiles)){
  data_mCherry <- intraPlateNormData[[i]]$mCherry$normData
    # remove ICs
  data_mCherry <- data_mCherry[!grepl(paste(runs[[i]]$IC, collapse="|"), rownames(data_mCherry)),]
  # remove NCs to calculate center and scale (so NCs don't skew the scale parameters)
  data_mCherry_no_NC <- data_mCherry[,!grepl(paste(runs[[i]]$NC, collapse="|"), colnames(data_mCherry))]
  data_mCherry_log2_no_NC_scaled[[i]] <- t(scale(t(log2(data_mCherry_no_NC + 0.01)),
                                           center=TRUE, scale=TRUE))
  # log transform and scale targets
  data_mCherry_log2_scaled[[i]] <- t(scale(t(log2(data_mCherry + 0.01)),
                                           center=attributes(data_mCherry_log2_no_NC_scaled[[i]])$`scaled:center`, 
                                           scale=attributes(data_mCherry_log2_no_NC_scaled[[i]])$`scaled:scale`))
}
```

---
title: `r title_var`
---
```{r, results='asis', eval=params$reportType!="WebApp"}
pandoc.header("Study summary", 2)
elements <- c(paste("Goal:", params$goal_desc), paste("Sample Description:", params$sample_desc))
pandoc.list(elements, style="bullet")
```

---

## Plate layout
```{r, results='asis'}
pandoc.p("Shows the layout of samples, controls (e.g., negative controls (NC), inter-plate controls (IPC)), and special wells if any (e.g., sample controls (SC), bridge samples) on the 96 well assay plate." )
for(i in 1:length(params$xmlFiles)){
  val <- matrixify(runs[[i]]$samples, plate=TRUE)
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){      well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){  well_types <- append(well_types, list(Bridge_wells[[i]]))}
  
  for (j in 1:length(well_types)){
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  val <- gsub('_', ' ', val) # replace underscore with space for text wrapping
  table.attr <- paste0("id=\"plate-summary", i, "\"")
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate Layout"), 
                   align="c", escape=FALSE, table.attr=table.attr) %>%
        kable_styling(font_size=9, bootstrap_options = c("striped", "hover", "condensed"), 
                      full_width = TRUE) %>%
        column_spec(column=1:13, width = "1.75cm", border_left = TRUE, border_right = TRUE) %>%
        row_spec(0:8, extra_css = "border-bottom: 1px solid") 
  )
}
```

---

## Read summary
```{r, results='asis'}
pandoc.p("Summary of the number and classification of reads for the assay run") 
pandoc.list(c("Parseable - Valid next generation sequencing (NGS) read (assay signal or background)",
              "Parseable Match - Valid NGS read (assay signal)",
              "Parseable Non-match - Vaild NGS read (assay background)",
              "Unparseable - Sequencing background",
              "Total samples - Total number of samples on plate (including controls)",
              "Total targets - Total number of assay targets (including internal controls)",
              "Zero values - Number of targets * samples which had no assay signal"
))
knitr::kable(read_summary, caption='', 
             align='r', format.args=list(big.mark = ","), 
             table.attr="id=\"read-summary\"") %>% 
  kable_styling(bootstrap_options=c("striped", "hover", "condensed"), full_width=TRUE)
```

---

### Internal controls (IC)
```{r, results='asis'}
pandoc.p("Each sample of the assay is spiked with the same concentration of an internal control (IC). This is used both as part of a well normalization procedure and as a method for assessing the uniformity of the assay run.") 
if(length(params$IC) == 1){
  IC_tables <- NULL
  for (i in 1:length(params$xmlFiles)){
    IC_tables <- rbind(IC_tables, runSummaries[[i]]$IC_table)
  }
  rownames(IC_tables) <- paste0("Plate", as.character(1:length(params$xmlFiles))) 
  cat(knitr::kable(IC_tables, 
                   caption="mCherry (IC) summary", 
                   align='r', 
                   format.args=list(big.mark = ","), 
                   table.attr="id=\"IC-summary\"") %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))  
} else {
  for(i in 1:length(params$xmlFiles)){
    table.attr <- paste0("id=\"IC-summary", i, "\"")
    cat(knitr::kable(runSummaries[[i]]$IC_table, 
                     caption=paste0("Plate ", as.character(i), ": IC summary"), 
                     align='r', 
                     format.args=list(big.mark = ","), 
                     table.attr=table.attr) %>% 
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```

---

### Inter-plate controls (IPC)
```{r, results='asis'}
pandoc.p("IPC samples are pooled plasma controls used both to normalize samples between experiments and to assess performance (e.g., precision) of the assay.")
pandoc.p("Note: %CV in this table does not exclude values below LOD. See [Intra-plate normalization](#intraPlateNorm) or [Inter-plate normalization](#interPlateNorm) sections for %CV (before and after normalization) that excludes values below LOD.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"IPC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---


### Negative controls (NC) 
```{r, results='asis'}
pandoc.p("NC wells are reactions where no sample input is provided (i.e., buffer only). These are used to assess Limit of Detection (LOD) for each target assay and to assess run quality (e.g., background levels).")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"NC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

```{r eval=indicatorSC, results='asis'}
pandoc.header("Sample controls (SC)", 3)
pandoc.p("SC samples are pooled plasma controls from an independent pooled plasma source that is different from IPCs. They could be a pooled sample derived from all study samples, for example. They should be from the same source across all plates that will be analysed together. SCs are used for calculating intra- and inter-plate coefficient of variation (CV). They are necessary for obtaining an unbiased measure of inter-plate CV when IPC normalization is used.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"SC-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$SC_table, caption=paste0("Plate ", as.character(i), ": SC summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

```{r eval=indicatorBridge, results='asis'}
pandoc.header("Bridge samples (Bridge)", 3)
pandoc.p("Bridge samples can be used for inter-plate normalization. Bridge sample normalization uses the bridge sample subset to estimate plate- and target-specific medians, and then uses these medians to normalize all samples in a manner similar to intensity normalization.")
for(i in 1:length(params$xmlFiles)){
  table.attr <- paste0("id=\"Bridge-summary", i, "\"")
  cat(knitr::kable(runSummaries[[i]]$Bridge_table, caption=paste0("Plate ", as.character(i), ": Bridge summary"), align='r', format.args=list(big.mark = ","), table.attr=table.attr) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
}
```

---

## Heatmaps
```{r, out.width='100%', fig.asp=0.33333*ceiling((length(params$IC)+1)/2), results='asis'}
heatmap_description <- if (params$heatMapRel==TRUE) "percent relative to plate median" else "absolute normalized read count"
pandoc.p(paste0("Heatmaps show the ", heatmap_description, " for log2(total counts) and the specified internal control."))
for(i in 1:length(params$xmlFiles)){
  ICs <- which(runs[[i]]$targets$targetType == "Control")
  val <- matrixify(runs[[i]]$samples)
  vals <- unlist(as.list(t(val)))
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(2,2,2,1))
  digitsmCherry <- if(params$heatMapRel) 1 else 0
  logVals <- log2(colSums(runs[[i]]$Data, na.rm=TRUE))
  well_order <- wellorder(runs[[i]]$sample)
  val <- vals
  val[which(!is.na(vals))] <- logVals[well_order]
  plateHeatmap(as.numeric(val), 
               title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), 
               cex=0.5, digits=1,
               relative=params$heatMapRel, cex.axis=0.5)
  for (j in 1:length(ICs)){
    val <- vals
    val[which(!is.na(vals))] <- runs[[i]]$Data[ICs[j],][well_order]
    plateHeatmap(as.numeric(val), 
                 title=paste0("Plate ", as.character(i),": ",  runs[[i]]$IC[j]), 
                 cex=0.5, digits=digitsmCherry, 
                 relative=params$heatMapRel, cex.axis=0.5)
  }
}
```

---

## Quality control

### Plate QC

```{r, results='asis'}
pandoc.p("Plate-specific QC criteria:")
pandoc.list(c(paste0("ICRead_CV - Coefficient of Variation of internal control signal across all samples (maximum = ", QCPlateCriteria()$thresholds['ICRead_CV']*100,"%)"),
              paste0("IPCRead_CV - Coefficient of Variation of the total assay signal across all IPCs (maximum = ", QCPlateCriteria()$thresholds['IPCRead_CV']*100,"%)"),
              paste0("IPCTarget_CV - Median Coefficient of Variation of all IPC targets (maximum = ", QCPlateCriteria()$thresholds['IPCTarget_CV']*100,"%)"),
              paste0("Detectability - Percentage of targets that are detectable (target is considered detectable if > 50% samples have signal > LOD) (minimum = ",  QCPlateCriteria()$thresholds['Detectability']*100,"%)"),
              paste0("MinReads - Number of total Parseable Match reads (signal) for the experiment (minimum = ", QCPlateCriteria()$thresholds['MinReads'],")"
              )))
pandoc.p("QC criteria are assessed either on unnormalized (raw) or IC-normalized (IC) data.")

for( i in 1:length(runs)){
  qcPlate <- QCFlagPlate(runs[[i]]$Data, normData[[i]], runs[[i]]$targets, runs[[i]]$samples)
  table.attr <- paste0("id=\"QCFlagPlate-summary", i, "\"")
  qcPlate$status[which(qcPlate$status == "F")] <- "Pass"
  qcPlate$status[which(qcPlate$status == "T")] <- "Fail"
  qcPlate$QCthreshold[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$QCthreshold[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$QCthreshold[nrow(qcPlate)] <- format(as.numeric(qcPlate$QCthreshold[nrow(qcPlate)]), big.mark=",")
  qcPlate$val[1:nrow(qcPlate)-1] <- paste0(format(as.numeric(qcPlate$val[1:nrow(qcPlate)-1])*100, digits=2), "%")
  qcPlate$val[nrow(qcPlate)] <- format(as.numeric(qcPlate$val[nrow(qcPlate)]), big.mark=",")
  cat(knitr::kable(qcPlate[,1:5], 
                   caption=paste0("Plate ", as.character(i), ": Plate QC Flag Summary"), 
                   align='r', 
                   format.args=list(big.mark = ",", digits=2),
                   table.attr=table.attr,
                   col.names = c("Flag Name", "Normalization", "QC Status", "QC Value", "QC Threshold"
                   )) %>%
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) %>%
        row_spec(which(qcPlate$status == "Fail"), bold=T, color="white", background="red"))
}
```

### Sample QC 
#### Sample QC summary tables
```{r, out.width='100%', results='asis'}
pandoc.p("Sample-specific QC criteria:")
pandoc.list(c(paste0("Detectability - Percentage of targets above LOD for a sample (minimum = ", as.numeric(QCSampleCriteria()$thresholds['Detectability'])*100,"%)"),
              paste0("ICReads - Number of IC reads for a sample (minimum = ", QCSampleCriteria()$thresholds['ICReads'],")"),
              paste0("NumReads - Number of total Parseable Match (signal) reads for a sample (minimum = ", QCSampleCriteria()$thresholds['NumReads'],")"),
              paste0("IC_Median - % deviation from the overall plate median IC reads (within +/-", as.numeric(unname(unlist(strsplit(QCSampleCriteria()$thresholds['IC_Median'], ',')))[2])*100, "% of plate median)")
))

# make empty sample QC summary table
criteria <- QCSampleCriteria()
rowNameQC <- c()
QCSummary <- matrix(nrow=length(runs) + 1, ncol=length(criteria$thresholds) + 1)
for (i in 1:length(runs)){
  QCSummary[i,1] <- length(runs[[i]]$SampleNames)
  rowNameQC <- c(rowNameQC,  paste0("Plate ", as.character(i))) 
}

# loop over criteria
# get xlim for plots
rmin <- rmax <- val <- list()
for (i in 1:length(runs)){
  well_order <- wellorder(runs[[i]]$samples)
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  for (j in 1:length(criteria$thresholds)){
    inds <- which(qcSample$flagName == names(criteria$thresholds)[j])
    QC_criterion_j_data <- qcSample[inds, ]
    val[j] <- criteria$thresholds[j]#if(names(criteria$thresholds)[j] == "Detectability") as.numeric(unlist(strsplit(criteria$thresholds[j],",")))*100 else unlist(strsplit(criteria$thresholds[j],","))
    if(names(criteria$thresholds)[j] == "Detectability"){
      xval <- as.numeric(QC_criterion_j_data$val)*100
      rmax[j] <- 100.0
      rmin[j] <- min(as.numeric(val[[j]])*100, as.numeric(xval), na.rm=TRUE) 
    }else if (names(criteria$thresholds)[j] == "IC_Median"){
      xval <- as.numeric(QC_criterion_j_data$val)*100
      minmaxVal <- unname(unlist(strsplit(val[[j]], ",")))
      rmin[j] <- min(as.numeric(minmaxVal[1])*100, as.numeric(xval), na.rm=TRUE)
      rmax[j] <- max(as.numeric(minmaxVal[2])*100, as.numeric(xval), na.rm=TRUE)
    }else{
      xval <- as.numeric(QC_criterion_j_data$val)
      rmin[j] <- min(as.numeric(val[[j]]), as.numeric(xval), na.rm=TRUE)
      rmax[j] <- max(as.numeric(val[[j]]), as.numeric(xval), na.rm=TRUE)
    }
    # add a small amount of padding to x axis limits
    if(names(criteria$thresholds)[j] %in% c("ICReads", "NumReads")){
      rlim_delta <- log10(rmax[[j]][1]) - log10(rmin[[j]][1])
      rmin[[j]][1] <- 10^(log10(rmin[[j]][1]) - 0.025 * rlim_delta)
      rmax[[j]][1] <- 10^(log10(rmax[[j]][1]) + 0.025 * rlim_delta)
    } else {
      rlim_delta <- rmax[[j]][1] - rmin[[j]][1]
      rmin[[j]][1] <- rmin[[j]][1] - 0.025 * rlim_delta
      rmax[[j]][1] <- rmax[[j]][1] + 0.025 * rlim_delta
    }
    # count how many samples fail QC (excludes controls)
    QCSummary[i, j+1] <- length(which(QC_criterion_j_data[QC_criterion_j_data$sampleName %in% runs[[i]]$SampleNames,]$status=="TRUE"))
  }
}

# fill in & format QCSummary
QCSummary[i+1, ] <- colSums(QCSummary, na.rm=TRUE) 
rownames(QCSummary) <- c(rowNameQC, "Total")
colnames(QCSummary) <- c("# of Samples", names(criteria$thresholds))

# print sample QC summary table
knitr::kable(QCSummary, caption='Number of samples that fail each QC Flag (excludes IPC, SC, NC & bridge samples)', 
             align='r', 
             table.attr="id=\"QC-summary-table\"",
             format.args=list(big.mark = ",", digits=2, escape=FALSE)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r, out.width='100%', results='asis'}
# table to show which specific samples fail each QC flag
QC_sample_fail <- vector(mode='list', length=length(names(criteria$thresholds)))
names(QC_sample_fail) <- names(criteria$thresholds)
QC_sample_fail <- lapply(QC_sample_fail, function(x) x <- data.frame(Plate=character(0), QC_fail_samples=character(0)))
for (i in 1:length(runs)){
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  for (j in 1:length(criteria$thresholds)){
    QC_criterion_j_data <- qcSample[qcSample$flagName == names(criteria$thresholds)[j], ]
    QC_criterion_j_data_samples <- QC_criterion_j_data[QC_criterion_j_data$sampleName %in% runs[[i]]$SampleNames,]
    QC_fail_samples_j <- QC_criterion_j_data_samples$sampleName[QC_criterion_j_data_samples$status==TRUE]
    # reverse so they are sorted A1 - H12 
    QC_fail_samples_j <- rev(QC_fail_samples_j)
    if(length(QC_fail_samples_j) > 0){
      QC_sample_fail[[j]] <- rbind(QC_sample_fail[[j]], data.frame(Plate=PlateNames[i], QC_fail_samples=QC_fail_samples_j))
    }
  }
}

# print QC fail tables
# need to fix table.attr
for(i in 1:length(names(criteria$thresholds))){
  if(nrow(QC_sample_fail[[i]]) > 0){
    cat(knitr::kable(QC_sample_fail[[i]], caption=paste0('Samples that fail ', names(criteria$thresholds)[i]), 
                     align='r', 
                     table.attr="id=\"sample-QC-summary-table\"",
                     format.args=list(big.mark = ",", digits=2, escape=FALSE)) %>% 
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE))
  }
}
```


#### Sample QC plots
```{r, out.width='100%', fig.asp=1, results='asis'}
# make sample QC plots
for( i in 1:length(runs)){
  # sort in order: samples, IPC, SC, Bridge, NC
  sampleType_factor <- factor(runs[[i]]$sample$sampleType,
                              levels=c('Sample', 'IPC', 'SC', 'Bridge', 'NC'))
  well_order <- wellorder(runs[[i]]$samples, 
                          sampleTypeFactor=sampleType_factor)
  # do sample QC
  qcSample <- QCFlagSample(runs[[i]]$Data, normData[[i]], runs[[i]]$samples, runs[[i]]$targets, well_order)
  if(indicatorSC){
    inds <- which(grepl(paste(runs[[i]]$SC, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "SC"
  }
  if(indicatorBridge){
    inds <- which(grepl(paste(runs[[i]]$Bridge, collapse="|"), qcSample$sampleName))
    qcSample[inds, ]$sampleType <- "Bridge"
  }
  
  # make plots
  par(mfcol=c(1, length(criteria$thresholds)+1), mar=c(5,0.05,2,0.05))
  # empty plot 
  dotchart(x=rep(0, length(sampleType_factor)), 
           xlab='',
           xlim=c(50, 100),
           labels=qcSample[inds, ]$sampleName,
           color="white", 
           lcolor='white',
           gcolor='black',
           xaxt='n', frame.plot=FALSE,
           offset=-1,
           cex=0.45)
  title(main=PlateNames[i])
  
  
  for(j in 1:length(names(criteria$thresholds))){
    inds <- which(qcSample$flagName == names(criteria$thresholds)[j])
    xlab <- ""
    xval <- NULL
    # define xlabels
    if(names(criteria$thresholds)[j] == "Detectability"){
      xlab <- "Detectability %"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    } else if(names(criteria$thresholds)[j] == "IC_Median"){
      xlab <- "% of mCherry Median"
      xval <- as.numeric(qcSample[inds, ]$val)*100
    } else {
      xlab <- "Number of Reads"
      xval <- as.numeric(qcSample[inds, ]$val)
      zs <- which(xval == 0)
      if(length(zs) > 0){
        xval[zs] <- xval[zs]+1
      }
    }
    
    # use log scale for number of reads
    log <- if(names(criteria$thresholds)[j] != "Detectability" && names(criteria$thresholds)[j] != "IC_Median") "x" else ""
    # use y labels only for first plot
    if(j==1) {
      labels <- qcSample[inds, ]$sampleName
    } else {
      labels <- rep('', length(xval))
    }
    # define colors
    color <- rep("black", length(inds))
    color[which(qcSample[inds,]$sampleType == "IPC")] <- boxplot_colors[2]
    color[which(qcSample[inds,]$sampleType == "NC")] <- boxplot_colors[3]
    if (length(which(qcSample[inds,]$sampleType == "SC")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "SC")] <- boxplot_colors[4]
    }
    if (length(which(qcSample[inds,]$sampleType == "Bridge")) > 0 ){
      color[which(qcSample[inds,]$sampleType == "Bridge")] <- boxplot_colors[5]
    }
    dotchart(x=as.numeric(xval), 
             xlab=xlab, 
             labels=rep('', length(xval)), las=1, 
             cex=0.45, xlim=c(rmin[[j]], rmax[[j]]), 
             color=color, log=log)
    if(j==1){
      # need to loop over labels and color individuals
      for (k in 1:length(xval)){
        axis(side=2, at=k, 
             labels=labels[k], col.axis=color[k], las=1,
             cex.axis=0.5)
      }
    }
    # color points green if PASS, red if FAIL
    xvalFail <- xval
    xvalFail[which(qcSample[inds,]$status != TRUE)] <- NA
    xvalPass <- xval
    xvalPass[which(qcSample[inds,]$status != FALSE)] <- NA
    points(as.numeric(xvalPass),1:length(xvalPass), pch=19, col="green")
    points(as.numeric(xvalFail),1:length(xvalFail), pch=19, col="red")
    
    if(names(criteria$thresholds)[j] == "IC_Median"){
      minmaxVal <- unlist(strsplit(val[[j]], ","))
      abline(v=as.numeric(minmaxVal[[1]])*100, col='brown')
      abline(v=as.numeric(minmaxVal[[2]])*100, col='brown')
      abline(v=0, col='brown', lty=2)
    }else{
      value <- if(criteria$format[j] == "percentage") as.numeric(val[[j]])*100 else as.numeric(val[[j]])
      abline(v=value, col='brown')
    }
    legend('bottomright', legend=c('Pass', "Fail"), col=c('green', 'red'), pch=19, cex=0.4, bty='n', inset=c(0,1), xpd=T,horiz=T)
    title(main=names(criteria$thresholds)[j], cex.main=1)
  } 
}
```

---

## Detectability
Target detectability is the percentage of samples that are above the limit of detection for that target. A target is considered "detectable" if it is above limit of detection in at least 50% of samples. "Overall" detectability is the overall percentage of samples across all plates that are above LOD for a given target. Target detectability reported here excludes IPCs, SCs, NCs, and bridge samples. 
```{r, echo=FALSE}
# calculate fig.asp for detectability plots
detect_fig_asp <- 2*ceiling(length(params$xmlFiles)/2)
```

```{r, results='asis', out.width='100%', fig.asp=detect_fig_asp}
pandoc.header("Detectability summary", 3)
# Detectability summary
kable_styling(knitr::kable(detectability_summary, caption='', 
                           align='r', 
                           table.attr="id=\"detectability-summary\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```

```{r, results='asis', out.width='100%', fig.asp=detect_fig_asp}
pandoc.header("Target detectability %", 3)
# Target detectability
kable_styling(knitr::kable(detectability_targets, caption='', 
                           align='r', 
                           table.attr="id=\"detectability-indepth\"",
                           format.args=list(big.mark = ",", digits=2)), 
              bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE) 
```

```{r, results='asis', out.width='100%', fig.asp=2*ceiling(length(params$xmlFiles)/2)}
# Target Boxplot
pandoc.header("Target detectability boxplot", 3)
pandoc.p("Plot shows target mCherry-normalized count distributions relative to LOD. For each target, log2(LOD) was subtracted from log2(count) for mCherry-normalized data.")
par(mfrow=c(ceiling(length(params$xmlFiles)/2), 2), mar=c(4,2,2,1))
for (i in 1:length(params$xmlFiles)){
  targetBoxplot(intraPlateNormData[[i]][[1]]$normData, 
                title=PlateNames[i], 
                subtractLOD=TRUE, 
                blanks=runs[[i]]$NC, 
                horizontal=TRUE, 
                replace_zero_LOD=FALSE,
                axis_lab_normalized=TRUE,
                cex.targets=0.25, 
                excludeTargets=runs[[i]]$IC, 
                excludeSamples=c(runs[[i]]$IPC, runs[[i]]$NC, runs[[i]]$SC))
}
```

---

## Intra-plate normalization {#intraPlateNorm}
%CV was calculated for each target (excluding internal controls) for the sample control replicates (if given) and IPCs. Only values above LOD were used to calculate %CV. 


```{r, eval=(params$reportType=="internal" & indicatorSC==TRUE), results='asis'}
pandoc.header("Intra-plate %CV table -- unnormalized", 3)
knitr::kable(SC_intraCV_unnorm_summary_table, caption='SC intra-plate %CV -- unnormalized', align='r', table.attr="id=\"SC-intra-plateCV-unnorm-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

knitr::kable(IPC_intraCV_mCherry_summary_table, caption='IPC intra-plate %CV -- unnormalized', align='r', table.attr="id=\"IPC-intra-plateCV-unnorm-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

pandoc.header("Intra-plate %CV table -- mCherry-normalized", 3)
knitr::kable(SC_intraCV_mCherry_summary_table, caption='SC intra-plate %CV -- mCherry-normalized', align='r', table.attr="id=\"SC-intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

knitr::kable(IPC_intraCV_mCherry_summary_table, caption='IPC intra-plate %CV -- mCherry-normalized', align='r', table.attr="id=\"IPC-intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r, eval=(params$reportType=="internal" & indicatorSC==FALSE), results='asis'}
pandoc.header("Intra-plate %CV table -- unnormalized", 3)
knitr::kable(IPC_intraCV_mCherry_summary_table, caption='IPC intra-plate %CV -- unnormalized', align='r', table.attr="id=\"IPC-intra-plateCV-unnorm-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)

pandoc.header("Intra-plate %CV table -- mCherry-normalized", 3)
knitr::kable(IPC_intraCV_mCherry_summary_table, caption='IPC intra-plate %CV -- mCherry-normalized', align='r', table.attr="id=\"intra-plateCV-mCherry-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


### Intra-plate %CV boxplots by plate
```{r, out.width='100%', fig.asp=(0.2*length(runs) + 0.15), eval=indicatorSC}
SC_intraCV_unnorm2 <- SC_intraCV_unnorm
colnames(SC_intraCV_unnorm2) <- paste0(colnames(SC_intraCV_mCherry), ' unnormalized')
SC_intraCV_mCherry2 <- SC_intraCV_mCherry
colnames(SC_intraCV_mCherry2) <- paste0(colnames(SC_intraCV_mCherry), ' mCherry-normalized')
SC_intraCV_vals <- t(interleave(t(SC_intraCV_unnorm2), t(SC_intraCV_mCherry2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(SC_intraCV_vals[1,])/2), nReps=2)))
par(mar=c(5, 7, 2, 1))
boxplot(SC_intraCV_vals[,ncol(SC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(SC_intraCV_vals), na.rm=TRUE)),
        main='SC Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r, out.width='100%', fig.asp=(0.2*length(runs) + 0.15)}
IPC_intraCV_unnorm2 <- IPC_intraCV_unnorm
colnames(IPC_intraCV_unnorm2) <- paste0(colnames(IPC_intraCV_mCherry), ' unnormalized')
IPC_intraCV_mCherry2 <- IPC_intraCV_mCherry
colnames(IPC_intraCV_mCherry2) <- paste0(colnames(IPC_intraCV_mCherry), ' mCherry-normalized')
IPC_intraCV_vals <- t(interleave(t(IPC_intraCV_unnorm2), t(IPC_intraCV_mCherry2), drop=FALSE))
col <- rev(unlist(alamarColorPalette(ceiling(length(IPC_intraCV_vals[1,])/2), nReps=2)))
par(mar=c(5, 7, 2, 1))
boxplot(IPC_intraCV_vals[,ncol(IPC_intraCV_vals):1], las=1, xlab='intra-plate CV (%)',
        ylim=c(0, max(c(IPC_intraCV_vals), na.rm=TRUE)),
        main='IPC Intra-plate CV', horizontal=T, cex.axis=0.5, lex.order=T,
        col=col)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

## Sample boxplots
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Sample boxplots show distributions of the log2 counts for each sample, unnormalized and after mCherry + IPC normalization.")

# function to draw boxplot
sampleboxplot <- function(data, ordering, label, plate_sample_colors, boxplot_colors){
  par(mar=c(2,6,2,0.5))
  boxplot(log2(data[,ordering]+0.01),
          las=1, 
          yaxt='n',
          xaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": ", label),
          outcex=0.5,
          col=plate_sample_colors, 
          horizontal=TRUE, 
          cex=0.5,
          cex.main=0.75,
          cex.lab=0.75)
  for (j in 1:ncol(data)){
    color <- if(plate_sample_colors[j] == boxplot_colors[1]) "black" else plate_sample_colors[j]
    axis(2, at=j, labels=FALSE, cex.axis=0.3, las=2, col.axis=color, tck=-0.01)
    axis(2, at=j, labels=colnames(data)[ordering[j]], cex.axis=0.3, las=2, col.axis=color, tick=FALSE, line=-0.75)
  }
  axis(side=1, labels=FALSE, tck=-0.01)
  axis(side=1, labels=TRUE, cex.axis=0.5, line=-1, tick=FALSE)
  # add mCherry line
  lines(cbind(log2(data['mCherry', ordering]+0.01), 1:ncol(data)), col='red', las=1)
  mtext('log2(count + 0.01)', side=1, line=0.75, cex=0.5)
  legend('topleft', 'mCherry', col='red', lty=1, cex=0.4, bty='n')
  abline(v=c(-50:50*5), col='grey', lty=3)
}

for(i in 1:length(params$xmlFiles)){
  plate_sample_type <- rep("1_sample", ncol(runs[[i]]$Data))
  plate_sample_type[grepl(paste0(IPC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '3_IPC'
  # put NCs last
  plate_sample_type[grepl(paste0(NC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '6_NC'
  # put colors in order 
  boxplot_colors2 <- boxplot_colors[c(1,2,3)]
  if(indicatorSC){
    plate_sample_type[grepl(paste0(SC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '4_SC'
    boxplot_colors2 <- boxplot_colors[c(1,2,4,3)]
  }
  if(indicatorBridge){
    plate_sample_type[grepl(paste0(Bridge_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '5_Bridge'
    boxplot_colors2 <- boxplot_colors[c(1,2,5,3)]
  }
  if(indicatorSC & indicatorBridge){
    boxplot_colors2 <- boxplot_colors[c(1,2,4,5,3)]
  }
  ordering2 <- wellorder(runs[[i]]$samples) 
  ordering <- NULL
  types <- sort(unique(plate_sample_type))
  for(j in 1:length(types)){
    inds <- which(plate_sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }
  # reverse ordering so special wells are at the bottom
  ordering <- rev(ordering)
  plate_sample_colors <- boxplot_colors2[as.numeric(as.factor(plate_sample_type))[ordering]]
  numPlots <- if(params$reportType == "internal") 2 else 1
  par(mfrow=c(1,numPlots), mar=c(4,6,2,0))
  if(params$reportType == "internal"){
    sampleboxplot(runs[[i]]$Data, ordering, "unnormalized", plate_sample_colors, boxplot_colors2)
  }
  sampleboxplot(mCherry_IPC$interNormData[[i]], ordering, "mCherry + IPC", plate_sample_colors, boxplot_colors2)
}
```

---

## Sample correlation
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Plot shows the Pearson correlation between samples. Heirarchical clustering is done using complete linkage.")
wellcolors <- function(data, well_types, boxplot_colors){
  # all labels black by default
  colors <- rep("black", ncol(data))
  for (j in 1:length(well_types)){
    # save indices matching the given well type
    indices <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    # color well label to match well type
    if(length(indices) > 0){
      colors[indices] <- boxplot_colors[j+1]
    }
  }
  return(colors)
}

for(i in 1:length(params$xmlFiles)){
  pdf(file=NULL)
  corrvals <- corrplot(cor(data_mCherry_log2_scaled[[i]]), 
                       order='hclust') 
  dev.off()
  
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  colors <- wellcolors(data=corrvals$corr, 
                       well_types=well_types, 
                       boxplot_colors=boxplot_colors)
  corrplot(corrvals$corr,
           tl.cex=0.4,
           mar=c(1,1,1,1),
           tl.col=colors,
           order="original",
           title=paste("Plate", i),
           is.corr=FALSE)
  cat("\n")
}
```

---

## Sample and target clustering 
```{r, out.width='100%', fig.asp=1, results='asis'}
pandoc.p("Hierarchical clustering of both samples and targets was done using a Euclidean distance metric and complete linkage. Data is log2 and mCherry-normalized; targets are centered and scaled.")
# define colors
paletteLength <- 50
heatmapColors <- colorRampPalette(c("royalblue1", "white", "red"))(paletteLength)
# loop over plates and draw heatmaps
for(i in 1:length(params$xmlFiles)){
  # define label colors
  well_types <- list(IPC_wells[[i]], NC_wells[[i]])
  if(indicatorSC){ well_types <- append(well_types, list(SC_wells[[i]]))}
  if(indicatorBridge){ well_types <- append(well_types, list(Bridge_wells[[i]]))}
  label_colors <- wellcolors(data=data_mCherry_log2_scaled[[i]], 
                             well_types=well_types, 
                             boxplot_colors=boxplot_colors)
  # define color scale breaks
  # omit NCs for determining min
  breaks <- c(seq(min(data_mCherry_log2_no_NC_scaled[[i]]), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_log2_scaled[[i]])/paletteLength, 
                  max(data_mCherry_log2_scaled[[i]]), length.out=floor(paletteLength/2)))
  # transpose and add color variable
  data_mCherry_log2_scaled2 <- data.frame(t(data_mCherry_log2_scaled[[i]]))
  data_mCherry_log2_scaled2$label_colors <- label_colors
  # generate heatmap for plate i
  heatmap_i <- pheatmap(data_mCherry_log2_scaled2[,1:(ncol(data_mCherry_log2_scaled2) - 1)],
                        main = paste("Plate", i), 
                        fontsize=5,
                        color=heatmapColors,
                        breaks=breaks,
                        show_colnames=FALSE, silent=TRUE)
  # put colors in order
  label_colors_ordered <- data_mCherry_log2_scaled2[order(match(rownames(data_mCherry_log2_scaled2), heatmap_i$gtable$grobs[[5]]$label)),]$label_colors
  # add label colors to plot
  heatmap_i$gtable$grobs[[5]]$gp=gpar(col=label_colors_ordered)
  grid::grid.newpage()
  grid::grid.draw(heatmap_i$gtable)
  cat("\n")
}
```

---

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate normalization {#interPlateNorm}", 2)
cat("%CV was calculated for each target (excluding internal controls) for the sample control replicates. Only values above LOD were used to calculate %CV.")
```

```{r eval=multipleFiles, results='asis'}
pandoc.header("Inter-plate %CV", 3)

if(params$reportType != "internal"){
  remove <- "mCherry + IN"
  if(indicatorSC==TRUE){
    SC_interCV_summary_table2 <- SC_interCV_summary_table[!(rownames(SC_interCV_summary_table) %in% remove),]
    SC_interCV_results2 <- SC_interCV_results[, !(colnames(SC_interCV_results) %in% remove)]
  }
  IPC_interCV_summary_table2 <- IPC_interCV_summary_table[!(rownames(IPC_interCV_summary_table) %in% remove),]
  IPC_interCV_results2 <- IPC_interCV_results[, !(colnames(IPC_interCV_results) %in% remove)]
} else {
  if(indicatorSC==TRUE){
    SC_interCV_summary_table2 <- SC_interCV_summary_table
    SC_interCV_results2 <- SC_interCV_results
  }
  IPC_interCV_summary_table2 <- IPC_interCV_summary_table
  IPC_interCV_results2 <- IPC_interCV_results
}

if(indicatorSC==TRUE){
  knitr::kable(SC_interCV_summary_table2, 
               caption='SC inter-plate %CV', 
               align='r', 
               table.attr="id=\"SC-inter-plateCV-summary\"",
               format.args=list(big.mark = ",", digits=3)) %>% 
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
}

knitr::kable(IPC_interCV_summary_table2, 
             caption='IPC inter-plate %CV', 
             align='r', 
             table.attr="id=\"IPC-inter-plateCV-summary\"",
             format.args=list(big.mark = ",", digits=3)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = TRUE)
```


```{r out.width='100%', fig.asp=0.5, eval=(multipleFiles & indicatorSC), results='asis'}
pandoc.header("Inter-plate %CV boxplot", 3)

par(mar=c(5,12,2,1))
boxplot(SC_interCV_results2[,ncol(SC_interCV_results2):1], las=1, 
        xlab='inter-plate CV (%)',
        ylim=c(0, max(SC_interCV_results2, na.rm=TRUE)), 
        main='SC Inter-plate CV',
        col=rev(alamarColorPalette(ncol(SC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

```{r out.width='100%', fig.asp=0.5, eval=(multipleFiles & indicatorSC), results='asis'}
par(mar=c(5,12,2,1))
boxplot(IPC_interCV_results2[,ncol(IPC_interCV_results2):1], las=1, 
        xlab='inter-plate CV (%)',
        ylim=c(0, max(IPC_interCV_results2, na.rm=TRUE)), 
        main='IPC Inter-plate CV',
        col=rev(alamarColorPalette(ncol(IPC_interCV_results2))), horizontal=TRUE)
abline(v=c(0:200*5), col='grey', lty=3)
```

---

```{r, out.width='100%', fig.asp=(0.4)+as.numeric(multipleFiles)*0.4, results='asis', eval=params$reportType=="internal"}
pandoc.header("Sample PCA", 2)
# function to make PCA plot
PCAplot <- function(data, plateID, IPC_samples, SC_samples, Bridge_samples, scale=TRUE, center=TRUE, title=NULL){
  pca <- prcomp(log2(t(data)+0.01), scale=scale, center=center)
  plateID <- factor(plateID)
  colors <- alamarColorPalette(length(levels(plateID)))
  point_shapes <- rep(1, ncol(data))
  point_shapes[colnames(data) %in% IPC_samples] <- 8
  legendText <- c(levels(plateID), 'Sample', 'IPCs')
  legend_point_shapes <- rep(1, (length(levels(plateID)) + 1))
  legend_point_shapes <- c(legend_point_shapes, 8)
  if(indicatorSC==TRUE){
    point_shapes[colnames(data) %in% SC_samples] <- 9
    legendText <- c(legendText, "SCs")
    legend_point_shapes <- c(legend_point_shapes, 9)
  }
  if(indicatorBridge==TRUE){
    point_shapes[colnames(data) %in% Bridge_samples] <- 10
    legendText <- c(legendText, "Bridge")
    legend_point_shapes <- c(legend_point_shapes, 10)
  }
  
  legend_colors <- c(colors, rep('black', (length(legend_point_shapes) - length(colors))))
  
  # make plot
  par(mar=c(4,4,2,5))
  plot(pca$x[,1], pca$x[,2],
       col=colors[as.integer(plateID)],
       pch=point_shapes,
       xlab=paste0('PC1 (', format(round(summary(pca)$importance[2,1]*100, 1), nsmall=1), 
                   '% variance)'),
       ylab=paste0('PC2 (', format(round(summary(pca)$importance[2,2]*100, 1), nsmall=1), 
                   '% variance)'),
       main=title, las=1, cex=0.5)
  legend(par('usr')[2], par('usr')[4], 
         legendText,
         col=legend_colors, xpd=NA,
         pch=legend_point_shapes, cex=0.75, bty='n')
}

# function to remove targets and samples
removeTargetsSamples <- function(data, NC, IC){
  data <- data[-which(grepl(paste(IC, collapse="|"), rownames(data))),]
  data <- data[,-which(grepl(paste(NC, collapse="|"), colnames(data)))]
  return(data)
}

# merge data across plates for PCA
dataPCA_unnorm <- dataPCA_mCherry <- dataPCA_mCherryIPC <- dataPCA_mCherryIN <- plateID <- NULL
for(i in 1:length(params$xmlFiles)){
  dataPCA_unnorm <- cbind(dataPCA_unnorm, removeTargetsSamples(runs[[i]]$Data, runs[[i]]$NC, runs[[i]]$IC))
  dataPCA_mCherry <- cbind(dataPCA_mCherry, removeTargetsSamples(intraPlateNormData[[i]][[1]]$normData, runs[[i]]$NC, runs[[i]]$IC))
  dataPCA_mCherryIPC <- cbind(dataPCA_mCherryIPC, removeTargetsSamples(mCherry_IPC$interNormData[[i]], runs[[i]]$NC, runs[[i]]$IC))
  dataPCA_mCherryIN <- cbind(dataPCA_mCherryIN, removeTargetsSamples(mCherry_IN$interNormData[[i]], runs[[i]]$NC, runs[[i]]$IC))
  plateID <- c(plateID, rep(paste0("Plate",i), ncol(removeTargetsSamples(runs[[i]]$Data, runs[[i]]$NC, runs[[i]]$IC))))
}
IPC_all <- unlist(lapply(runs, function(x) x$IPC))
SC_all <- unlist(lapply(runs, function(x) x$SC))
Bridge_all <- unlist(lapply(runs, function(x) x$Bridge))

# set plot layout params
nRowsPCA <- if(multipleFiles) 2 else 1
nCols <- 2

# draw plots
par(mfrow=c(nRowsPCA, nCols))
PCAplot(dataPCA_unnorm, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all, scale=TRUE, center=TRUE, title="Unnormalized")
PCAplot(dataPCA_mCherry, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all,scale=TRUE, center=TRUE, title="mCherry")
if(multipleFiles){
  PCAplot(dataPCA_mCherryIPC, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all, scale=TRUE, center=TRUE, title="mCherry + IPC")
  if(params$reportType == "internal"){
    PCAplot(dataPCA_mCherryIN, plateID, IPC_samples=IPC_all, SC_samples=SC_all, Bridge_samples=Bridge_all, scale=TRUE, center=TRUE, title="mCherry + IN")
  }
}
```
