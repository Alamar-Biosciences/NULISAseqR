---
output:
  html_document:
    toc: yes
date: "`r Sys.Date()`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(NULISAseqR)
library(kableExtra)
library(knitr)
library(pheatmap)
library(corrplot)
library(pander)
library(grid)
```

```{r, include=FALSE}
###############################################################################
# List of input files (XML)
###############################################################################
dataDir <- '/Users/dkuo/Projects/NULISAseqR/data'
xmlFiles <- c(
  '20221226_Cleveland_plate01_nomismatch_XML.xml',
  '20221227_cleveland_plate02_nononmatch_XML.xml',
  '20221227_Cleveland_plate03_nononmatch_XML.xml',
  '20221229_cleveland_plate04_nononmatch_XML.xml',
  '20221229_cleveland_plate05_nononmatch_XML.xml',
  '20221230_Cleveland_plate06_nononmatch_XML.xml'
  )

###############################################################################
# Strings to define IPC, NC, IC and bridge samples.
# Note Bridge samples can be set to NULL
###############################################################################
study_name<- "Study Name"
assayName <- "NULISAseq 200-plex Inflammation Panel"
sample_desc <- "This is a sample description"
goal_desc <- " NULISAseq 200-plex inflammation panel"

IC <- c('mCherry') #"Internal Control"
IPC <- c('IPC') #"InterPlateControl"
NC <- c('NC') #"NegativeControl"
Bridge <- c('Donor') #NULL
heatMapRel <- TRUE

###############################################################################
# Annotation in XML file corresponding to row and column
###############################################################################
rowAnnotName <- "Annot2"
colAnnotName <- "Annot3"
plateAnnotName <- "Annot1"
```

```{r, include=FALSE}
###############################################################################
# Function for colorizing wells
###############################################################################

wellorder <- function(samples, rowAnnotName, colAnnotName){
  cmd <- paste0("samples$", colAnnotName)
  cols <- eval(parse(text=cmd))
  cols <- formatC( as.numeric(cols), width=2, flag=0)
  cmd <- paste0("samples$", rowAnnotName)
  inds <- sort(paste0(eval(parse(text=cmd)), cols), index.return=T)
  return(inds$ix)
}

###############################################################################
# Read in files
###############################################################################
title_var <- paste(study_name, assayName, sep='<br>')
boxplot_colors <- unlist(lapply(alamarColorPalette(n=4, tint='light', nReps=4), function(x) x[3]))
knitr::opts_knit$set(root.dir=dataDir)
xmlFilesPath <- paste0(dataDir, "/", xmlFiles)
xmlFilePlateNames <- rep("", times=length(xmlFiles))
runs <- vector('list', length(xmlFiles))
runSummarys <- vector('list', length(xmlFiles))
read_summary <- NULL
PlateNames <- NULL
for(i in 1:length(xmlFiles)){
  # Read each run1
  plateID <- if(xmlFilePlateNames[i] == "") paste0("plate", i) else xmlFilePlateNames[i]
  runs[[i]] <- readNULISAseq(xmlFilesPath[i], plateID=plateID)
  xmlFilePlateNames[i] <- plateID
  ICs  <- runs[[i]]$targets$targetName[which(grepl(paste(IC, collapse="|"),  runs[[i]]$targets$targetName))]
  IPCs <- runs[[i]]$samples$sampleName[which(grepl(paste(IPC, collapse="|"), runs[[i]]$samples$sampleName))]
  NCs  <- runs[[i]]$samples$sampleName[which(grepl(paste(NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  IPCs <- paste0(plateID, "_", IPCs)
  NCs  <- paste0(plateID, "_", NCs)

  # Summarize each Plate
  runSummarys[[i]] <- plateSummary(runs[[i]], ICs=ICs, IPCs=IPCs, NCs=NCs)
  read_summary <- cbind(read_summary,runSummarys[[i]]$readsTable)
  PlateNames <- c(PlateNames, paste("Plate", i, sep=" "))
}
names(runs) <- xmlFilePlateNames
names(runSummarys) <- xmlFilePlateNames
colnames(read_summary) <- PlateNames
rownames(read_summary)[length(xmlFiles)] <- 'Total samples * targets'
read_summary <- t(read_summary)
```

```{r, include=FALSE}
run_lod <- vector('list',length(xmlFiles))
for (i in 1:length(xmlFiles)){
  # replace NAs with 0
  runs[[i]]$Data[is.na(runs[[i]]$Data)] <- 0

  # calculate LODs 
  NCs  <- runs[[i]]$samples$sampleName[which(grepl(paste(NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  plateID <- if(xmlFilePlateNames[i] == "") paste0("plate", i) else xmlFilePlateNames[i]
  NCs  <- paste0(plateID, "_", NCs)
  run_lod[[i]] <- lod(data_matrix=runs[[i]]$Data, blanks=NCs, min_count=0)
}
```

```{r, include=FALSE}
# do intra-plate normalizations
plateNorms <- vector("list", length(xmlFiles))
for (i in 1:length(xmlFiles)){
  plateNorms[[i]] <- vector("list", length(ICs))
  for (j in 1:length(ICs)){
    plateNorms[[i]][[j]] <- intraPlateNorm(data_matrix=runs[[i]]$Data,
                               method="IC",
                               IC=ICs[j])
  }
  names(plateNorms[[i]]) <- ICs
}
names(plateNorms) <- xmlFilePlateNames
```

```{r, include=FALSE}
# do inter-plate normalization 

normData <- list()
IPC_wells <- list(list())
NC_wells <- list(list())
Bridge_wells <- list(list())
IPC_wells_orig <- list(list())
NC_wells_orig <- list(list())
Bridge_wells_orig <- list(list())
for (i in 1:length(xmlFiles)){
  normData[[i]] <- plateNorms[[i]]$mCherry$normData
  IPC_wells_orig[[i]] <- runs[[i]]$samples$sampleName[which(grepl(paste(IPC, collapse="|"), runs[[i]]$samples$sampleName))]
  plateID <- if(xmlFilePlateNames[i] == "") paste0("run", i) else xmlFilePlateNames[i]
  if(!is.null(Bridge)){
    Bridge_wells_orig[[i]] <-runs[[i]]$samples$sampleName[which(grepl(paste(Bridge, collapse="|"), runs[[i]]$samples$sampleName))]
    Bridge_wells[[i]] <- paste0(plateID,"_", Bridge_wells_orig[[i]])
  }
  IPC_wells[[i]] <- paste0(plateID, "_", IPC_wells_orig[[i]])
  NC_wells_orig[[i]]  <- runs[[i]]$samples$sampleName[which(grepl(paste(NC, collapse="|"),  runs[[i]]$samples$sampleName))]
  NC_wells[[i]]  <- paste0(plateID, "_", NC_wells_orig[[i]]) 
} 

# using intra-plate means
# mCherry + IPC
mCherry_IPC <- interPlateNorm(data_list=normData,
                              IPC=TRUE, IN=FALSE,
                              IPC_wells=IPC_wells,
                              IPC_method='median')
# using intra-plate means
# mCherry + IN
mCherry_IN <- interPlateNorm(data_list=normData,
                              IPC=FALSE, IN=TRUE,
                              IPC_wells=IPC_wells,
                              NC_wells=NC_wells
                            )
```

```{r, include=FALSE}
# do inter-plate bridge sample normalization 
# mCherry + bridge
if(length(Bridge_wells[[1]])){
  mCherry_bridge <- interPlateNorm(data_list=normData,
                                 IPC=FALSE, IN=TRUE,
                                 IN_samples=Bridge_wells
                                  )
}
```

```{r, include=FALSE}
# calculate intra-plate CVs unnormalized
# using the sample controls 

intraCV_unnorm <- NULL
intraCV_mCherry <- NULL
for (i in 1:length(xmlFiles)){
  sc <- rep(NA, 96)
  sc[colnames(runs[[i]]$Data) %in% IPC_wells[[i]]]<- 'SC'
  plate_unnorm_intraCV <- intraCV(data_matrix=runs[[i]]$Data,
                                 samples=sc,
                                 aboveLOD=run_lod[[i]]$aboveLOD,
                                 exclude_targets=ICs)
# combine plates into one matrix
  intraCV_unnorm <- cbind(intraCV_unnorm, plate_unnorm_intraCV) 
  plate_mCherry_intraCV <- intraCV(data_matrix=plateNorms[[i]]$mCherry$normData,
                                  samples=sc,
                                  aboveLOD=run_lod[[i]]$aboveLOD,
                                  exclude_targets=ICs)
  intraCV_mCherry <- cbind(intraCV_mCherry, plate_mCherry_intraCV)
}

colnames(intraCV_unnorm) <- PlateNames

# calculate intra-plate CVs mCherry
colnames(intraCV_mCherry) <- PlateNames

# create intra-plate CV table
intraCV_unnorm_summary_table <- cbind(colMeans(intraCV_unnorm, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, sd, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, median, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, min, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, max, na.rm=TRUE),
                                      apply(intraCV_unnorm, 2, function(x){
                                        sum(is.na(x))
                                      }))


rownames(intraCV_unnorm_summary_table) <- PlateNames
colnames(intraCV_unnorm_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')

# create intra-plate CV table
intraCV_mCherry_summary_table <- cbind(colMeans(intraCV_mCherry, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, sd, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, median, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, min, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, max, na.rm=TRUE),
                                       apply(intraCV_mCherry, 2, function(x){
                                         sum(is.na(x))
                                       }))

rownames(intraCV_mCherry_summary_table) <- PlateNames
colnames(intraCV_mCherry_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# calculate inter-plate CVs 
# using individual replicates

# run-run plates 1-6
# un-normalized data
scs <- vector("list", length(xmlFiles))
plateData <- vector("list", length(xmlFiles))
aboveLOD <- vector("list", length(xmlFiles))
exclude_targets <- vector("list", length(xmlFiles))
plate_mCherry <- vector("list", length(xmlFiles))
for(i in 1:length(xmlFiles)){
  sc <- rep(NA, 96)
  sc[colnames(runs[[i]]$Data) %in% IPC_wells[[i]]]<- 'SC'
  scs[[i]] <- sc
  plateData[[i]] <- runs[[i]]$Data
  aboveLOD[[i]] <- run_lod[[i]]$aboveLOD
  exclude_targets[[i]] <- ICs
  plate_mCherry[[i]] <- plateNorms[[i]]$mCherry$normData
}
interCV_unnorm <- interCV(data_list=plateData,
                          samples=scs,
                          aboveLOD=aboveLOD,
                          exclude_targets=exclude_targets,
                          useMean=FALSE)

# mCherry normalized data
interCV_mCherry <- interCV(data_list=plate_mCherry,
                           samples=scs,
                           aboveLOD=aboveLOD,
                           exclude_targets=exclude_targets,
                           useMean=FALSE)

# mCherry + IPC normalized data
interCV_mCherry_IPC <- interCV(data_list=mCherry_IPC$interNormData,
                               samples=scs,
                               aboveLOD=aboveLOD,
                               exclude_targets=exclude_targets,
                               useMean=FALSE)

# mCherry + IN normalized data
interCV_mCherry_IN <- interCV(data_list=mCherry_IN$interNormData,
                              samples=scs,
                              aboveLOD=aboveLOD,
                              exclude_targets=exclude_targets,
                              useMean=FALSE)

# mCherry + bridge sample normalized data
if(length(Bridge_wells[[1]])){
  interCV_mCherry_bridge <- interCV(data_list=mCherry_bridge$interNormData,
                                  samples=scs,
                                  aboveLOD=aboveLOD,
                                  exclude_targets=exclude_targets,
                                  useMean=FALSE)
}

# combine results into one matrix
interCV_results <- NULL
if(length(Bridge_wells[[1]])){
  interCV_results <- cbind(interCV_unnorm,
                         interCV_mCherry,
                         interCV_mCherry_IPC,
                         interCV_mCherry_IN,
                         interCV_mCherry_bridge)
  colnames(interCV_results) <- c('unnorm',
                               'mCherry',
                               'mCherry + IPC',
                               'mCherry + IN',
                               'mCherry + bridge')
}else{
  interCV_results <- cbind(interCV_unnorm,
                         interCV_mCherry,
                         interCV_mCherry_IPC,
                         interCV_mCherry_IN)
                                  
  colnames(interCV_results) <- c('unnorm',
                               'mCherry',
                               'mCherry + IPC',
                               'mCherry + IN')
}

# create inter-plate CV table
interCV_summary_table <- cbind(colMeans(interCV_results, na.rm=TRUE),
                               apply(interCV_results, 2, sd, na.rm=TRUE),
                               apply(interCV_results, 2, median, na.rm=TRUE),
                               apply(interCV_results, 2, min, na.rm=TRUE),
                               apply(interCV_results, 2, max, na.rm=TRUE),
                               apply(interCV_results, 2, function(x){
                                 sum(is.na(x))
                               }))
if(length(Bridge_wells[[1]])){
  rownames(interCV_summary_table) <- c('unnorm',
                                                 'mCherry',
                                                 'mCherry + IPC',
                                                 'mCherry + IN',
                                                 'mCherry + bridge')
} else{
  rownames(interCV_summary_table) <- c('unnorm',
                                                 'mCherry',
                                                 'mCherry + IPC',
                                                 'mCherry + IN')
}
  colnames(interCV_summary_table) <- c('mean', 'sd', 'median', 'min', 'max', 'missing')
```

```{r, include=FALSE}
# convert data to long format
```

```{r, include=FALSE}
# calculate detectability
detectability_summary <- list()
for (i in 1:length(xmlFiles)){
  detect_samples <- colnames(plateNorms[[i]]$mCherry$normData)
  detect_samples <- detect_samples[-which(grepl(paste(IPC, collapse="|"), detect_samples))]
  detect_samples <- detect_samples[-which(grepl(paste(NC, collapse="|"), detect_samples))]
  detect_samples <- detect_samples[-which(grepl(paste(Bridge, collapse="|"), detect_samples))]
  plate_detect <- detectability(aboveLOD_matrix=run_lod[[i]]$aboveLOD,
                                 sample_subset=detect_samples,
                                 exclude_targets=ICs)
  detectability <- cbind(format(round(mean(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                                 format(round(sd(plate_detect$detectability, na.rm=TRUE), 1), nsmall=1),
                                 median(plate_detect$detectability, na.rm=TRUE),
                                 min(plate_detect$detectability, na.rm=TRUE),
                                 max(plate_detect$detectability, na.rm=TRUE),
                                 paste0(sum(plate_detect$detectability >= 50),
                                        ' (',
                                        format(round(sum(plate_detect$detectability > 50)/length(plate_detect$detectability) * 100, 1), nsmall=1),
                                        '%)'))
  colnames(detectability) <- c('mean',
                                     'sd',
                                     'median',
                                     'min',
                                     'max',
                                     'detectable targets n (%)')
  detectability_summary <- rbind(detectability_summary, detectability)
}
rownames(detectability_summary) <- PlateNames
```

```{r, include=FALSE}
# sample clustering
data_mCherry_scaled <- list(list())
for(i in 1:length(xmlFiles)){
  data_mCherry_scaled[[i]] <- scale(log2(plateNorms[[i]]$mCherry$normData+0.01))
#  colnames(data_mCherry_scaled[[i]]) <- paste0(sample_info$personID, '_', 
#                                        sample_info$sample, 
#                                        '_',
#                                        sample_info$sampleName)
}
```

---
title: `r title_var`
---

## Summary
* **Goal:** `r goal_desc`.
* Sample description: `r sample_desc`


---

## Plate layout
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  well_order <- wellorder(runs[[i]]$samples, rowAnnotName, colAnnotName)
  val <- matrix(runs[[i]]$samples[well_order,]$sampleName, nrow=8, byrow=T)
  colnames(val) <- 1:12
  rownames(val) <- LETTERS[1:8]
  B_well_orig <- if (!is.null(Bridge)) Bridge_wells_orig[[i]] else NULL
  well_types <- list(B_well_orig, IPC_wells_orig[[i]], NC_wells_orig[[i]])
  for (j in 1:length(well_types)){
    if (j == 1 && is.null(Bridge)){
      next
    }
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), val))
    if(length(inds) > 0){
      val[inds] <- cell_spec(val[inds], "html", background=boxplot_colors[j+1])
    }
  }
  cat(knitr::kable(val, caption=paste0("Plate ", as.character(i), ": Plate/Sample Layout"), align="c",escape=F) %>% kable_styling(font_size=9))
}
```

---

## Read summary
```{r, results='asis'}
knitr::kable(read_summary, caption='', align='r', format.args=list(big.mark = ",")) %>% kable_styling()
```

---

### Internal control (IC)
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  cat(knitr::kable(runSummarys[[i]]$IC_table, caption=paste0("Plate ", as.character(i), ": IC summary"), align='r', format.args=list(big.mark = ",")) %>% kable_styling())  
}
```

---

### Inter-plate control (IPC)
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  cat(knitr::kable(runSummarys[[i]]$IPC_table, caption=paste0("Plate ", as.character(i), ": IPC summary"), align='r', format.args=list(big.mark = ",")) %>% kable_styling())
}
```
---

### Negative control (NC) 
```{r, results='asis'}
for(i in 1:length(xmlFiles)){
  cat(knitr::kable(runSummarys[[i]]$NC_table, caption=paste0("Plate ", as.character(i), ": NC summaray"), align='r', format.args=list(big.mark = ",")) %>% kable_styling())
}
```

---

### Heatmap
```{r, out.width='100%', fig.asp=1.2}

for(i in 1:length(xmlFiles)){
  well_order <- wellorder(runs[[i]]$samples, rowAnnotName, colAnnotName)
  par(mfrow=c(ceiling((length(ICs)+1)/2),2), oma=c(1,1,1,1), mar=c(0,2,2,0), pty="s")
  for (j in 1:length(ICs)){
    plateHeatmap(runs[[i]]$Data[ICs[j],], title=paste0("Plate ", as.character(i),": ",  ICs[j]), cex=0.5, digits=(if(heatMapRel) 3 else 0), well_order=well_order,relative=heatMapRel)
  }
  plateHeatmap(log2(colSums(runs[[i]]$Data, na.rm=TRUE)), title=paste0('Plate ', as.character(i), ": ", 'log2(total counts)'), cex=0.5, digits=3,
               well_order=well_order, relative=heatMapRel)
}
```

---

## Quality Control:
### Intra-plate CV
Only values above LOD were used to calculate %CV (no minimum count requirement). %CV was calculated for each of the 204 targets for the 2 pooled plasma (sample control) replicates (PP).

#### Intra-plate %CV table -- un-normalized
```{r}
knitr::kable(intraCV_unnorm_summary_table, caption='', align='r', 
             format.args=list(big.mark = ",", digits=5)) %>% kable_styling()
```

#### Intra-plate %CV table -- mCherry-normalized
```{r}
knitr::kable(intraCV_mCherry_summary_table, caption='', align='r', 
             format.args=list(big.mark = ",", digits=5)) %>% kable_styling()
```

#### Intra-plate CV boxplots by plate
```{r, out.width='100%', fig.asp=0.8}
par(mfrow=c(1,2))
boxplot(intraCV_unnorm, las=3, ylab='intra-plate CV (%)',
        ylim=c(0, max(c(intraCV_unnorm, intraCV_mCherry), na.rm=TRUE)),
        main='un-normalized',
        col=alamarColorPalette(6))
abline(h=c(0:8*5), col='grey', lty=3)
boxplot(intraCV_mCherry, las=3, ylab='intra-plate CV (%)',
        ylim=c(0, max(c(intraCV_unnorm, intraCV_mCherry), na.rm=TRUE)),
        main='mCherry-normalized',
        col=alamarColorPalette(6))
abline(h=c(0:8*5), col='grey', lty=3)
```

---

### Inter-plate CV
Only values above LOD were used to calculate %CV (no minimum count requirement). %CV was calculated for each of the 204 targets for the 2 pooled plasma (sample control) replicates (PP).

#### Inter-plate %CV table 
```{r}
if (length(xmlFiles) > 1){
  knitr::kable(interCV_summary_table, caption='', align='r', 
             format.args=list(big.mark = ",", digits=5)) %>% kable_styling()
}
```

#### Inter-plate CV boxplot
```{r, out.width='100%', fig.asp=0.8}
if(length(xmlFiles) > 1){
  par(mfrow=c(1,2))
  par(mar=c(8,5,1,1))
  boxplot(interCV_results, las=3, ylab='inter-plate CV (%)',
          col=alamarColorPalette(5))
  abline(h=c(0:16*5), col='grey', lty=3)
}
```

### Sample boxplots
```{r, out.width='100%', fig.asp=1}
for(i in 1:length(xmlFiles)){
  plate_sample_type <- rep("1_sample",96)
  if(!is.null(Bridge)){
    plate_sample_type[grepl(paste0(Bridge_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '2_donor'
  }
  plate_sample_type[grepl(paste0(IPC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '3_IPC'
  plate_sample_type[grepl(paste0(NC_wells[[i]], collapse="|"), colnames(runs[[i]]$Data))] <- '4_NC'

  ordering2 <- wellorder(runs[[i]]$samples, rowAnnotName, colAnnotName) 
  ordering <- NULL
  types <- sort(unique(plate_sample_type))
  for(j in 1:length(types)){
    inds <- which(plate_sample_type[ordering2] == types[j])
    ordering <- c(ordering, ordering2[inds])
  }

  plate_sample_colors <- boxplot_colors[as.numeric(as.factor(plate_sample_type))[ordering]]
  par(mfrow=c(2,1), mar=c(6,3,2,0))
  boxplot(log2(runs[[i]]$Data[,ordering]+0.01),
          las=1, xaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": unnormalized"),
          outcex=0.5,
          col=plate_sample_colors)
  axis(1, at=1:96, labels=colnames(runs[[i]]$Data)[ordering], cex.axis=0.4, las=3)
  lines(log2(runs[[i]]$Data['mCherry',ordering]+0.01), col='red')
  mtext('log2(count + 0.01)', side=2, line=2)
  legend('topleft', 'mCherry', col='red', lty=1,
         cex=0.4, bty='n')

  boxplot(log2(mCherry_IPC$interNormData[[i]][,ordering]+0.01),
          las=1, xaxt='n',
          ylab='',
          main=paste0("Plate ", as.character(i), ": mCherry + IPC"),
          outcex=0.5,
          col=plate_sample_colors)
  axis(1, at=1:96, labels=colnames(mCherry_IPC$interNormData[[i]])[ordering], cex.axis=0.4, las=3)
  lines(log2(mCherry_IPC$interNormData[[i]]['mCherry',ordering]+0.01), col='red')
  mtext('log2(count + 0.01)', side=2, line=2)
  legend('topleft', 'mCherry', col='red', lty=1,
         cex=0.4, bty='n')
}
```

### Detectability table
```{r, results='asis'}
kable_styling(knitr::kable(detectability_summary, caption='', align='r', 
             format.args=list(big.mark = ",", digits=5)))
```

## Sample and target clustering 
```{r, out.width='100%', fig.asp=1, results='asis'}
wellcolors <- function(data, well_types, boxplot_colors ){
  mycolors <- rep("black", 96)
  for (j in 1:length(well_types)){
    if (j == 1 && well_types[j] == ""){
      next
    }
    inds <- which(grepl(paste0(well_types[[j]], collapse="|"), colnames(data)))
    if(length(inds) > 0){
      mycolors[inds] <- boxplot_colors[j+1]
    }
  }
  return(mycolors)
}

paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
for(i in 1:length(xmlFiles)){
  pandoc.header(paste("Plate", i), 4)
  B_well_orig <- if (!is.null(Bridge)) Bridge_wells_orig[[i]] else ""
  well_types <- list(B_well_orig, IPC_wells_orig[[i]], NC_wells_orig[[i]])
  mycolors <- wellcolors(data_mCherry_scaled[[i]], well_types, boxplot_colors)
  myBreaks <- c(seq(min(data_mCherry_scaled[[i]]), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(data_mCherry_scaled[[i]])/paletteLength, max(data_mCherry_scaled[[i]]), length.out=floor(paletteLength/2)))
  data_mCherry_scaled2 <- data.frame(t(data_mCherry_scaled[[i]]))
  data_mCherry_scaled2$status <- rep(1, 96) # 
  data_mCherry_scaled2$colors <- mycolors
  e <- pheatmap(data_mCherry_scaled2[,1:(length(data_mCherry_scaled2[1, ]) - 2)],
         main = "", fontsize=5,
         color=myColor,
         breaks=myBreaks,
         show_colnames=FALSE, silent=T)
  cols <- data_mCherry_scaled2[order(match(rownames(data_mCherry_scaled2), e$gtable$grobs[[5]]$label)), ]$colors
  e$gtable$grobs[[5]]$gp=gpar(col=cols)
  grid::grid.newpage()
  grid::grid.draw(e$gtable)
  cat("\n")
}
```

## Sample correlation
```{r, out.width='100%', fig.asp=1, results='asis'}
for(i in 1:length(xmlFiles)){
  pandoc.header(paste("Plate", i), 4)
  pdf(file=NULL)
  corrvals <- corrplot(cor(data_mCherry_scaled[[i]]), order='hclust') 
  dev.off()
  B_well_orig <- if (!is.null(Bridge)) Bridge_wells_orig[[i]] else ""
  well_types <- list(B_well_orig, IPC_wells_orig[[i]], NC_wells_orig[[i]])
  mycolors <- wellcolors(corrvals$corr, well_types, boxplot_colors)
  corrplot(corrvals$corr,
         tl.cex=0.4,
         tl.col=mycolors,
         order="original",
         is.corr=FALSE)
  cat("\n")
}
